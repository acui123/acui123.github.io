---
title: 前端储存方式总结
date: 2021-3-03
tags:
 - 
categories:
 -  前端
---

<Boxx type='tip'  changeTime="6000"/> 

## cookie

网络早期最大的问题之一是如何管理状态。简而言之，服务器无法知道两个请求是否来自同一个浏览器。当时最

简单的方法是在请求时，在页面中插入一些参数，并在下一个请求中传回参数。这需要使用包含参数的隐藏的表

单，或者作为URL参数的一部分传递。这两个解决方案都手动操作，容易出错。cookie出现来解决这个问题。

h5之前，存储主要是cookies。cookies缺点有在请求头上带着数据，大小在4K之内。主Domain污染。

主要应用：购物车、客户记录

对于IE浏览器有UserData,大小是64k,只有IE浏览器支持。
Cookie是保存在客户机的文本文件（IE保存在本地的一个txt文件中）, 这个文件与特定的 Web 文档关联在一

起, 保存了该客户机访问这个Web 文档时的信息, 当客户机再次访问这个 Web 文档时这些信息可供该文档使用。

请求服务器时放在http请求头里面（不论是否需要，都会放在请求头里面）


特征：

不同的浏览器存放的cookie位置不一样，也是不能通用的。

cookie的存储是以域名形式进行区分的，不同的域下存储的cookie是独立的。

我们可以设置cookie生效的域（当前设置cookie所在域的子域），也就是说，我们能够操作的cookie是当前域以及当前域下的所有子域

一个域名下存放的cookie的个数是有限制的，不同的浏览器存放的个数不一样,一般为20个。

每个cookie存放的内容大小也是有限制的，不同的浏览器存放大小不一样，一般为4KB。

cookie也可以设置过期的时间，默认是会话结束的时候，当时间到期自动销毁

目标：

解决4K的大小问题

解决请求体常带储存信息的问题

解决关系型储存的问题

跨浏览器

如何工作：

当网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段

中。这些是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们做。这个特点很重要，因为这关

系到“什么样的数据适合存储在cookie中”。

存储在cookie中的数据，每次都会被浏览器自动放在http请求中，如果这些数据并不是每个请求都需要发给服务

端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据

（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那种设置“每次请求都要携

带的信息（最典型的就是身份认证信息）”就特别适合放在cookie中，其他类型的数据就不适合了。

### 本地存储localstorage
存储方式：以键值对的方式存储，永久存储，永不失效，除非手动删除

大小：每个域名5M

常用的API：

getItem //取记录

setItem //设置记录

removeItem //移除记录

key //取key所对应的值

clear //清除记录

存储的内容：

数组，图片，json,样式，脚本（只要能序列化成字符串的内容都可以存储）

### 本地存储sessionstorage

HTML5的本地存储API中localStorage与sessionStorage在使用方法上是相同的，区别在于sessionStorage在关闭页面后被清空，而localStorage则会一直保存

### cookie、localStorage、sessionStorage区别
相同：在本地（浏览器端）存储数据。

不同：

localStorage、sessionStorage

localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。

sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。

localStorage是永久存储，除非手动删除。

sessionStorage当会话结束（当前页面关闭的时候，自动销毁）

cookie的数据会在每一次发送http请求的时候，同时发送给服务器而localStorage、sessionStorage不会。

### 离线缓存 application cache

本地缓存应用所需的文件

使用方法：

①配置manifest

页面上

```
<!DOCTYPE HTML>

<html manifest="demo.appcache">

...

</html>

```
Manifest文件：

manifest文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。

manifest文件可分为三个部分：

① CACHE MANIFEST 在此标题下列出的文件将在首次下载后缓存

② NETWORK 在此标题下列出的文件需要与服务器的连接，且不会被缓存

③ FALLBACK 在此标题下列出的文件规定当前页面无法访问时的回退页面

完整demo:

```
CACHE MANIFEST

# 2016-07-24 v1.0.0

/theme.css

/main.js

NETWORK:

login.jsp

FALLBACK:

/html/ /offline.html

```
服务器上：manifest文件需要配置正确的MIME-type,即"text/cache-manifest"

如Tomcat:

```
<mime-mapping>

     <extension>manifest</extension>

     <mime-type>text/cache-manifest</mime-type>

</mime-mapping>

```

常用API

核心是applicationCache对象，有个status属性，表示应用缓存的当前状态：

0（UNCACHED） :  无缓存， 即没有与页面相关的应用缓存

1（IDLE） : 闲置，即应用缓存未得到更新

2 （CHECKING） : 检查中，即正在下载描述文件并检查更新

3 （DOWNLOADING） : 下载中，即应用缓存正在下载描述文件中指定的资源

4 （UPDATEREADY） : 更新完成，所有资源都已下载完毕

5 （IDLE） :  废弃，即应用缓存的描述文件已经不存在了，因此页面无法再访问应用缓存

相关的事件：

表示应用缓存状态的改变：

checking : 在浏览器为应用缓存查找更新时触发

error : 在检查更新或下载资源期间发送错误时触发

noupdate : 在检查描述文件发现文件无变化时触发

downloading : 在开始下载应用缓存资源时触发

progress：在文件下载应用缓存的过程中持续不断地下载地触发

updateready : 在页面新的应用缓存下载完毕触发

cached : 在应用缓存完整可用时触发

Application Cache的三个优势：

① 离线浏览

② 提升页面载入速度

③ 降低服务器压力

### Web SQL

关系数据库，通过SQL语句访问

Web SQL 数据库API并不是HTML5规范的一部分，但是它是一个独立的规范，引入了一组使用SQL操作客户端数据库

的APIS

支持情况：

 Web SQL 数据库可以在最新版的 Safari, Chrome 和 Opera 浏览器中工作。

核心方法：

①openDatabase：这个方法使用现有的数据库或者新建的数据库创建一个数据库对象。

②transaction：这个方法让我们能够控制一个事务，以及基于这种情况执行提交或者回滚。

③executeSql：这个方法用于执行实际的 SQL 查询。

### IndexedDB

索引数据库 (IndexedDB) API（作为 HTML5 的一部分）对创建具有丰富本地存储数据的数据密集型的离线 

HTML5 Web 应用程序很有用。同时它还有助于本地缓存数据，使传统在线 Web 应用程序（比如移动 Web 应用程

序）能够更快地运行和响应。

