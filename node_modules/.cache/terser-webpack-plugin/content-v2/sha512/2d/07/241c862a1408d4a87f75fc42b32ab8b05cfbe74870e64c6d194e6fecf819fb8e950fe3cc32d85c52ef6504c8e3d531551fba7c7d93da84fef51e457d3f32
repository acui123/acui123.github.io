{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{613:function(t,a,e){\"use strict\";e.r(a);var s=e(12),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[e(\"h2\",{attrs:{id:\"vuex\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vuex\"}},[t._v(\"#\")]),t._v(\" Vuex\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"什么是vuex\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是vuex\"}},[t._v(\"#\")]),t._v(\" 什么是Vuex\")]),t._v(\" \"),e(\"p\",[t._v(\"vuex是实现组件全局状态数据管理的一种机制，可以方便的实现组件之间的数据共享。可以把vuex看成一个仓库\")]),t._v(\" \"),e(\"p\",[t._v(\"所有的组件都可以把数据存在这里，也可以从这里拿取数据\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"vuex的组成\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vuex的组成\"}},[t._v(\"#\")]),t._v(\" vuex的组成\")]),t._v(\" \"),e(\"p\",[t._v(\"state:存放的公共数据源，所有共享的数据都要统一放到Store的state中进行储存。通过this.$store.state访问\")]),t._v(\" \"),e(\"p\",[t._v(\"Mutation:在vuex中直接修改state里的数据是不对的，这样不安全，使用Mutation来变更修改数据，可以方便后\")]),t._v(\" \"),e(\"p\",[t._v(\"期的维护，找到谁能修改这个数据\")]),t._v(\" \"),e(\"p\",[t._v(\"调用方法：配置好mutation后，在组件中使用，this.$store.commit('方法名称')来修改state的数据\")]),t._v(\" \"),e(\"p\",[t._v(\"action:在mutaion函数中不能写异步函数，定时器之类的，要执行异步任务，使用action属性来执行\")]),t._v(\" \"),e(\"p\",[t._v(\"调用方法：this.$store.dispatch('addAsync')\")]),t._v(\" \"),e(\"p\",[t._v(\"getters:对store中已有的数据进行修改，类似于vuexd的计算属性\")]),t._v(\" \"),e(\"p\",[t._v(\"调用方法：this.store.getters.名称\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"双向绑定的原理\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#双向绑定的原理\"}},[t._v(\"#\")]),t._v(\" 双向绑定的原理\")]),t._v(\" \"),e(\"p\",[t._v(\"Vue双向绑定，使用数据劫持和发布订阅模式实现的。\")]),t._v(\" \"),e(\"p\",[t._v(\"实现的核心是通过Object.defineProperty()对data的每个属性进行了get,set的拦截\")]),t._v(\" \"),e(\"p\",[t._v(\"观察者模型是双向绑定更有效率\")]),t._v(\" \"),e(\"p\",[t._v(\"观察者模式，是一对多的模式。 页面上使用data的地方，都观察着这个data.\")]),t._v(\" \"),e(\"p\",[t._v(\"Object.defineProperty（）\")]),t._v(\" \"),e(\"p\",[t._v(\"有三个参数\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",[e(\"code\",[t._v(\"第一个是属性所在的对象\\n\\n第二个是要操作的属性\\n\\n第三个是被操作的属性（一般是get,set）的特性\\n\\nget:读取属性时触发\\n\\nset:写入属性时触发\\n\")])])]),e(\"p\",[t._v(\"数据劫持就是通过Object.defineProperty,去操作数据的get、set\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"组件间传递数据\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#组件间传递数据\"}},[t._v(\"#\")]),t._v(\" 组件间传递数据\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"vue项目优化\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue项目优化\"}},[t._v(\"#\")]),t._v(\" Vue项目优化\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"mvvm和mvc\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mvvm和mvc\"}},[t._v(\"#\")]),t._v(\" MVVM和MVC\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"computed和watch\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#computed和watch\"}},[t._v(\"#\")]),t._v(\" Computed和Watch\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"v-for和v-if-同时使用的问题\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#v-for和v-if-同时使用的问题\"}},[t._v(\"#\")]),t._v(\" V-for和V-if 同时使用的问题\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"什么时候使用-nexttick\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么时候使用-nexttick\"}},[t._v(\"#\")]),t._v(\" 什么时候使用$nextTick()\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"路由的原理\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#路由的原理\"}},[t._v(\"#\")]),t._v(\" 路由的原理\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"常用事件修饰符\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#常用事件修饰符\"}},[t._v(\"#\")]),t._v(\" 常用事件修饰符\")])])}),[],!1,null,null,null);a.default=v.exports}}]);","extractedComments":[]}