{"remainingRequest":"C:\\Users\\Administrator\\Desktop\\qd\\blog\\vuepress-blog-demo\\xcui-blog\\node_modules\\babel-loader\\lib\\index.js??ref--3-1!C:\\Users\\Administrator\\Desktop\\qd\\blog\\vuepress-blog-demo\\xcui-blog\\node_modules\\@moefe\\vue-aplayer\\dist\\VueAPlayer.common.js","dependencies":[{"path":"C:\\Users\\Administrator\\Desktop\\qd\\blog\\vuepress-blog-demo\\xcui-blog\\node_modules\\@moefe\\vue-aplayer\\dist\\VueAPlayer.common.js","mtime":1544600652000},{"path":"C:\\Users\\Administrator\\Desktop\\qd\\blog\\vuepress-blog-demo\\xcui-blog\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Administrator\\Desktop\\qd\\blog\\vuepress-blog-demo\\xcui-blog\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:dmFyIF90eXBlb2YzID0gcmVxdWlyZSgiQzovVXNlcnMvQWRtaW5pc3RyYXRvci9EZXNrdG9wL3FkL2Jsb2cvdnVlcHJlc3MtYmxvZy1kZW1vL3hjdWktYmxvZy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YiKVsiZGVmYXVsdCJdOwoKcmVxdWlyZSgicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wudG8tc3RyaW5nLXRhZy5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGgudG8tc3RyaW5nLXRhZy5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLmpzb24udG8tc3RyaW5nLXRhZy5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5jcmVhdGUuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5iaW5kLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cy5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmlzLWFycmF5LmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maW5kLWluZGV4LmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmNvbnN0cnVjdG9yLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2UuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy5kYXRlLnRvLXN0cmluZy5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmZsYWdzLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXIuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zb3J0LmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZC5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmV2ZXJzZS5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMucGFyc2UtaW50LmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnN0YXJ0cy13aXRoLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmZpeGVkLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnBhZC1zdGFydC5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzLmpzIik7Cgptb2R1bGUuZXhwb3J0cyA9Ci8qKioqKiovCmZ1bmN0aW9uIChtb2R1bGVzKSB7CiAgLy8gd2VicGFja0Jvb3RzdHJhcAoKICAvKioqKioqLwogIC8vIFRoZSBtb2R1bGUgY2FjaGUKCiAgLyoqKioqKi8KICB2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9OwogIC8qKioqKiovCgogIC8qKioqKiovCiAgLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb24KCiAgLyoqKioqKi8KCiAgZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkgewogICAgLyoqKioqKi8KCiAgICAvKioqKioqLwogICAgLy8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlCgogICAgLyoqKioqKi8KICAgIGlmIChpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkgewogICAgICAvKioqKioqLwogICAgICByZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0czsKICAgICAgLyoqKioqKi8KICAgIH0KICAgIC8qKioqKiovCiAgICAvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKQoKICAgIC8qKioqKiovCgoKICAgIHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHsKICAgICAgLyoqKioqKi8KICAgICAgaTogbW9kdWxlSWQsCgogICAgICAvKioqKioqLwogICAgICBsOiBmYWxzZSwKCiAgICAgIC8qKioqKiovCiAgICAgIGV4cG9ydHM6IHt9CiAgICAgIC8qKioqKiovCgogICAgfTsKICAgIC8qKioqKiovCgogICAgLyoqKioqKi8KICAgIC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvbgoKICAgIC8qKioqKiovCgogICAgbW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7CiAgICAvKioqKioqLwoKICAgIC8qKioqKiovCiAgICAvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkCgogICAgLyoqKioqKi8KCiAgICBtb2R1bGUubCA9IHRydWU7CiAgICAvKioqKioqLwoKICAgIC8qKioqKiovCiAgICAvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZQoKICAgIC8qKioqKiovCgogICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzOwogICAgLyoqKioqKi8KICB9CiAgLyoqKioqKi8KCiAgLyoqKioqKi8KCiAgLyoqKioqKi8KICAvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKQoKICAvKioqKioqLwoKCiAgX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlczsKICAvKioqKioqLwoKICAvKioqKioqLwogIC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlCgogIC8qKioqKiovCgogIF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7CiAgLyoqKioqKi8KCiAgLyoqKioqKi8KICAvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHMKCiAgLyoqKioqKi8KCiAgX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24gKGV4cG9ydHMsIG5hbWUsIGdldHRlcikgewogICAgLyoqKioqKi8KICAgIGlmICghX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7CiAgICAgIC8qKioqKiovCiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7CiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICBnZXQ6IGdldHRlcgogICAgICB9KTsKICAgICAgLyoqKioqKi8KICAgIH0KICAgIC8qKioqKiovCgogIH07CiAgLyoqKioqKi8KCiAgLyoqKioqKi8KICAvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzCgogIC8qKioqKiovCgoKICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbiAoZXhwb3J0cykgewogICAgLyoqKioqKi8KICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHsKICAgICAgLyoqKioqKi8KICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgewogICAgICAgIHZhbHVlOiAnTW9kdWxlJwogICAgICB9KTsKICAgICAgLyoqKioqKi8KICAgIH0KICAgIC8qKioqKiovCgoKICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsKICAgICAgdmFsdWU6IHRydWUKICAgIH0pOwogICAgLyoqKioqKi8KICB9OwogIC8qKioqKiovCgogIC8qKioqKiovCiAgLy8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0CgogIC8qKioqKiovCiAgLy8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0CgogIC8qKioqKiovCiAgLy8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zCgogIC8qKioqKiovCiAgLy8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0CgogIC8qKioqKiovCiAgLy8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZQoKICAvKioqKioqLwoKCiAgX193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24gKHZhbHVlLCBtb2RlKSB7CiAgICAvKioqKioqLwogICAgaWYgKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpOwogICAgLyoqKioqKi8KCiAgICBpZiAobW9kZSAmIDgpIHJldHVybiB2YWx1ZTsKICAgIC8qKioqKiovCgogICAgaWYgKG1vZGUgJiA0ICYmIF90eXBlb2YzKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlOwogICAgLyoqKioqKi8KCiAgICB2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOwogICAgLyoqKioqKi8KCiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpOwogICAgLyoqKioqKi8KCgogICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsKICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgdmFsdWU6IHZhbHVlCiAgICB9KTsKICAgIC8qKioqKiovCgogICAgaWYgKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7CiAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbiAoa2V5KSB7CiAgICAgICAgcmV0dXJuIHZhbHVlW2tleV07CiAgICAgIH0uYmluZChudWxsLCBrZXkpKTsKICAgIH0KICAgIC8qKioqKiovCgogICAgcmV0dXJuIG5zOwogICAgLyoqKioqKi8KICB9OwogIC8qKioqKiovCgogIC8qKioqKiovCiAgLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXMKCiAgLyoqKioqKi8KCgogIF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uIChtb2R1bGUpIHsKICAgIC8qKioqKiovCiAgICB2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID8KICAgIC8qKioqKiovCiAgICBmdW5jdGlvbiBnZXREZWZhdWx0KCkgewogICAgICByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107CiAgICB9IDoKICAgIC8qKioqKiovCiAgICBmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgewogICAgICByZXR1cm4gbW9kdWxlOwogICAgfTsKICAgIC8qKioqKiovCgogICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpOwogICAgLyoqKioqKi8KCgogICAgcmV0dXJuIGdldHRlcjsKICAgIC8qKioqKiovCiAgfTsKICAvKioqKioqLwoKICAvKioqKioqLwogIC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbAoKICAvKioqKioqLwoKCiAgX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHkpIHsKICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7CiAgfTsKICAvKioqKioqLwoKICAvKioqKioqLwogIC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fCgogIC8qKioqKiovCgoKICBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSAiIjsKICAvKioqKioqLwoKICAvKioqKioqLwoKICAvKioqKioqLwogIC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0cwoKICAvKioqKioqLwoKICByZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAiZmIxNSIpOwogIC8qKioqKiovCn0oCi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovCgovKioqKioqLwp7CiAgLyoqKi8KICAiMDFmOSI6CiAgLyoqKi8KICBmdW5jdGlvbiBmOShtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgICJ1c2Ugc3RyaWN0IjsKCiAgICB2YXIgTElCUkFSWSA9IF9fd2VicGFja19yZXF1aXJlX18oIjJkMDAiKTsKCiAgICB2YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oIjVjYTEiKTsKCiAgICB2YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyYWJhIik7CgogICAgdmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIzMmU5Iik7CgogICAgdmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oIjg0ZjIiKTsKCiAgICB2YXIgJGl0ZXJDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI0MWEwIik7CgogICAgdmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygiN2YyMCIpOwoKICAgIHZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oIjM4ZmQiKTsKCiAgICB2YXIgSVRFUkFUT1IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyYjRjIikoJ2l0ZXJhdG9yJyk7CgogICAgdmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgCgogICAgdmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InOwogICAgdmFyIEtFWVMgPSAna2V5cyc7CiAgICB2YXIgVkFMVUVTID0gJ3ZhbHVlcyc7CgogICAgdmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiByZXR1cm5UaGlzKCkgewogICAgICByZXR1cm4gdGhpczsKICAgIH07CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7CiAgICAgICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTsKCiAgICAgIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiBnZXRNZXRob2Qoa2luZCkgewogICAgICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdOwoKICAgICAgICBzd2l0Y2ggKGtpbmQpIHsKICAgICAgICAgIGNhc2UgS0VZUzoKICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsKICAgICAgICAgICAgfTsKCiAgICAgICAgICBjYXNlIFZBTFVFUzoKICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsKICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOwogICAgICAgICAgICB9OwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7CiAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOwogICAgICAgIH07CiAgICAgIH07CgogICAgICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InOwogICAgICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTOwogICAgICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlOwogICAgICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTsKICAgICAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07CiAgICAgIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpOwogICAgICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkOwogICAgICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7CiAgICAgIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlOyAvLyBGaXggbmF0aXZlCgogICAgICBpZiAoJGFueU5hdGl2ZSkgewogICAgICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTsKCiAgICAgICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHsKICAgICAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnMKICAgICAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpOyAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXMKCiAgICAgICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7CiAgICAgICAgfQogICAgICB9IC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkYKCgogICAgICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7CiAgICAgICAgVkFMVUVTX0JVRyA9IHRydWU7CgogICAgICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgewogICAgICAgICAgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsKICAgICAgICB9OwogICAgICB9IC8vIERlZmluZSBpdGVyYXRvcgoKCiAgICAgIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkgewogICAgICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7CiAgICAgIH0gLy8gUGx1ZyBmb3IgbGlicmFyeQoKCiAgICAgIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0OwogICAgICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7CgogICAgICBpZiAoREVGQVVMVCkgewogICAgICAgIG1ldGhvZHMgPSB7CiAgICAgICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLAogICAgICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksCiAgICAgICAgICBlbnRyaWVzOiAkZW50cmllcwogICAgICAgIH07CiAgICAgICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykgewogICAgICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTsKICAgICAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpOwogICAgICB9CgogICAgICByZXR1cm4gbWV0aG9kczsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICIwYTQ5IjoKICAvKioqLwogIGZ1bmN0aW9uIGE0OShtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIC8vIDAgLT4gQXJyYXkjZm9yRWFjaAogICAgLy8gMSAtPiBBcnJheSNtYXAKICAgIC8vIDIgLT4gQXJyYXkjZmlsdGVyCiAgICAvLyAzIC0+IEFycmF5I3NvbWUKICAgIC8vIDQgLT4gQXJyYXkjZXZlcnkKICAgIC8vIDUgLT4gQXJyYXkjZmluZAogICAgLy8gNiAtPiBBcnJheSNmaW5kSW5kZXgKICAgIHZhciBjdHggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI5YjQzIik7CgogICAgdmFyIElPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI2MjZhIik7CgogICAgdmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNGJmOCIpOwoKICAgIHZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oIjlkZWYiKTsKCiAgICB2YXIgYXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXygiY2QxYyIpOwoKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsICRjcmVhdGUpIHsKICAgICAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTsKICAgICAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjsKICAgICAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7CiAgICAgIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDsKICAgICAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7CiAgICAgIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYOwogICAgICB2YXIgY3JlYXRlID0gJGNyZWF0ZSB8fCBhc2M7CiAgICAgIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHsKICAgICAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTsKICAgICAgICB2YXIgc2VsZiA9IElPYmplY3QoTyk7CiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMyk7CiAgICAgICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTsKICAgICAgICB2YXIgaW5kZXggPSAwOwogICAgICAgIHZhciByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkOwogICAgICAgIHZhciB2YWwsIHJlczsKCiAgICAgICAgZm9yICg7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7CiAgICAgICAgICBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikgewogICAgICAgICAgICB2YWwgPSBzZWxmW2luZGV4XTsKICAgICAgICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTsKCiAgICAgICAgICAgIGlmIChUWVBFKSB7CiAgICAgICAgICAgICAgaWYgKElTX01BUCkgcmVzdWx0W2luZGV4XSA9IHJlczsgLy8gbWFwCiAgICAgICAgICAgICAgZWxzZSBpZiAocmVzKSBzd2l0Y2ggKFRZUEUpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgICAgICAvLyBzb21lCgogICAgICAgICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgICAgICAgICAgICAgLy8gZmluZAoKICAgICAgICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDsKICAgICAgICAgICAgICAgICAgLy8gZmluZEluZGV4CgogICAgICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsKTsKICAgICAgICAgICAgICAgICAgLy8gZmlsdGVyCiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7IC8vIGV2ZXJ5CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7CiAgICAgIH07CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiMGJmYiI6CiAgLyoqKi8KICBmdW5jdGlvbiBiZmIobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7IC8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzCgogICAgdmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiY2I3YyIpOwoKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgewogICAgICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpOwogICAgICB2YXIgcmVzdWx0ID0gJyc7CiAgICAgIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJzsKICAgICAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJzsKICAgICAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nOwogICAgICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnOwogICAgICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiMGQ1OCI6CiAgLyoqKi8KICBmdW5jdGlvbiBkNTgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTykKICAgIHZhciAka2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oImNlMTAiKTsKCiAgICB2YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJlMTFlIik7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHsKICAgICAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICIxMTY5IjoKICAvKioqLwogIGZ1bmN0aW9uIF8obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KQogICAgdmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oIjJkOTUiKTsKCiAgICBtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHsKICAgICAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiMTFlOSI6CiAgLyoqKi8KICBmdW5jdGlvbiBlOShtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIHZhciBwSUUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI1MmE3Iik7CgogICAgdmFyIGNyZWF0ZURlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI0NjMwIik7CgogICAgdmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oIjY4MjEiKTsKCiAgICB2YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI2YTk5Iik7CgogICAgdmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oIjY5YTgiKTsKCiAgICB2YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJjNjlhIik7CgogICAgdmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOwogICAgZXhwb3J0cy5mID0gX193ZWJwYWNrX3JlcXVpcmVfXygiOWUxZSIpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7CiAgICAgIE8gPSB0b0lPYmplY3QoTyk7CiAgICAgIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTsKICAgICAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkgewogICAgICAgIHJldHVybiBnT1BEKE8sIFApOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgLyogZW1wdHkgKi8KICAgICAgfQogICAgICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7CiAgICB9OwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICIxNDk1IjoKICAvKioqLwogIGZ1bmN0aW9uIF8obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgZFAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI4NmNjIik7CgogICAgdmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiY2I3YyIpOwoKICAgIHZhciBnZXRLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMGQ1OCIpOwoKICAgIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiOWUxZSIpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHsKICAgICAgYW5PYmplY3QoTyk7CiAgICAgIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTsKICAgICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoOwogICAgICB2YXIgaSA9IDA7CiAgICAgIHZhciBQOwoKICAgICAgd2hpbGUgKGxlbmd0aCA+IGkpIHsKICAgICAgICBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pOwogICAgICB9CgogICAgICByZXR1cm4gTzsKICAgIH07CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgIjE5OTEiOgogIC8qKiovCiAgZnVuY3Rpb24gXyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIHZhciBjdHggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI5YjQzIik7CgogICAgdmFyIGludm9rZSA9IF9fd2VicGFja19yZXF1aXJlX18oIjMxZjQiKTsKCiAgICB2YXIgaHRtbCA9IF9fd2VicGFja19yZXF1aXJlX18oImZhYjIiKTsKCiAgICB2YXIgY2VsID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMjMwZSIpOwoKICAgIHZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI3NzI2Iik7CgogICAgdmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzczsKICAgIHZhciBzZXRUYXNrID0gZ2xvYmFsLnNldEltbWVkaWF0ZTsKICAgIHZhciBjbGVhclRhc2sgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7CiAgICB2YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7CiAgICB2YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7CiAgICB2YXIgY291bnRlciA9IDA7CiAgICB2YXIgcXVldWUgPSB7fTsKICAgIHZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJzsKICAgIHZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDsKCiAgICB2YXIgcnVuID0gZnVuY3Rpb24gcnVuKCkgewogICAgICB2YXIgaWQgPSArdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucwoKICAgICAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkgewogICAgICAgIHZhciBmbiA9IHF1ZXVlW2lkXTsKICAgICAgICBkZWxldGUgcXVldWVbaWRdOwogICAgICAgIGZuKCk7CiAgICAgIH0KICAgIH07CgogICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoZXZlbnQpIHsKICAgICAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7CiAgICB9OyAvLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6CgoKICAgIGlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7CiAgICAgIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHsKICAgICAgICB2YXIgYXJncyA9IFtdOwogICAgICAgIHZhciBpID0gMTsKCiAgICAgICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSB7CiAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pOwogICAgICAgIH0KCiAgICAgICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYwogICAgICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpOwogICAgICAgIH07CgogICAgICAgIGRlZmVyKGNvdW50ZXIpOwogICAgICAgIHJldHVybiBjb3VudGVyOwogICAgICB9OwoKICAgICAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHsKICAgICAgICBkZWxldGUgcXVldWVbaWRdOwogICAgICB9OyAvLyBOb2RlLmpzIDAuOC0KCgogICAgICBpZiAoX193ZWJwYWNrX3JlcXVpcmVfXygiMmQ5NSIpKHByb2Nlc3MpID09ICdwcm9jZXNzJykgewogICAgICAgIGRlZmVyID0gZnVuY3Rpb24gZGVmZXIoaWQpIHsKICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTsKICAgICAgICB9OyAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUEkKCiAgICAgIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7CiAgICAgICAgZGVmZXIgPSBmdW5jdGlvbiBkZWZlcihpZCkgewogICAgICAgICAgRGlzcGF0Y2gubm93KGN0eChydW4sIGlkLCAxKSk7CiAgICAgICAgfTsgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2VycwoKICAgICAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkgewogICAgICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTsKICAgICAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjsKICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyOwogICAgICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpOyAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnMKICAgICAgICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0JwogICAgICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykgewogICAgICAgIGRlZmVyID0gZnVuY3Rpb24gZGVmZXIoaWQpIHsKICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpOwogICAgICAgIH07CgogICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTsgLy8gSUU4LQogICAgICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKSB7CiAgICAgICAgZGVmZXIgPSBmdW5jdGlvbiBkZWZlcihpZCkgewogICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpOwogICAgICAgICAgICBydW4uY2FsbChpZCk7CiAgICAgICAgICB9OwogICAgICAgIH07IC8vIFJlc3Qgb2xkIGJyb3dzZXJzCgogICAgICB9IGVsc2UgewogICAgICAgIGRlZmVyID0gZnVuY3Rpb24gZGVmZXIoaWQpIHsKICAgICAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTsKICAgICAgICB9OwogICAgICB9CiAgICB9CgogICAgbW9kdWxlLmV4cG9ydHMgPSB7CiAgICAgIHNldDogc2V0VGFzaywKICAgICAgY2xlYXI6IGNsZWFyVGFzawogICAgfTsKICAgIC8qKiovCiAgfSwKCiAgLyoqKi8KICAiMWZhOCI6CiAgLyoqKi8KICBmdW5jdGlvbiBmYTgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yCiAgICB2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJjYjdjIik7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykgewogICAgICB0cnkgewogICAgICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7IC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddOwogICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTsKICAgICAgICB0aHJvdyBlOwogICAgICB9CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiMjBkNiI6CiAgLyoqKi8KICBmdW5jdGlvbiBkNihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgICJ1c2Ugc3RyaWN0IjsgLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpCgogICAgdmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI1Y2ExIik7CgogICAgdmFyICRmaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMGE0OSIpKDYpOwoKICAgIHZhciBLRVkgPSAnZmluZEluZGV4JzsKICAgIHZhciBmb3JjZWQgPSB0cnVlOyAvLyBTaG91bGRuJ3Qgc2tpcCBob2xlcwoKICAgIGlmIChLRVkgaW4gW10pIEFycmF5KDEpW0tFWV0oZnVuY3Rpb24gKCkgewogICAgICBmb3JjZWQgPSBmYWxzZTsKICAgIH0pOwogICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHsKICAgICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgoY2FsbGJhY2tmbgogICAgICAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8KICAgICAgKSB7CiAgICAgICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTsKICAgICAgfQogICAgfSk7CgogICAgX193ZWJwYWNrX3JlcXVpcmVfXygiOWM2YyIpKEtFWSk7CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICIyMTRmIjoKICAvKioqLwogIGZ1bmN0aW9uIGYobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7CgogICAgdmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIzMmU5Iik7CgogICAgdmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMmFiYSIpOwoKICAgIHZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oIjc5ZTUiKTsKCiAgICB2YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oImJlMTMiKTsKCiAgICB2YXIgd2tzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMmI0YyIpOwoKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgbGVuZ3RoLCBleGVjKSB7CiAgICAgIHZhciBTWU1CT0wgPSB3a3MoS0VZKTsKICAgICAgdmFyIGZucyA9IGV4ZWMoZGVmaW5lZCwgU1lNQk9MLCAnJ1tLRVldKTsKICAgICAgdmFyIHN0cmZuID0gZm5zWzBdOwogICAgICB2YXIgcnhmbiA9IGZuc1sxXTsKCiAgICAgIGlmIChmYWlscyhmdW5jdGlvbiAoKSB7CiAgICAgICAgdmFyIE8gPSB7fTsKCiAgICAgICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgcmV0dXJuIDc7CiAgICAgICAgfTsKCiAgICAgICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNzsKICAgICAgfSkpIHsKICAgICAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmZuKTsKICAgICAgICBoaWRlKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDIgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKQogICAgICAgIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdKHN0cmluZywgbGltaXQpCiAgICAgICAgPyBmdW5jdGlvbiAoc3RyaW5nLCBhcmcpIHsKICAgICAgICAgIHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOwogICAgICAgIH0gLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpCiAgICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKQogICAgICAgIDogZnVuY3Rpb24gKHN0cmluZykgewogICAgICAgICAgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMpOwogICAgICAgIH0pOwogICAgICB9CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiMjMwZSI6CiAgLyoqKi8KICBmdW5jdGlvbiBlKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgdmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiZDNmNCIpOwoKICAgIHZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oIjc3MjYiKS5kb2N1bWVudDsgLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFCgoKICAgIHZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTsKCiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogICAgICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9OwogICAgfTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgIjIzNTAiOgogIC8qKiovCiAgZnVuY3Rpb24gXyhtb2R1bGUsIGV4cG9ydHMpIHsKICAgIC8qCiAgICAJTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAKICAgIAlBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhCiAgICAqLwogICAgLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXIKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkgewogICAgICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nCgogICAgICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7CiAgICAgICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTsKCiAgICAgICAgICBpZiAoaXRlbVsyXSkgewogICAgICAgICAgICByZXR1cm4gIkBtZWRpYSAiICsgaXRlbVsyXSArICJ7IiArIGNvbnRlbnQgKyAifSI7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gY29udGVudDsKICAgICAgICAgIH0KICAgICAgICB9KS5qb2luKCIiKTsKICAgICAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3QKCgogICAgICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSkgewogICAgICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gInN0cmluZyIpIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICIiXV07CiAgICAgICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTsKCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdOwogICAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gIm51bWJlciIpIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTsKICAgICAgICB9CgogICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICB2YXIgaXRlbSA9IG1vZHVsZXNbaV07IC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGUKICAgICAgICAgIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zCiAgICAgICAgICAvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLgogICAgICAgICAgLy8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcykKCiAgICAgICAgICBpZiAodHlwZW9mIGl0ZW1bMF0gIT09ICJudW1iZXIiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7CiAgICAgICAgICAgIGlmIChtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7CiAgICAgICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVkaWFRdWVyeSkgewogICAgICAgICAgICAgIGl0ZW1bMl0gPSAiKCIgKyBpdGVtWzJdICsgIikgYW5kICgiICsgbWVkaWFRdWVyeSArICIpIjsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgbGlzdC5wdXNoKGl0ZW0pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfTsKCiAgICAgIHJldHVybiBsaXN0OwogICAgfTsKCiAgICBmdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkgewogICAgICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7CiAgICAgIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTsKCiAgICAgIGlmICghY3NzTWFwcGluZykgewogICAgICAgIHJldHVybiBjb250ZW50OwogICAgICB9CgogICAgICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7CiAgICAgICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHsKICAgICAgICAgIHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLyc7CiAgICAgICAgfSk7CiAgICAgICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXG4nKTsKICAgICAgfQoKICAgICAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcbicpOwogICAgfSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpCgoKICAgIGZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHsKICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmCiAgICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpOwogICAgICB2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0OwogICAgICByZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nOwogICAgfQogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiMjNjNiI6CiAgLyoqKi8KICBmdW5jdGlvbiBjNihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIC8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpCiAgICB2YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMmQ5NSIpOwoKICAgIHZhciBUQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyYjRjIikoJ3RvU3RyaW5nVGFnJyk7IC8vIEVTMyB3cm9uZyBoZXJlCgoKICAgIHZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gYXJndW1lbnRzOwogICAgfSgpKSA9PSAnQXJndW1lbnRzJzsgLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3IKCiAgICB2YXIgdHJ5R2V0ID0gZnVuY3Rpb24gdHJ5R2V0KGl0LCBrZXkpIHsKICAgICAgdHJ5IHsKICAgICAgICByZXR1cm4gaXRba2V5XTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIC8qIGVtcHR5ICovCiAgICAgIH0KICAgIH07CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICAgICAgdmFyIE8sIFQsIEI7CiAgICAgIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJyAvLyBAQHRvU3RyaW5nVGFnIGNhc2UKICAgICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVCAvLyBidWlsdGluVGFnIGNhc2UKICAgICAgOiBBUkcgPyBjb2YoTykgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFjawogICAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICIyNjIxIjoKICAvKioqLwogIGZ1bmN0aW9uIF8obW9kdWxlLCBleHBvcnRzKSB7CiAgICBleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzOwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICIyN2VlIjoKICAvKioqLwogIGZ1bmN0aW9uIGVlKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgdmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyM2M2Iik7CgogICAgdmFyIElURVJBVE9SID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMmI0YyIpKCdpdGVyYXRvcicpOwoKICAgIHZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI4NGYyIik7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI4Mzc4IikuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHsKICAgICAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXSB8fCBpdFsnQEBpdGVyYXRvciddIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiMjhhNSI6CiAgLyoqKi8KICBmdW5jdGlvbiBhNShtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIC8vIEBAc3BsaXQgbG9naWMKICAgIF9fd2VicGFja19yZXF1aXJlX18oIjIxNGYiKSgnc3BsaXQnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgU1BMSVQsICRzcGxpdCkgewogICAgICAndXNlIHN0cmljdCc7CgogICAgICB2YXIgaXNSZWdFeHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJhYWUzIik7CgogICAgICB2YXIgX3NwbGl0ID0gJHNwbGl0OwogICAgICB2YXIgJHB1c2ggPSBbXS5wdXNoOwogICAgICB2YXIgJFNQTElUID0gJ3NwbGl0JzsKICAgICAgdmFyIExFTkdUSCA9ICdsZW5ndGgnOwogICAgICB2YXIgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnOwoKICAgICAgaWYgKCdhYmJjJ1skU1BMSVRdKC8oYikqLylbMV0gPT0gJ2MnIHx8ICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fCAnYWInWyRTUExJVF0oLyg/OmFiKSovKVtMRU5HVEhdICE9IDIgfHwgJy4nWyRTUExJVF0oLyguPykoLj8pLylbTEVOR1RIXSAhPSA0IHx8ICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHwgJydbJFNQTElUXSgvLj8vKVtMRU5HVEhdKSB7CiAgICAgICAgdmFyIE5QQ0cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHVuZGVmaW5lZDsgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXAKICAgICAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXQKCiAgICAgICAgJHNwbGl0ID0gZnVuY3Rpb24gJHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHsKICAgICAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7CiAgICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApIHJldHVybiBbXTsgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXQKCiAgICAgICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHJldHVybiBfc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpOwogICAgICAgICAgdmFyIG91dHB1dCA9IFtdOwogICAgICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICsgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgKyAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgKyAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTsKICAgICAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDsKICAgICAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IDQyOTQ5NjcyOTUgOiBsaW1pdCA+Pj4gMDsgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHkKCiAgICAgICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpOwogICAgICAgICAgdmFyIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGgsIGk7IC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydAoKICAgICAgICAgIGlmICghTlBDRykgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yQ29weS5zb3VyY2UgKyAnJCg/IVxccyknLCBmbGFncyk7CgogICAgICAgICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yQ29weS5leGVjKHN0cmluZykpIHsKICAgICAgICAgICAgLy8gYHNlcGFyYXRvckNvcHkubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlcgogICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdW0xFTkdUSF07CgogICAgICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkgewogICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpOyAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3IgTlBDRwogICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmMKCiAgICAgICAgICAgICAgaWYgKCFOUENHICYmIG1hdGNoW0xFTkdUSF0gPiAxKSBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHNbTEVOR1RIXSAtIDI7IGkrKykgewogICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGlmIChtYXRjaFtMRU5HVEhdID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZ1tMRU5HVEhdKSAkcHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTsKICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF1bTEVOR1RIXTsKICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4OwogICAgICAgICAgICAgIGlmIChvdXRwdXRbTEVOR1RIXSA+PSBzcGxpdExpbWl0KSBicmVhazsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KSBzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdKys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nW0xFTkdUSF0pIHsKICAgICAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIG91dHB1dC5wdXNoKCcnKTsKICAgICAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpOwoKICAgICAgICAgIHJldHVybiBvdXRwdXRbTEVOR1RIXSA+IHNwbGl0TGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgc3BsaXRMaW1pdCkgOiBvdXRwdXQ7CiAgICAgICAgfTsgLy8gQ2hha3JhLCBWOAoKICAgICAgfSBlbHNlIGlmICgnMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pIHsKICAgICAgICAkc3BsaXQgPSBmdW5jdGlvbiAkc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkgewogICAgICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiBfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTsKICAgICAgICB9OwogICAgICB9IC8vIDIxLjEuMy4xNyBTdHJpbmcucHJvdG90eXBlLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpCgoKICAgICAgcmV0dXJuIFtmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7CiAgICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpOwogICAgICAgIHZhciBmbiA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdOwogICAgICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChzZXBhcmF0b3IsIE8sIGxpbWl0KSA6ICRzcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7CiAgICAgIH0sICRzcGxpdF07CiAgICB9KTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgIjJhYmEiOgogIC8qKiovCiAgZnVuY3Rpb24gYWJhKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgdmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oIjc3MjYiKTsKCiAgICB2YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oIjMyZTkiKTsKCiAgICB2YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNjlhOCIpOwoKICAgIHZhciBTUkMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJjYTVhIikoJ3NyYycpOwoKICAgIHZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnOwogICAgdmFyICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR107CiAgICB2YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpOwoKICAgIF9fd2VicGFja19yZXF1aXJlX18oIjgzNzgiKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7CiAgICAgIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7CiAgICB9OwoKICAgIChtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkgewogICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJzsKICAgICAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTsKICAgICAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47CiAgICAgIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTsKCiAgICAgIGlmIChPID09PSBnbG9iYWwpIHsKICAgICAgICBPW2tleV0gPSB2YWw7CiAgICAgIH0gZWxzZSBpZiAoIXNhZmUpIHsKICAgICAgICBkZWxldGUgT1trZXldOwogICAgICAgIGhpZGUoTywga2V5LCB2YWwpOwogICAgICB9IGVsc2UgaWYgKE9ba2V5XSkgewogICAgICAgIE9ba2V5XSA9IHZhbDsKICAgICAgfSBlbHNlIHsKICAgICAgICBoaWRlKE8sIGtleSwgdmFsKTsKICAgICAgfSAvLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmUKCiAgICB9KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTsKICAgIH0pOwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICIyYWViIjoKICAvKioqLwogIGZ1bmN0aW9uIGFlYihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIC8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKQogICAgdmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiY2I3YyIpOwoKICAgIHZhciBkUHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIxNDk1Iik7CgogICAgdmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiZTExZSIpOwoKICAgIHZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oIjYxM2IiKSgnSUVfUFJPVE8nKTsKCiAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHsKICAgICAgLyogZW1wdHkgKi8KICAgIH07CgogICAgdmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnOyAvLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlCgogICAgdmFyIF9jcmVhdGVEaWN0ID0gZnVuY3Rpb24gY3JlYXRlRGljdCgpIHsKICAgICAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWcKICAgICAgdmFyIGlmcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oIjIzMGUiKSgnaWZyYW1lJyk7CgogICAgICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDsKICAgICAgdmFyIGx0ID0gJzwnOwogICAgICB2YXIgZ3QgPSAnPic7CiAgICAgIHZhciBpZnJhbWVEb2N1bWVudDsKICAgICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7CgogICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKCJmYWIyIikuYXBwZW5kQ2hpbGQoaWZyYW1lKTsKCiAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmwKICAgICAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDsKICAgICAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpOwoKICAgICAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDsKICAgICAgaWZyYW1lRG9jdW1lbnQub3BlbigpOwogICAgICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7CiAgICAgIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7CiAgICAgIF9jcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjsKCiAgICAgIHdoaWxlIChpLS0pIHsKICAgICAgICBkZWxldGUgX2NyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07CiAgICAgIH0KCiAgICAgIHJldHVybiBfY3JlYXRlRGljdCgpOwogICAgfTsKCiAgICBtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHsKICAgICAgdmFyIHJlc3VsdDsKCiAgICAgIGlmIChPICE9PSBudWxsKSB7CiAgICAgICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pOwogICAgICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpOwogICAgICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsOyAvLyBhZGQgIl9fcHJvdG9fXyIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbAoKICAgICAgICByZXN1bHRbSUVfUFJPVE9dID0gTzsKICAgICAgfSBlbHNlIHJlc3VsdCA9IF9jcmVhdGVEaWN0KCk7CgogICAgICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiMmI0YyI6CiAgLyoqKi8KICBmdW5jdGlvbiBiNGMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI1NTM3IikoJ3drcycpOwoKICAgIHZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJjYTVhIik7CgogICAgdmFyIF9TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI3NzI2IikuU3ltYm9sOwoKICAgIHZhciBVU0VfU1lNQk9MID0gdHlwZW9mIF9TeW1ib2wgPT0gJ2Z1bmN0aW9uJzsKCiAgICB2YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7CiAgICAgIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPSBVU0VfU1lNQk9MICYmIF9TeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBfU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7CiAgICB9OwoKICAgICRleHBvcnRzLnN0b3JlID0gc3RvcmU7CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgIjJkMDAiOgogIC8qKiovCiAgZnVuY3Rpb24gZDAwKG1vZHVsZSwgZXhwb3J0cykgewogICAgbW9kdWxlLmV4cG9ydHMgPSBmYWxzZTsKICAgIC8qKiovCiAgfSwKCiAgLyoqKi8KICAiMmQ5NSI6CiAgLyoqKi8KICBmdW5jdGlvbiBkOTUobW9kdWxlLCBleHBvcnRzKSB7CiAgICB2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZzsKCiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpOwogICAgfTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgIjJlMDgiOgogIC8qKiovCiAgZnVuY3Rpb24gZTA4KG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmQKICAgIHZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oIjlkZWYiKTsKCiAgICB2YXIgcmVwZWF0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiOTc0NCIpOwoKICAgIHZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygiYmUxMyIpOwoKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIG1heExlbmd0aCwgZmlsbFN0cmluZywgbGVmdCkgewogICAgICB2YXIgUyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTsKICAgICAgdmFyIHN0cmluZ0xlbmd0aCA9IFMubGVuZ3RoOwogICAgICB2YXIgZmlsbFN0ciA9IGZpbGxTdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcgJyA6IFN0cmluZyhmaWxsU3RyaW5nKTsKICAgICAgdmFyIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKG1heExlbmd0aCk7CiAgICAgIGlmIChpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpIHJldHVybiBTOwogICAgICB2YXIgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aDsKICAgICAgdmFyIHN0cmluZ0ZpbGxlciA9IHJlcGVhdC5jYWxsKGZpbGxTdHIsIE1hdGguY2VpbChmaWxsTGVuIC8gZmlsbFN0ci5sZW5ndGgpKTsKICAgICAgaWYgKHN0cmluZ0ZpbGxlci5sZW5ndGggPiBmaWxsTGVuKSBzdHJpbmdGaWxsZXIgPSBzdHJpbmdGaWxsZXIuc2xpY2UoMCwgZmlsbExlbik7CiAgICAgIHJldHVybiBsZWZ0ID8gc3RyaW5nRmlsbGVyICsgUyA6IFMgKyBzdHJpbmdGaWxsZXI7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiMmYyMSI6CiAgLyoqKi8KICBmdW5jdGlvbiBmMjEobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7CgogICAgdmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNzllNSIpOwoKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7CiAgICAgIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7CiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbAogICAgICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uICgpIHsKICAgICAgICAgIC8qIGVtcHR5ICovCiAgICAgICAgfSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTsKICAgICAgfSk7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiMmZkYiI6CiAgLyoqKi8KICBmdW5jdGlvbiBmZGIobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7IC8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApCgogICAgdmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI1Y2ExIik7CgogICAgdmFyIGNvbnRleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJkMmM4Iik7CgogICAgdmFyIElOQ0xVREVTID0gJ2luY2x1ZGVzJzsKICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogX193ZWJwYWNrX3JlcXVpcmVfXygiNTE0NyIpKElOQ0xVREVTKSwgJ1N0cmluZycsIHsKICAgICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZwogICAgICAvKiAsIHBvc2l0aW9uID0gMCAqLwogICAgICApIHsKICAgICAgICByZXR1cm4gISF+Y29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIElOQ0xVREVTKS5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpOwogICAgICB9CiAgICB9KTsKICAgIC8qKiovCiAgfSwKCiAgLyoqKi8KICAiMzFmNCI6CiAgLyoqKi8KICBmdW5jdGlvbiBmNChtb2R1bGUsIGV4cG9ydHMpIHsKICAgIC8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNQogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHsKICAgICAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkOwoKICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkgewogICAgICAgIGNhc2UgMDoKICAgICAgICAgIHJldHVybiB1biA/IGZuKCkgOiBmbi5jYWxsKHRoYXQpOwoKICAgICAgICBjYXNlIDE6CiAgICAgICAgICByZXR1cm4gdW4gPyBmbihhcmdzWzBdKSA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7CgogICAgICAgIGNhc2UgMjoKICAgICAgICAgIHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTsKCiAgICAgICAgY2FzZSAzOgogICAgICAgICAgcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSkgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pOwoKICAgICAgICBjYXNlIDQ6CiAgICAgICAgICByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKSA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7CiAgICAgIH0KCiAgICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmdzKTsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICIzMmU5IjoKICAvKioqLwogIGZ1bmN0aW9uIGU5KG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgdmFyIGRQID0gX193ZWJwYWNrX3JlcXVpcmVfXygiODZjYyIpOwoKICAgIHZhciBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNDYzMCIpOwoKICAgIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiOWUxZSIpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkgewogICAgICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpOwogICAgfSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHsKICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTsKICAgICAgcmV0dXJuIG9iamVjdDsKICAgIH07CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgIjMzYTQiOgogIC8qKiovCiAgZnVuY3Rpb24gYTQobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yCiAgICB2YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiODRmMiIpOwoKICAgIHZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oIjJiNGMiKSgnaXRlcmF0b3InKTsKCiAgICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTsKCiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogICAgICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpOwogICAgfTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgIjM3ZTciOgogIC8qKiovCiAgZnVuY3Rpb24gZTcobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7CgogICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pOwogICAgLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLwoKCiAgICBfX3dlYnBhY2tfZXhwb3J0c19fWyJkZWZhdWx0Il0gPSB7CiAgICAgIGZ1bmN0aW9uYWw6IHRydWUsCiAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKF9oLCBfdm0pIHsKICAgICAgICB2YXIgX2MgPSBfdm0uX2M7CiAgICAgICAgcmV0dXJuIF9jKCdzdmcnLCB7CiAgICAgICAgICAiY2xhc3MiOiBbX3ZtLmRhdGFbImNsYXNzIl0sIF92bS5kYXRhLnN0YXRpY0NsYXNzXSwKICAgICAgICAgIHN0eWxlOiBbX3ZtLmRhdGEuc3R5bGUsIF92bS5kYXRhLnN0YXRpY1N0eWxlXSwKICAgICAgICAgIGF0dHJzOiB7CiAgICAgICAgICAgICJ4bWxucyI6ICJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIsCiAgICAgICAgICAgICJ2aWV3Qm94IjogIjAgMCAzMiAzMiIKICAgICAgICAgIH0KICAgICAgICB9LCBbX2MoJ3BhdGgnLCB7CiAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAiZCI6ICJNMjUuNDY4IDYuOTQ3YTEuMDA0IDEuMDA0IDAgMCAwLTEuMDMuMDU3TDE4IDExLjM4NFY3LjgzMWExLjAwMSAxLjAwMSAwIDAgMC0xLjU2Mi0uODI3bC0xMiA4LjE2NGExIDEgMCAwIDAgMCAxLjY1NGwxMiA4LjE2OEEuOTk5Ljk5OSAwIDAgMCAxOCAyNC4xNjR2LTMuNTU2bDYuNDM4IDQuMzgyQS45OTkuOTk5IDAgMCAwIDI2IDI0LjE2NFY3LjgzMWMwLS4zNzEtLjIwNS0uNzEtLjUzMi0uODg0eiIKICAgICAgICAgIH0KICAgICAgICB9KV0pOwogICAgICB9CiAgICB9OwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICIzODQ2IjoKICAvKioqLwogIGZ1bmN0aW9uIF8obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAvLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFncygpCiAgICBpZiAoX193ZWJwYWNrX3JlcXVpcmVfXygiOWUxZSIpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI4NmNjIikuZihSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnLCB7CiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgICAgZ2V0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKCIwYmZiIikKICAgIH0pOwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICIzODZiIjoKICAvKioqLwogIGZ1bmN0aW9uIGIobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oIjVjYTEiKTsKCiAgICB2YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI3OWU1Iik7CgogICAgdmFyIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJiZTEzIik7CgogICAgdmFyIHF1b3QgPSAvIi9nOyAvLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSkKCiAgICB2YXIgY3JlYXRlSFRNTCA9IGZ1bmN0aW9uIGNyZWF0ZUhUTUwoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHsKICAgICAgdmFyIFMgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTsKICAgICAgdmFyIHAxID0gJzwnICsgdGFnOwogICAgICBpZiAoYXR0cmlidXRlICE9PSAnJykgcDEgKz0gJyAnICsgYXR0cmlidXRlICsgJz0iJyArIFN0cmluZyh2YWx1ZSkucmVwbGFjZShxdW90LCAnJnF1b3Q7JykgKyAnIic7CiAgICAgIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nOwogICAgfTsKCiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCBleGVjKSB7CiAgICAgIHZhciBPID0ge307CiAgICAgIE9bTkFNRV0gPSBleGVjKGNyZWF0ZUhUTUwpOwogICAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsKICAgICAgICB2YXIgdGVzdCA9ICcnW05BTUVdKCciJyk7CiAgICAgICAgcmV0dXJuIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSB8fCB0ZXN0LnNwbGl0KCciJykubGVuZ3RoID4gMzsKICAgICAgfSksICdTdHJpbmcnLCBPKTsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICIzOGZkIjoKICAvKioqLwogIGZ1bmN0aW9uIGZkKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTykKICAgIHZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI2OWE4Iik7CgogICAgdmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNGJmOCIpOwoKICAgIHZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oIjYxM2IiKSgnSUVfUFJPVE8nKTsKCiAgICB2YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlOwoKICAgIG1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7CiAgICAgIE8gPSB0b09iamVjdChPKTsKICAgICAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTsKCiAgICAgIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7CiAgICAgICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlOwogICAgICB9CgogICAgICByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICI0MWEwIjoKICAvKioqLwogIGZ1bmN0aW9uIGEwKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgInVzZSBzdHJpY3QiOwoKICAgIHZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyYWViIik7CgogICAgdmFyIGRlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI0NjMwIik7CgogICAgdmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygiN2YyMCIpOwoKICAgIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9OyAvLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKQoKICAgIF9fd2VicGFja19yZXF1aXJlX18oIjMyZTkiKShJdGVyYXRvclByb3RvdHlwZSwgX193ZWJwYWNrX3JlcXVpcmVfXygiMmI0YyIpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiB0aGlzOwogICAgfSk7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHsKICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7CiAgICAgICAgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KQogICAgICB9KTsKICAgICAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiNDU2ZCI6CiAgLyoqKi8KICBmdW5jdGlvbiBkKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pCiAgICB2YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI0YmY4Iik7CgogICAgdmFyICRrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMGQ1OCIpOwoKICAgIF9fd2VicGFja19yZXF1aXJlX18oIjVlZGEiKSgna2V5cycsIGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpIHsKICAgICAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTsKICAgICAgfTsKICAgIH0pOwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiNDU4OCI6CiAgLyoqKi8KICBmdW5jdGlvbiBfKG1vZHVsZSwgZXhwb3J0cykgewogICAgLy8gNy4xLjQgVG9JbnRlZ2VyCiAgICB2YXIgY2VpbCA9IE1hdGguY2VpbDsKICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICAgICAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiNDYzMCI6CiAgLyoqKi8KICBmdW5jdGlvbiBfKG1vZHVsZSwgZXhwb3J0cykgewogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkgewogICAgICByZXR1cm4gewogICAgICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksCiAgICAgICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLAogICAgICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLAogICAgICAgIHZhbHVlOiB2YWx1ZQogICAgICB9OwogICAgfTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgIjQ3MTMiOgogIC8qKiovCiAgZnVuY3Rpb24gXyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgICJ1c2Ugc3RyaWN0IjsKCiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7CiAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovCgoKICAgIF9fd2VicGFja19leHBvcnRzX19bImRlZmF1bHQiXSA9IHsKICAgICAgZnVuY3Rpb25hbDogdHJ1ZSwKICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoX2gsIF92bSkgewogICAgICAgIHZhciBfYyA9IF92bS5fYzsKICAgICAgICByZXR1cm4gX2MoJ3N2ZycsIHsKICAgICAgICAgICJjbGFzcyI6IFtfdm0uZGF0YVsiY2xhc3MiXSwgX3ZtLmRhdGEuc3RhdGljQ2xhc3NdLAogICAgICAgICAgc3R5bGU6IFtfdm0uZGF0YS5zdHlsZSwgX3ZtLmRhdGEuc3RhdGljU3R5bGVdLAogICAgICAgICAgYXR0cnM6IHsKICAgICAgICAgICAgInhtbG5zIjogImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiwKICAgICAgICAgICAgInZpZXdCb3giOiAiMCAwIDMyIDMyIgogICAgICAgICAgfQogICAgICAgIH0sIFtfYygncGF0aCcsIHsKICAgICAgICAgIGF0dHJzOiB7CiAgICAgICAgICAgICJkIjogIk0yNi42NjcgNS4zMzNINS4zMzRoLS4wMDFhMi42NjcgMi42NjcgMCAwIDAtMi42NjYgMi42NjZWMjQuMDAxYTIuNjY3IDIuNjY3IDAgMCAwIDIuNjY2IDIuNjY2aDIxLjMzNWEyLjY2NyAyLjY2NyAwIDAgMCAyLjY2Ni0yLjY2NlY4di0uMDAxYTIuNjY3IDIuNjY3IDAgMCAwLTIuNjY2LTIuNjY2aC0uMDAxek01LjMzMyAxNmg1LjMzM3YyLjY2N0g1LjMzM1YxNnptMTMuMzM0IDhINS4zMzR2LTIuNjY3aDEzLjMzM1YyNHptOCAwaC01LjMzM3YtMi42NjdoNS4zMzNWMjR6bTAtNS4zMzNIMTMuMzM0VjE2aDEzLjMzM3YyLjY2N3oiCiAgICAgICAgICB9CiAgICAgICAgfSldKTsKICAgICAgfQogICAgfTsKICAgIC8qKiovCiAgfSwKCiAgLyoqKi8KICAiNDc1YSI6CiAgLyoqKi8KICBmdW5jdGlvbiBhKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgInVzZSBzdHJpY3QiOwoKICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTsKICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8KCgogICAgX193ZWJwYWNrX2V4cG9ydHNfX1siZGVmYXVsdCJdID0gewogICAgICBmdW5jdGlvbmFsOiB0cnVlLAogICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihfaCwgX3ZtKSB7CiAgICAgICAgdmFyIF9jID0gX3ZtLl9jOwogICAgICAgIHJldHVybiBfYygnc3ZnJywgewogICAgICAgICAgImNsYXNzIjogW192bS5kYXRhWyJjbGFzcyJdLCBfdm0uZGF0YS5zdGF0aWNDbGFzc10sCiAgICAgICAgICBzdHlsZTogW192bS5kYXRhLnN0eWxlLCBfdm0uZGF0YS5zdGF0aWNTdHlsZV0sCiAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAieG1sbnMiOiAiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLAogICAgICAgICAgICAidmlld0JveCI6ICIwIDAgMzIgMzIiCiAgICAgICAgICB9CiAgICAgICAgfSwgW19jKCdwYXRoJywgewogICAgICAgICAgYXR0cnM6IHsKICAgICAgICAgICAgImQiOiAiTS42MjIgMTguMzM0aDE5LjU0djcuNTVsMTEuMDUyLTkuNDEyLTExLjA1Mi05LjQxM3Y3LjU0OUguNjIydjMuNzI1eiIKICAgICAgICAgIH0KICAgICAgICB9KV0pOwogICAgICB9CiAgICB9OwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICI0OGQzIjoKICAvKioqLwogIGZ1bmN0aW9uIGQzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgInVzZSBzdHJpY3QiOwoKICAgIGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHsKICAgICAgZm9yICh2YXIgcCBpbiBtKSB7CiAgICAgICAgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTsKICAgICAgfQogICAgfQoKICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsKICAgICAgdmFsdWU6IHRydWUKICAgIH0pOwoKICAgIF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oImIzNDkiKSk7CgogICAgdmFyIG1vZGlmaWVyc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNjZhMSIpOwoKICAgIGV4cG9ydHMubW9kaWZpZXJzID0gbW9kaWZpZXJzXzEubW9kaWZpZXJzOwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICI0OTE3IjoKICAvKioqLwogIGZ1bmN0aW9uIF8obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAvLyBAQG1hdGNoIGxvZ2ljCiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyMTRmIikoJ21hdGNoJywgMSwgZnVuY3Rpb24gKGRlZmluZWQsIE1BVENILCAkbWF0Y2gpIHsKICAgICAgLy8gMjEuMS4zLjExIFN0cmluZy5wcm90b3R5cGUubWF0Y2gocmVnZXhwKQogICAgICByZXR1cm4gW2Z1bmN0aW9uIG1hdGNoKHJlZ2V4cCkgewogICAgICAgICd1c2Ugc3RyaWN0JzsKCiAgICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpOwogICAgICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdOwogICAgICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpOwogICAgICB9LCAkbWF0Y2hdOwogICAgfSk7CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICI0OTllIjoKICAvKioqLwogIGZ1bmN0aW9uIGUobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7CgogICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pOyAvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanMKCiAgICAvKioKICAgICAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmcKICAgICAqIGVhc2llciB0byBtYW5pcHVsYXRlLgogICAgICovCgoKICAgIGZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdCkgewogICAgICB2YXIgc3R5bGVzID0gW107CiAgICAgIHZhciBuZXdTdHlsZXMgPSB7fTsKCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciBpdGVtID0gbGlzdFtpXTsKICAgICAgICB2YXIgaWQgPSBpdGVtWzBdOwogICAgICAgIHZhciBjc3MgPSBpdGVtWzFdOwogICAgICAgIHZhciBtZWRpYSA9IGl0ZW1bMl07CiAgICAgICAgdmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107CiAgICAgICAgdmFyIHBhcnQgPSB7CiAgICAgICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLAogICAgICAgICAgY3NzOiBjc3MsCiAgICAgICAgICBtZWRpYTogbWVkaWEsCiAgICAgICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcAogICAgICAgIH07CgogICAgICAgIGlmICghbmV3U3R5bGVzW2lkXSkgewogICAgICAgICAgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHsKICAgICAgICAgICAgaWQ6IGlkLAogICAgICAgICAgICBwYXJ0czogW3BhcnRdCiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHN0eWxlczsKICAgIH0gLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzCgogICAgLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovCgoKICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCAiZGVmYXVsdCIsIGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIGFkZFN0eWxlc0NsaWVudDsKICAgIH0pOwogICAgLyoKICAgICAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAKICAgICAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYQogICAgICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzCiAgICAqLwoKCiAgICB2YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnOwoKICAgIGlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7CiAgICAgIGlmICghaGFzRG9jdW1lbnQpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArICJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LiIpOwogICAgICB9CiAgICB9CiAgICAvKgogICAgdHlwZSBTdHlsZU9iamVjdCA9IHsKICAgICAgaWQ6IG51bWJlcjsKICAgICAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD4KICAgIH0KICAgIAogICAgdHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7CiAgICAgIGNzczogc3RyaW5nOwogICAgICBtZWRpYTogc3RyaW5nOwogICAgICBzb3VyY2VNYXA6ID9zdHJpbmcKICAgIH0KICAgICovCgoKICAgIHZhciBzdHlsZXNJbkRvbSA9IHsKICAgICAgLyoKICAgICAgW2lkOiBudW1iZXJdOiB7CiAgICAgIGlkOiBudW1iZXIsCiAgICAgIHJlZnM6IG51bWJlciwKICAgICAgcGFydHM6IEFycmF5PChvYmo/OiBTdHlsZU9iamVjdFBhcnQpID0+IHZvaWQ+CiAgICAgIH0KICAgICAgKi8KICAgIH07CiAgICB2YXIgaGVhZCA9IGhhc0RvY3VtZW50ICYmIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0pOwogICAgdmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsOwogICAgdmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwOwogICAgdmFyIGlzUHJvZHVjdGlvbiA9IGZhbHNlOwoKICAgIHZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9OwoKICAgIHZhciBvcHRpb25zID0gbnVsbDsKICAgIHZhciBzc3JJZEtleSA9ICdkYXRhLXZ1ZS1zc3ItaWQnOyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT4KICAgIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2UKCiAgICB2YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTsKCiAgICBmdW5jdGlvbiBhZGRTdHlsZXNDbGllbnQocGFyZW50SWQsIGxpc3QsIF9pc1Byb2R1Y3Rpb24sIF9vcHRpb25zKSB7CiAgICAgIGlzUHJvZHVjdGlvbiA9IF9pc1Byb2R1Y3Rpb247CiAgICAgIG9wdGlvbnMgPSBfb3B0aW9ucyB8fCB7fTsKICAgICAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdCk7CiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcyk7CiAgICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkgewogICAgICAgIHZhciBtYXlSZW1vdmUgPSBbXTsKCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldOwogICAgICAgICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07CiAgICAgICAgICBkb21TdHlsZS5yZWZzLS07CiAgICAgICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7CiAgICAgICAgfQoKICAgICAgICBpZiAobmV3TGlzdCkgewogICAgICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KTsKICAgICAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcyk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHN0eWxlcyA9IFtdOwogICAgICAgIH0KCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTsKCiAgICAgICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkgewogICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICB9CgogICAgZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzCiAgICAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8KICAgICkgewogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldOwogICAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdOwoKICAgICAgICBpZiAoZG9tU3R5bGUpIHsKICAgICAgICAgIGRvbVN0eWxlLnJlZnMrKzsKCiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pOwogICAgICAgICAgfQoKICAgICAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykgewogICAgICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoZG9tU3R5bGUucGFydHMubGVuZ3RoID4gaXRlbS5wYXJ0cy5sZW5ndGgpIHsKICAgICAgICAgICAgZG9tU3R5bGUucGFydHMubGVuZ3RoID0gaXRlbS5wYXJ0cy5sZW5ndGg7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhciBwYXJ0cyA9IFtdOwoKICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykgewogICAgICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKTsKICAgICAgICAgIH0KCiAgICAgICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsKICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsCiAgICAgICAgICAgIHJlZnM6IDEsCiAgICAgICAgICAgIHBhcnRzOiBwYXJ0cwogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQoKSB7CiAgICAgIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpOwogICAgICBzdHlsZUVsZW1lbnQudHlwZSA9ICd0ZXh0L2Nzcyc7CiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTsKICAgICAgcmV0dXJuIHN0eWxlRWxlbWVudDsKICAgIH0KCiAgICBmdW5jdGlvbiBhZGRTdHlsZShvYmoKICAgIC8qIFN0eWxlT2JqZWN0UGFydCAqLwogICAgKSB7CiAgICAgIHZhciB1cGRhdGUsIHJlbW92ZTsKICAgICAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlWycgKyBzc3JJZEtleSArICd+PSInICsgb2JqLmlkICsgJyJdJyk7CgogICAgICBpZiAoc3R5bGVFbGVtZW50KSB7CiAgICAgICAgaWYgKGlzUHJvZHVjdGlvbikgewogICAgICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYW5kIGluIHByb2R1Y3Rpb24gbW9kZS4KICAgICAgICAgIC8vIHNpbXBseSBkbyBub3RoaW5nLgogICAgICAgICAgcmV0dXJuIG5vb3A7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGJ1dCBpbiBkZXYgbW9kZS4KICAgICAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBDaHJvbWUgY2FuJ3QgaGFuZGxlIHNvdXJjZSBtYXAgaW4gc2VydmVyLXJlbmRlcmVkCiAgICAgICAgICAvLyBzdHlsZSB0YWdzIC0gc291cmNlIG1hcHMgaW4gPHN0eWxlPiBvbmx5IHdvcmtzIGlmIHRoZSBzdHlsZSB0YWcgaXMKICAgICAgICAgIC8vIGNyZWF0ZWQgYW5kIGluc2VydGVkIGR5bmFtaWNhbGx5LiBTbyB3ZSByZW1vdmUgdGhlIHNlcnZlciByZW5kZXJlZAogICAgICAgICAgLy8gc3R5bGVzIGFuZCBpbmplY3QgbmV3IG9uZXMuCiAgICAgICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKGlzT2xkSUUpIHsKICAgICAgICAvLyB1c2Ugc2luZ2xldG9uIG1vZGUgZm9yIElFOS4KICAgICAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKzsKICAgICAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpOwogICAgICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTsKICAgICAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzCiAgICAgICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCk7CiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7CgogICAgICAgIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHsKICAgICAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7CiAgICAgICAgfTsKICAgICAgfQoKICAgICAgdXBkYXRlKG9iaik7CiAgICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmoKICAgICAgLyogU3R5bGVPYmplY3RQYXJ0ICovCiAgICAgICkgewogICAgICAgIGlmIChuZXdPYmopIHsKICAgICAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQoKICAgICAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZW1vdmUoKTsKICAgICAgICB9CiAgICAgIH07CiAgICB9CgogICAgdmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gKCkgewogICAgICB2YXIgdGV4dFN0b3JlID0gW107CiAgICAgIHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7CiAgICAgICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50OwogICAgICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xuJyk7CiAgICAgIH07CiAgICB9KCk7CgogICAgZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikgewogICAgICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzOwoKICAgICAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7CiAgICAgICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpOwogICAgICB9IGVsc2UgewogICAgICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTsKICAgICAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzOwogICAgICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTsKCiAgICAgICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7CiAgICAgICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpOwogICAgICAgIH0KICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHsKICAgICAgdmFyIGNzcyA9IG9iai5jc3M7CiAgICAgIHZhciBtZWRpYSA9IG9iai5tZWRpYTsKICAgICAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7CgogICAgICBpZiAobWVkaWEpIHsKICAgICAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTsKICAgICAgfQoKICAgICAgaWYgKG9wdGlvbnMuc3NySWQpIHsKICAgICAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKHNzcklkS2V5LCBvYmouaWQpOwogICAgICB9CgogICAgICBpZiAoc291cmNlTWFwKSB7CiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nCiAgICAgICAgLy8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZQogICAgICAgIGNzcyArPSAnXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nOyAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NQoKICAgICAgICBjc3MgKz0gJ1xuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nOwogICAgICB9CgogICAgICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHsKICAgICAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzOwogICAgICB9IGVsc2UgewogICAgICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkgewogICAgICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTsKICAgICAgICB9CgogICAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTsKICAgICAgfQogICAgfQogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiNGE1OSI6CiAgLyoqKi8KICBmdW5jdGlvbiBhNTkobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgY3R4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiOWI0MyIpOwoKICAgIHZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMWZhOCIpOwoKICAgIHZhciBpc0FycmF5SXRlciA9IF9fd2VicGFja19yZXF1aXJlX18oIjMzYTQiKTsKCiAgICB2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJjYjdjIik7CgogICAgdmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXygiOWRlZiIpOwoKICAgIHZhciBnZXRJdGVyRm4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyN2VlIik7CgogICAgdmFyIEJSRUFLID0ge307CiAgICB2YXIgUkVUVVJOID0ge307CgogICAgdmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7CiAgICAgIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gaXRlcmFibGU7CiAgICAgIH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpOwogICAgICB2YXIgZiA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKTsKICAgICAgdmFyIGluZGV4ID0gMDsKICAgICAgdmFyIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDsKICAgICAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7IC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvcgoKICAgICAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHsKICAgICAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7CiAgICAgICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7CiAgICAgIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7CiAgICAgICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7CiAgICAgICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7CiAgICAgIH0KICAgIH07CgogICAgZXhwb3J0cy5CUkVBSyA9IEJSRUFLOwogICAgZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgIjRiNDEiOgogIC8qKiovCiAgZnVuY3Rpb24gYjQxKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgInVzZSBzdHJpY3QiOwoKICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTsKICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8KCgogICAgX193ZWJwYWNrX2V4cG9ydHNfX1siZGVmYXVsdCJdID0gewogICAgICBmdW5jdGlvbmFsOiB0cnVlLAogICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihfaCwgX3ZtKSB7CiAgICAgICAgdmFyIF9jID0gX3ZtLl9jOwogICAgICAgIHJldHVybiBfYygnc3ZnJywgewogICAgICAgICAgImNsYXNzIjogW192bS5kYXRhWyJjbGFzcyJdLCBfdm0uZGF0YS5zdGF0aWNDbGFzc10sCiAgICAgICAgICBzdHlsZTogW192bS5kYXRhLnN0eWxlLCBfdm0uZGF0YS5zdGF0aWNTdHlsZV0sCiAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAieG1sbnMiOiAiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLAogICAgICAgICAgICAidmlld0JveCI6ICIwIDAgMjggMzIiCiAgICAgICAgICB9CiAgICAgICAgfSwgW19jKCdwYXRoJywgewogICAgICAgICAgYXR0cnM6IHsKICAgICAgICAgICAgImQiOiAiTTEzLjcyOCA2LjI3MnYxOS40NTZxMCAuNDQ4LS4zNTIuOHQtLjguMzItLjgtLjMybC01Ljk1Mi01Ljk1MkgxLjE1MnEtLjQ4IDAtLjgtLjM1MnQtLjM1Mi0uOHYtNi44NDhxMC0uNDguMzUyLS44dC44LS4zNTJoNC42NzJsNS45NTItNS45NTJxLjMyLS4zMi44LS4zMnQuOC4zMi4zNTIuOHpNMjAuNTc2IDE2cTAgMS4zNDQtLjc2OCAyLjUyOHQtMi4wMTYgMS42NjRxLS4xNi4wOTYtLjQ0OC4wOTYtLjQ0OCAwLS44LS4zMnQtLjMyLS44MzJxMC0uMzg0LjE5Mi0uNjR0LjU0NC0uNDQ4LjYwOC0uMzg0LjUxMi0uNjQuMTkyLTEuMDI0LS4xOTItMS4wMjQtLjUxMi0uNjQtLjYwOC0uMzg0LS41NDQtLjQ0OC0uMTkyLS42NHEwLS40OC4zMi0uODMydC44LS4zMnEuMjg4IDAgLjQ0OC4wOTYgMS4yNDguNDggMi4wMTYgMS42NjRUMjAuNTc2IDE2em00LjU3NiAwcTAgMi43Mi0xLjUzNiA1LjA1NnQtNCAzLjM2cS0uMjU2LjA5Ni0uNDQ4LjA5Ni0uNDggMC0uODMyLS4zNTJ0LS4zMi0uOHEwLS43MDQuNjcyLTEuMDU2IDEuMDI0LS41MTIgMS4zNzYtLjggMS4zMTItLjk2IDIuMDQ4LTIuNFQyMi44NDggMTZ0LS43MzYtMy4xMDQtMi4wNDgtMi40cS0uMzUyLS4yODgtMS4zNzYtLjgtLjY3Mi0uMzUyLS42NzItMS4wNTYgMC0uNDQ4LjMyLS44dC44LS4zNTJxLjIyNCAwIC40OC4wOTYgMi40OTYgMS4wNTYgNCAzLjM2VDI1LjE1MiAxNnptNC41NzYgMHEwIDQuMDk2LTIuMjcyIDcuNTUydC02LjA0OCA1LjA1NnEtLjIyNC4wOTYtLjQ0OC4wOTYtLjQ4IDAtLjgzMi0uMzUydC0uMzItLjhxMC0uNjQuNzA0LTEuMDU2bC4zODQtLjE5MnEuMjU2LS4xMjguNDE2LS4xOTIuOC0uNDQ4IDEuNDQtLjg5NiAyLjIwOC0xLjYzMiAzLjQ1Ni00LjA2NFQyNy40MjQgMTZ0LTEuMjE2LTUuMTUyLTMuNDU2LTQuMDY0cS0uNjQtLjQ0OC0xLjQ0LS44OTYtLjEyOC0uMDk2LS40MTYtLjE5MnQtLjM4NC0uMTkycS0uNzA0LS40MTYtLjcwNC0xLjA1NiAwLS40NDguMzItLjh0LjgzMi0uMzUycS4yMjQgMCAuNDQ4LjA5NiAzLjc3NiAxLjYzMiA2LjA0OCA1LjA1NlQyOS43MjggMTZ6IgogICAgICAgICAgfQogICAgICAgIH0pXSk7CiAgICAgIH0KICAgIH07CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgIjRiZjgiOgogIC8qKiovCiAgZnVuY3Rpb24gYmY4KG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KQogICAgdmFyIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJiZTEzIik7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICAgICAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiNGQyNiI6CiAgLyoqKi8KICBmdW5jdGlvbiBkMjYobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187CiAgICAvKiEKICAgIENvcHlyaWdodCAoYykgMjAxNyBKZWQgV2F0c29uLgogICAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWUKICAgIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXMKICAgICovCgogICAgLyogZ2xvYmFsIGRlZmluZSAqLwoKCiAgICAoZnVuY3Rpb24gKCkgewogICAgICAndXNlIHN0cmljdCc7CgogICAgICB2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7CgogICAgICBmdW5jdGlvbiBjbGFzc05hbWVzKCkgewogICAgICAgIHZhciBjbGFzc2VzID0gW107CgogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldOwogICAgICAgICAgaWYgKCFhcmcpIGNvbnRpbnVlOwoKICAgICAgICAgIHZhciBhcmdUeXBlID0gX3R5cGVvZjMoYXJnKTsKCiAgICAgICAgICBpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHsKICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGFyZyk7CiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSAmJiBhcmcubGVuZ3RoKSB7CiAgICAgICAgICAgIHZhciBpbm5lciA9IGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTsKCiAgICAgICAgICAgIGlmIChpbm5lcikgewogICAgICAgICAgICAgIGNsYXNzZXMucHVzaChpbm5lcik7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHsKICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZykgewogICAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHsKICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChrZXkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIGNsYXNzZXMuam9pbignICcpOwogICAgICB9CgogICAgICBpZiAodHJ1ZSAmJiBtb2R1bGUuZXhwb3J0cykgewogICAgICAgIGNsYXNzTmFtZXNbImRlZmF1bHQiXSA9IGNsYXNzTmFtZXM7CiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzOwogICAgICB9IGVsc2UgaWYgKHRydWUpIHsKICAgICAgICAvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lCiAgICAgICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXM7CiAgICAgICAgfS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpOwogICAgICB9IGVsc2Uge30KICAgIH0pKCk7CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICI1MTQ3IjoKICAvKioqLwogIGZ1bmN0aW9uIF8obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgTUFUQ0ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyYjRjIikoJ21hdGNoJyk7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7CiAgICAgIHZhciByZSA9IC8uLzsKCiAgICAgIHRyeSB7CiAgICAgICAgJy8uLydbS0VZXShyZSk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICB0cnkgewogICAgICAgICAgcmVbTUFUQ0hdID0gZmFsc2U7CiAgICAgICAgICByZXR1cm4gIScvLi8nW0tFWV0ocmUpOwogICAgICAgIH0gY2F0Y2ggKGYpIHsKICAgICAgICAgIC8qIGVtcHR5ICovCiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gdHJ1ZTsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICI1MmE3IjoKICAvKioqLwogIGZ1bmN0aW9uIGE3KG1vZHVsZSwgZXhwb3J0cykgewogICAgZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgIjUyZjAiOgogIC8qKiovCiAgZnVuY3Rpb24gZjAobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgbWFwID0gewogICAgICAiLi9sb2FkaW5nLnN2ZyI6ICI4ODVkIiwKICAgICAgIi4vbG9vcC1hbGwuc3ZnIjogImY4NjYiLAogICAgICAiLi9sb29wLW5vbmUuc3ZnIjogImMzYWIiLAogICAgICAiLi9sb29wLW9uZS5zdmciOiAiNTUyNyIsCiAgICAgICIuL2xyYy5zdmciOiAiNDcxMyIsCiAgICAgICIuL21lbnUuc3ZnIjogIjkwNmIiLAogICAgICAiLi9vcmRlci1saXN0LnN2ZyI6ICI0NzVhIiwKICAgICAgIi4vb3JkZXItcmFuZG9tLnN2ZyI6ICI3YTFhIiwKICAgICAgIi4vcGF1c2Uuc3ZnIjogImRhZjgiLAogICAgICAiLi9wbGF5LnN2ZyI6ICI4NGQ4IiwKICAgICAgIi4vcmlnaHQuc3ZnIjogImJmNWMiLAogICAgICAiLi9za2lwLnN2ZyI6ICIzN2U3IiwKICAgICAgIi4vdm9sdW1lLWRvd24uc3ZnIjogImJkYmEiLAogICAgICAiLi92b2x1bWUtb2ZmLnN2ZyI6ICJhZGVjIiwKICAgICAgIi4vdm9sdW1lLXVwLnN2ZyI6ICI0YjQxIgogICAgfTsKCiAgICBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHsKICAgICAgdmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7CiAgICAgIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTsKICAgIH0KCiAgICBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7CiAgICAgIHZhciBpZCA9IG1hcFtyZXFdOwoKICAgICAgaWYgKCEoaWQgKyAxKSkgewogICAgICAgIC8vIGNoZWNrIGZvciBudW1iZXIgb3Igc3RyaW5nCiAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoIkNhbm5vdCBmaW5kIG1vZHVsZSAnIiArIHJlcSArICInIik7CiAgICAgICAgZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnOwogICAgICAgIHRocm93IGU7CiAgICAgIH0KCiAgICAgIHJldHVybiBpZDsKICAgIH0KCiAgICB3ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkgewogICAgICByZXR1cm4gT2JqZWN0LmtleXMobWFwKTsKICAgIH07CgogICAgd2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTsKICAgIG1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7CiAgICB3ZWJwYWNrQ29udGV4dC5pZCA9ICI1MmYwIjsKICAgIC8qKiovCiAgfSwKCiAgLyoqKi8KICAiNTUxYyI6CiAgLyoqKi8KICBmdW5jdGlvbiBjKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgInVzZSBzdHJpY3QiOwoKICAgIHZhciBMSUJSQVJZID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMmQwMCIpOwoKICAgIHZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI3NzI2Iik7CgogICAgdmFyIGN0eCA9IF9fd2VicGFja19yZXF1aXJlX18oIjliNDMiKTsKCiAgICB2YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oIjIzYzYiKTsKCiAgICB2YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oIjVjYTEiKTsKCiAgICB2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJkM2Y0Iik7CgogICAgdmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oImQ4ZTgiKTsKCiAgICB2YXIgYW5JbnN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oImY2MDUiKTsKCiAgICB2YXIgZm9yT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI0YTU5Iik7CgogICAgdmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oImViZDYiKTsKCiAgICB2YXIgdGFzayA9IF9fd2VicGFja19yZXF1aXJlX18oIjE5OTEiKS5zZXQ7CgogICAgdmFyIG1pY3JvdGFzayA9IF9fd2VicGFja19yZXF1aXJlX18oIjgwNzkiKSgpOwoKICAgIHZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oImE1YjgiKTsKCiAgICB2YXIgcGVyZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oIjljODAiKTsKCiAgICB2YXIgdXNlckFnZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiYTI1ZiIpOwoKICAgIHZhciBwcm9taXNlUmVzb2x2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oImJjYWEiKTsKCiAgICB2YXIgUFJPTUlTRSA9ICdQcm9taXNlJzsKICAgIHZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yOwogICAgdmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzczsKICAgIHZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9uczsKICAgIHZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4IHx8ICcnOwogICAgdmFyICRQcm9taXNlID0gZ2xvYmFsW1BST01JU0VdOwogICAgdmFyIGlzTm9kZSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnOwoKICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uIGVtcHR5KCkgewogICAgICAvKiBlbXB0eSAqLwogICAgfTsKCiAgICB2YXIgSW50ZXJuYWwsIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7CiAgICB2YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mOwogICAgdmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uICgpIHsKICAgICAgdHJ5IHsKICAgICAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnQKICAgICAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlLnJlc29sdmUoMSk7CgogICAgICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW19fd2VicGFja19yZXF1aXJlX18oIjJiNGMiKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uIChleGVjKSB7CiAgICAgICAgICBleGVjKGVtcHR5LCBlbXB0eSk7CiAgICAgICAgfTsgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdAoKCiAgICAgICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKSAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2UgLy8gdjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlcwogICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgzMDU2NQogICAgICAgIC8vIHdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zCiAgICAgICAgJiYgdjguaW5kZXhPZignNi42JykgIT09IDAgJiYgdXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZS82NicpID09PSAtMTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIC8qIGVtcHR5ICovCiAgICAgIH0KICAgIH0oKTsgLy8gaGVscGVycwoKICAgIHZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gaXNUaGVuYWJsZShpdCkgewogICAgICB2YXIgdGhlbjsKICAgICAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlOwogICAgfTsKCiAgICB2YXIgbm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5KHByb21pc2UsIGlzUmVqZWN0KSB7CiAgICAgIGlmIChwcm9taXNlLl9uKSByZXR1cm47CiAgICAgIHByb21pc2UuX24gPSB0cnVlOwogICAgICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jOwogICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkgewogICAgICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7CiAgICAgICAgdmFyIG9rID0gcHJvbWlzZS5fcyA9PSAxOwogICAgICAgIHZhciBpID0gMDsKCiAgICAgICAgdmFyIHJ1biA9IGZ1bmN0aW9uIHJ1bihyZWFjdGlvbikgewogICAgICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDsKICAgICAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTsKICAgICAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7CiAgICAgICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluOwogICAgICAgICAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkOwoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7CiAgICAgICAgICAgICAgaWYgKCFvaykgewogICAgICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7CiAgICAgICAgICAgICAgICBwcm9taXNlLl9oID0gMTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtlbHNlIHsKICAgICAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpOwogICAgICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIG1heSB0aHJvdwoKICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHsKICAgICAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTsKICAgICAgICAgICAgICAgICAgZXhpdGVkID0gdHJ1ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHsKICAgICAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7CiAgICAgICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpOwogICAgICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7CiAgICAgICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7CiAgICAgICAgICAgIHJlamVjdChlKTsKICAgICAgICAgIH0KICAgICAgICB9OwoKICAgICAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgewogICAgICAgICAgcnVuKGNoYWluW2krK10pOwogICAgICAgIH0gLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2gKCgogICAgICAgIHByb21pc2UuX2MgPSBbXTsKICAgICAgICBwcm9taXNlLl9uID0gZmFsc2U7CiAgICAgICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTsKICAgICAgfSk7CiAgICB9OwoKICAgIHZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIG9uVW5oYW5kbGVkKHByb21pc2UpIHsKICAgICAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkgewogICAgICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7CiAgICAgICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpOwogICAgICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7CgogICAgICAgIGlmICh1bmhhbmRsZWQpIHsKICAgICAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkgewogICAgICAgICAgICBpZiAoaXNOb2RlKSB7CiAgICAgICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbikgewogICAgICAgICAgICAgIGhhbmRsZXIoewogICAgICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZSwKICAgICAgICAgICAgICAgIHJlYXNvbjogdmFsdWUKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSBlbHNlIGlmICgoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7CiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGQKCiAgICAgICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7CiAgICAgICAgfQoKICAgICAgICBwcm9taXNlLl9hID0gdW5kZWZpbmVkOwogICAgICAgIGlmICh1bmhhbmRsZWQgJiYgcmVzdWx0LmUpIHRocm93IHJlc3VsdC52OwogICAgICB9KTsKICAgIH07CgogICAgdmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gaXNVbmhhbmRsZWQocHJvbWlzZSkgewogICAgICByZXR1cm4gcHJvbWlzZS5faCAhPT0gMSAmJiAocHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jKS5sZW5ndGggPT09IDA7CiAgICB9OwoKICAgIHZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIG9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpIHsKICAgICAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkgewogICAgICAgIHZhciBoYW5kbGVyOwoKICAgICAgICBpZiAoaXNOb2RlKSB7CiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTsKICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7CiAgICAgICAgICBoYW5kbGVyKHsKICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZSwKICAgICAgICAgICAgcmVhc29uOiBwcm9taXNlLl92CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH0pOwogICAgfTsKCiAgICB2YXIgJHJlamVjdCA9IGZ1bmN0aW9uICRyZWplY3QodmFsdWUpIHsKICAgICAgdmFyIHByb21pc2UgPSB0aGlzOwogICAgICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuOwogICAgICBwcm9taXNlLl9kID0gdHJ1ZTsKICAgICAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwCgogICAgICBwcm9taXNlLl92ID0gdmFsdWU7CiAgICAgIHByb21pc2UuX3MgPSAyOwogICAgICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7CiAgICAgIG5vdGlmeShwcm9taXNlLCB0cnVlKTsKICAgIH07CgogICAgdmFyICRyZXNvbHZlID0gZnVuY3Rpb24gJHJlc29sdmUodmFsdWUpIHsKICAgICAgdmFyIHByb21pc2UgPSB0aGlzOwogICAgICB2YXIgdGhlbjsKICAgICAgaWYgKHByb21pc2UuX2QpIHJldHVybjsKICAgICAgcHJvbWlzZS5fZCA9IHRydWU7CiAgICAgIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcAoKICAgICAgdHJ5IHsKICAgICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcigiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGYiKTsKCiAgICAgICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkgewogICAgICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSB7CiAgICAgICAgICAgICAgX3c6IHByb21pc2UsCiAgICAgICAgICAgICAgX2Q6IGZhbHNlCiAgICAgICAgICAgIH07IC8vIHdyYXAKCiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlOwogICAgICAgICAgcHJvbWlzZS5fcyA9IDE7CiAgICAgICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICRyZWplY3QuY2FsbCh7CiAgICAgICAgICBfdzogcHJvbWlzZSwKICAgICAgICAgIF9kOiBmYWxzZQogICAgICAgIH0sIGUpOyAvLyB3cmFwCiAgICAgIH0KICAgIH07IC8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsCgoKICAgIGlmICghVVNFX05BVElWRSkgewogICAgICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKQogICAgICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHsKICAgICAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTsKICAgICAgICBhRnVuY3Rpb24oZXhlY3V0b3IpOwogICAgICAgIEludGVybmFsLmNhbGwodGhpcyk7CgogICAgICAgIHRyeSB7CiAgICAgICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpOwogICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7CiAgICAgICAgfQogICAgICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMKCgogICAgICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHsKICAgICAgICB0aGlzLl9jID0gW107IC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9ucwoKICAgICAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9ucwoKICAgICAgICB0aGlzLl9zID0gMDsgLy8gPC0gc3RhdGUKCiAgICAgICAgdGhpcy5fZCA9IGZhbHNlOyAvLyA8LSBkb25lCgogICAgICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7IC8vIDwtIHZhbHVlCgogICAgICAgIHRoaXMuX2ggPSAwOyAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZAoKICAgICAgICB0aGlzLl9uID0gZmFsc2U7IC8vIDwtIG5vdGlmeQogICAgICB9OwoKICAgICAgSW50ZXJuYWwucHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygiZGNiYyIpKCRQcm9taXNlLnByb3RvdHlwZSwgewogICAgICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpCiAgICAgICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkgewogICAgICAgICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7CiAgICAgICAgICByZWFjdGlvbi5vayA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlOwogICAgICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDsKICAgICAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkOwoKICAgICAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7CgogICAgICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7CiAgICAgICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTsKICAgICAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlOwogICAgICAgIH0sCiAgICAgICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZCkKICAgICAgICAnY2F0Y2gnOiBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3RlZCkgewogICAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpOwogICAgICAgIH0KICAgICAgfSk7CgogICAgICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIE93blByb21pc2VDYXBhYmlsaXR5KCkgewogICAgICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7CiAgICAgICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTsKICAgICAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpOwogICAgICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpOwogICAgICB9OwoKICAgICAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQykgewogICAgICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpOwogICAgICB9OwogICAgfQoKICAgICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsKICAgICAgUHJvbWlzZTogJFByb21pc2UKICAgIH0pOwoKICAgIF9fd2VicGFja19yZXF1aXJlX18oIjdmMjAiKSgkUHJvbWlzZSwgUFJPTUlTRSk7CgogICAgX193ZWJwYWNrX3JlcXVpcmVfXygiN2E1NiIpKFBST01JU0UpOwoKICAgIFdyYXBwZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI4Mzc4IilbUFJPTUlTRV07IC8vIHN0YXRpY3MKCiAgICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7CiAgICAgIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpCiAgICAgIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHsKICAgICAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpOwogICAgICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0OwogICAgICAgICQkcmVqZWN0KHIpOwogICAgICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7CiAgICAgIH0KICAgIH0pOwogICAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHsKICAgICAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpCiAgICAgIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkgewogICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShMSUJSQVJZICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpOwogICAgICB9CiAgICB9KTsKICAgICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIF9fd2VicGFja19yZXF1aXJlX18oIjVjYzUiKShmdW5jdGlvbiAoaXRlcikgewogICAgICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpOwogICAgfSkpLCBQUk9NSVNFLCB7CiAgICAgIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKQogICAgICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkgewogICAgICAgIHZhciBDID0gdGhpczsKICAgICAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpOwogICAgICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlOwogICAgICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDsKICAgICAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7CiAgICAgICAgICB2YXIgdmFsdWVzID0gW107CiAgICAgICAgICB2YXIgaW5kZXggPSAwOwogICAgICAgICAgdmFyIHJlbWFpbmluZyA9IDE7CiAgICAgICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7CiAgICAgICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrOwogICAgICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlOwogICAgICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpOwogICAgICAgICAgICByZW1haW5pbmcrKzsKICAgICAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAgICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjsKICAgICAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTsKICAgICAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlOwogICAgICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTsKICAgICAgICAgICAgfSwgcmVqZWN0KTsKICAgICAgICAgIH0pOwogICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpOwogICAgICAgIH0pOwogICAgICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTsKICAgICAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlOwogICAgICB9LAogICAgICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpCiAgICAgIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHsKICAgICAgICB2YXIgQyA9IHRoaXM7CiAgICAgICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTsKICAgICAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7CiAgICAgICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkgewogICAgICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkgewogICAgICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7CiAgICAgICAgICB9KTsKICAgICAgICB9KTsKICAgICAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7CiAgICAgICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTsKICAgICAgfQogICAgfSk7CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgIjU1MjciOgogIC8qKiovCiAgZnVuY3Rpb24gXyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgICJ1c2Ugc3RyaWN0IjsKCiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7CiAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovCgoKICAgIF9fd2VicGFja19leHBvcnRzX19bImRlZmF1bHQiXSA9IHsKICAgICAgZnVuY3Rpb25hbDogdHJ1ZSwKICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoX2gsIF92bSkgewogICAgICAgIHZhciBfYyA9IF92bS5fYzsKICAgICAgICByZXR1cm4gX2MoJ3N2ZycsIHsKICAgICAgICAgICJjbGFzcyI6IFtfdm0uZGF0YVsiY2xhc3MiXSwgX3ZtLmRhdGEuc3RhdGljQ2xhc3NdLAogICAgICAgICAgc3R5bGU6IFtfdm0uZGF0YS5zdHlsZSwgX3ZtLmRhdGEuc3RhdGljU3R5bGVdLAogICAgICAgICAgYXR0cnM6IHsKICAgICAgICAgICAgInhtbG5zIjogImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiwKICAgICAgICAgICAgInZpZXdCb3giOiAiMCAwIDMzIDMyIgogICAgICAgICAgfQogICAgICAgIH0sIFtfYygncGF0aCcsIHsKICAgICAgICAgIGF0dHJzOiB7CiAgICAgICAgICAgICJkIjogIk05LjMzMyA5LjMzM2gxMy4zMzN2NEwyNy45OTkgOGwtNS4zMzMtNS4zMzN2NGgtMTZ2OGgyLjY2N1Y5LjMzNHptMTMuMzM0IDEzLjMzNEg5LjMzNHYtNEw0LjAwMSAyNGw1LjMzMyA1LjMzM3YtNGgxNnYtOGgtMi42Njd2NS4zMzN6TTE3LjMzMyAyMHYtOEgxNmwtMi42NjcgMS4zMzN2MS4zMzNoMnY1LjMzM2gyeiIKICAgICAgICAgIH0KICAgICAgICB9KV0pOwogICAgICB9CiAgICB9OwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICI1NTM3IjoKICAvKioqLwogIGZ1bmN0aW9uIF8obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oIjgzNzgiKTsKCiAgICB2YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNzcyNiIpOwoKICAgIHZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJzsKICAgIHZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTsKICAgIChtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7CiAgICAgIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pOwogICAgfSkoJ3ZlcnNpb25zJywgW10pLnB1c2goewogICAgICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sCiAgICAgIG1vZGU6IF9fd2VicGFja19yZXF1aXJlX18oIjJkMDAiKSA/ICdwdXJlJyA6ICdnbG9iYWwnLAogICAgICBjb3B5cmlnaHQ6ICfCqSAyMDE4IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJwogICAgfSk7CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgIjU1ZGQiOgogIC8qKiovCiAgZnVuY3Rpb24gZGQobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7CgogICAgdmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI1Y2ExIik7CgogICAgdmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oImQ4ZTgiKTsKCiAgICB2YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI0YmY4Iik7CgogICAgdmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNzllNSIpOwoKICAgIHZhciAkc29ydCA9IFtdLnNvcnQ7CiAgICB2YXIgdGVzdCA9IFsxLCAyLCAzXTsKICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHsKICAgICAgLy8gSUU4LQogICAgICB0ZXN0LnNvcnQodW5kZWZpbmVkKTsKICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7CiAgICAgIC8vIFY4IGJ1ZwogICAgICB0ZXN0LnNvcnQobnVsbCk7IC8vIE9sZCBXZWJLaXQKICAgIH0pIHx8ICFfX3dlYnBhY2tfcmVxdWlyZV9fKCIyZjIxIikoJHNvcnQpKSwgJ0FycmF5JywgewogICAgICAvLyAyMi4xLjMuMjUgQXJyYXkucHJvdG90eXBlLnNvcnQoY29tcGFyZWZuKQogICAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikgewogICAgICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZCA/ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcykpIDogJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSwgYUZ1bmN0aW9uKGNvbXBhcmVmbikpOwogICAgICB9CiAgICB9KTsKICAgIC8qKiovCiAgfSwKCiAgLyoqKi8KICAiNWNhMSI6CiAgLyoqKi8KICBmdW5jdGlvbiBjYTEobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNzcyNiIpOwoKICAgIHZhciBjb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygiODM3OCIpOwoKICAgIHZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMzJlOSIpOwoKICAgIHZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oIjJhYmEiKTsKCiAgICB2YXIgY3R4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiOWI0MyIpOwoKICAgIHZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJzsKCiAgICB2YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICRleHBvcnQodHlwZSwgbmFtZSwgc291cmNlKSB7CiAgICAgIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GOwogICAgICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRzsKICAgICAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7CiAgICAgIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7CiAgICAgIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjsKICAgICAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTsKICAgICAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTsKICAgICAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7CiAgICAgIHZhciBrZXksIG93biwgb3V0LCBleHA7CiAgICAgIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7CgogICAgICBmb3IgKGtleSBpbiBzb3VyY2UpIHsKICAgICAgICAvLyBjb250YWlucyBpbiBuYXRpdmUKICAgICAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkOyAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZAoKICAgICAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldOyAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dAoKICAgICAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDsgLy8gZXh0ZW5kIGdsb2JhbAoKICAgICAgICBpZiAodGFyZ2V0KSByZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTsgLy8gZXhwb3J0CgogICAgICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTsKICAgICAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7CiAgICAgIH0KICAgIH07CgogICAgZ2xvYmFsLmNvcmUgPSBjb3JlOyAvLyB0eXBlIGJpdG1hcAoKICAgICRleHBvcnQuRiA9IDE7IC8vIGZvcmNlZAoKICAgICRleHBvcnQuRyA9IDI7IC8vIGdsb2JhbAoKICAgICRleHBvcnQuUyA9IDQ7IC8vIHN0YXRpYwoKICAgICRleHBvcnQuUCA9IDg7IC8vIHByb3RvCgogICAgJGV4cG9ydC5CID0gMTY7IC8vIGJpbmQKCiAgICAkZXhwb3J0LlcgPSAzMjsgLy8gd3JhcAoKICAgICRleHBvcnQuVSA9IDY0OyAvLyBzYWZlCgogICAgJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgCgogICAgbW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0OwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICI1Y2M1IjoKICAvKioqLwogIGZ1bmN0aW9uIGNjNShtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIHZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oIjJiNGMiKSgnaXRlcmF0b3InKTsKCiAgICB2YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7CgogICAgdHJ5IHsKICAgICAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpOwoKICAgICAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkgewogICAgICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7CiAgICAgIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsCgoKICAgICAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgewogICAgICAgIHRocm93IDI7CiAgICAgIH0pOwogICAgfSBjYXRjaCAoZSkgewogICAgICAvKiBlbXB0eSAqLwogICAgfQoKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7CiAgICAgIGlmICghc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlOwogICAgICB2YXIgc2FmZSA9IGZhbHNlOwoKICAgICAgdHJ5IHsKICAgICAgICB2YXIgYXJyID0gWzddOwogICAgICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpOwoKICAgICAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBkb25lOiBzYWZlID0gdHJ1ZQogICAgICAgICAgfTsKICAgICAgICB9OwoKICAgICAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgcmV0dXJuIGl0ZXI7CiAgICAgICAgfTsKCiAgICAgICAgZXhlYyhhcnIpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgLyogZW1wdHkgKi8KICAgICAgfQoKICAgICAgcmV0dXJuIHNhZmU7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiNWRiYyI6CiAgLyoqKi8KICBmdW5jdGlvbiBkYmMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJkM2Y0Iik7CgogICAgdmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygiOGI5NyIpLnNldDsKCiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCB0YXJnZXQsIEMpIHsKICAgICAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7CiAgICAgIHZhciBQOwoKICAgICAgaWYgKFMgIT09IEMgJiYgdHlwZW9mIFMgPT0gJ2Z1bmN0aW9uJyAmJiAoUCA9IFMucHJvdG90eXBlKSAhPT0gQy5wcm90b3R5cGUgJiYgaXNPYmplY3QoUCkgJiYgc2V0UHJvdG90eXBlT2YpIHsKICAgICAgICBzZXRQcm90b3R5cGVPZih0aGF0LCBQKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoYXQ7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiNWVkYSI6CiAgLyoqKi8KICBmdW5jdGlvbiBlZGEobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXMKICAgIHZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNWNhMSIpOwoKICAgIHZhciBjb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygiODM3OCIpOwoKICAgIHZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oIjc5ZTUiKTsKCiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHsKICAgICAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldOwogICAgICB2YXIgZXhwID0ge307CiAgICAgIGV4cFtLRVldID0gZXhlYyhmbik7CiAgICAgICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgewogICAgICAgIGZuKDEpOwogICAgICB9KSwgJ09iamVjdCcsIGV4cCk7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiNjEwYSI6CiAgLyoqKi8KICBmdW5jdGlvbiBhKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWcKICAgIC8vIGxvYWQgdGhlIHN0eWxlcwogICAgdmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJhYjU3Iik7CgogICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07CiAgICBpZiAoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7IC8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET00KCiAgICB2YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNDk5ZSIpWyJkZWZhdWx0Il07CgogICAgdmFyIHVwZGF0ZSA9IGFkZCgiNDU3M2M4YjAiLCBjb250ZW50LCB0cnVlLCB7CiAgICAgICJzb3VyY2VNYXAiOiBmYWxzZSwKICAgICAgInNoYWRvd01vZGUiOiBmYWxzZQogICAgfSk7CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgIjYxM2IiOgogIC8qKiovCiAgZnVuY3Rpb24gYihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIHZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI1NTM3IikoJ2tleXMnKTsKCiAgICB2YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygiY2E1YSIpOwoKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkgewogICAgICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpOwogICAgfTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgIjYyNmEiOgogIC8qKiovCiAgZnVuY3Rpb24gYShtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIC8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzCiAgICB2YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMmQ5NSIpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zCgoKICAgIG1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHsKICAgICAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpOwogICAgfTsKICAgIC8qKiovCiAgfSwKCiAgLyoqKi8KICAiNjVkOSI6CiAgLyoqKi8KICBmdW5jdGlvbiBkOShtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgICJ1c2Ugc3RyaWN0IjsKICAgIC8qKgogICAgICAqIHZ1ZS1jbGFzcy1jb21wb25lbnQgdjYuMy4yCiAgICAgICogKGMpIDIwMTUtcHJlc2VudCBFdmFuIFlvdQogICAgICAqIEBsaWNlbnNlIE1JVAogICAgICAqLwoKICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsKICAgICAgdmFsdWU6IHRydWUKICAgIH0pOwoKICAgIGZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdChleCkgewogICAgICByZXR1cm4gZXggJiYgX3R5cGVvZjMoZXgpID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZXggPyBleFsnZGVmYXVsdCddIDogZXg7CiAgICB9CgogICAgdmFyIFZ1ZSA9IF9pbnRlcm9wRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKCI4YmJmIikpOwoKICAgIHZhciByZWZsZWN0aW9uSXNTdXBwb3J0ZWQgPSB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YTsKCiAgICBmdW5jdGlvbiBjb3B5UmVmbGVjdGlvbk1ldGFkYXRhKHRvLCBmcm9tKSB7CiAgICAgIGZvcndhcmRNZXRhZGF0YSh0bywgZnJvbSk7CiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGZyb20ucHJvdG90eXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsKICAgICAgICBmb3J3YXJkTWV0YWRhdGEodG8ucHJvdG90eXBlLCBmcm9tLnByb3RvdHlwZSwga2V5KTsKICAgICAgfSk7CiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGZyb20pLmZvckVhY2goZnVuY3Rpb24gKGtleSkgewogICAgICAgIGZvcndhcmRNZXRhZGF0YSh0bywgZnJvbSwga2V5KTsKICAgICAgfSk7CiAgICB9CgogICAgZnVuY3Rpb24gZm9yd2FyZE1ldGFkYXRhKHRvLCBmcm9tLCBwcm9wZXJ0eUtleSkgewogICAgICB2YXIgbWV0YUtleXMgPSBwcm9wZXJ0eUtleSA/IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKGZyb20sIHByb3BlcnR5S2V5KSA6IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKGZyb20pOwogICAgICBtZXRhS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRhS2V5KSB7CiAgICAgICAgdmFyIG1ldGFkYXRhID0gcHJvcGVydHlLZXkgPyBSZWZsZWN0LmdldE93bk1ldGFkYXRhKG1ldGFLZXksIGZyb20sIHByb3BlcnR5S2V5KSA6IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEobWV0YUtleSwgZnJvbSk7CgogICAgICAgIGlmIChwcm9wZXJ0eUtleSkgewogICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShtZXRhS2V5LCBtZXRhZGF0YSwgdG8sIHByb3BlcnR5S2V5KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShtZXRhS2V5LCBtZXRhZGF0YSwgdG8pOwogICAgICAgIH0KICAgICAgfSk7CiAgICB9CgogICAgdmFyIGZha2VBcnJheSA9IHsKICAgICAgX19wcm90b19fOiBbXQogICAgfTsKICAgIHZhciBoYXNQcm90byA9IGZha2VBcnJheSBpbnN0YW5jZW9mIEFycmF5OwoKICAgIGZ1bmN0aW9uIGNyZWF0ZURlY29yYXRvcihmYWN0b3J5KSB7CiAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIGluZGV4KSB7CiAgICAgICAgdmFyIEN0b3IgPSB0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nID8gdGFyZ2V0IDogdGFyZ2V0LmNvbnN0cnVjdG9yOwoKICAgICAgICBpZiAoIUN0b3IuX19kZWNvcmF0b3JzX18pIHsKICAgICAgICAgIEN0b3IuX19kZWNvcmF0b3JzX18gPSBbXTsKICAgICAgICB9CgogICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSB7CiAgICAgICAgICBpbmRleCA9IHVuZGVmaW5lZDsKICAgICAgICB9CgogICAgICAgIEN0b3IuX19kZWNvcmF0b3JzX18ucHVzaChmdW5jdGlvbiAob3B0aW9ucykgewogICAgICAgICAgcmV0dXJuIGZhY3Rvcnkob3B0aW9ucywga2V5LCBpbmRleCk7CiAgICAgICAgfSk7CiAgICAgIH07CiAgICB9CgogICAgZnVuY3Rpb24gbWl4aW5zKCkgewogICAgICB2YXIgQ3RvcnMgPSBbXTsKCiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7CiAgICAgICAgQ3RvcnNbX2ldID0gYXJndW1lbnRzW19pXTsKICAgICAgfQoKICAgICAgcmV0dXJuIFZ1ZS5leHRlbmQoewogICAgICAgIG1peGluczogQ3RvcnMKICAgICAgfSk7CiAgICB9CgogICAgZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHsKICAgICAgdmFyIHR5cGUgPSBfdHlwZW9mMyh2YWx1ZSk7CgogICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCB0eXBlICE9PSAnb2JqZWN0JyAmJiB0eXBlICE9PSAnZnVuY3Rpb24nOwogICAgfQoKICAgIGZ1bmN0aW9uIHdhcm4obWVzc2FnZSkgewogICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgY29uc29sZS53YXJuKCdbdnVlLWNsYXNzLWNvbXBvbmVudF0gJyArIG1lc3NhZ2UpOwogICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gY29sbGVjdERhdGFGcm9tQ29uc3RydWN0b3Iodm0sIENvbXBvbmVudCkgewogICAgICAvLyBvdmVycmlkZSBfaW5pdCB0byBwcmV2ZW50IHRvIGluaXQgYXMgVnVlIGluc3RhbmNlCiAgICAgIHZhciBvcmlnaW5hbEluaXQgPSBDb21wb25lbnQucHJvdG90eXBlLl9pbml0OwoKICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHsKICAgICAgICB2YXIgX3RoaXMgPSB0aGlzOyAvLyBwcm94eSB0byBhY3R1YWwgdm0KCgogICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModm0pOyAvLyAyLjIuMCBjb21wYXQgKHByb3BzIGFyZSBubyBsb25nZXIgZXhwb3NlZCBhcyBzZWxmIHByb3BlcnRpZXMpCgogICAgICAgIGlmICh2bS4kb3B0aW9ucy5wcm9wcykgewogICAgICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7CiAgICAgICAgICAgIGlmICghdm0uaGFzT3duUHJvcGVydHkoa2V5KSkgewogICAgICAgICAgICAgIGtleXMucHVzaChrZXkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgewogICAgICAgICAgaWYgKGtleS5jaGFyQXQoMCkgIT09ICdfJykgewogICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIGtleSwgewogICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHZtW2tleV07CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgewogICAgICAgICAgICAgICAgdm1ba2V5XSA9IHZhbHVlOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9OyAvLyBzaG91bGQgYmUgYWNxdWlyZWQgY2xhc3MgcHJvcGVydHkgdmFsdWVzCgoKICAgICAgdmFyIGRhdGEgPSBuZXcgQ29tcG9uZW50KCk7IC8vIHJlc3RvcmUgb3JpZ2luYWwgX2luaXQgdG8gYXZvaWQgbWVtb3J5IGxlYWsgKCMyMDkpCgogICAgICBDb21wb25lbnQucHJvdG90eXBlLl9pbml0ID0gb3JpZ2luYWxJbml0OyAvLyBjcmVhdGUgcGxhaW4gZGF0YSBvYmplY3QKCiAgICAgIHZhciBwbGFpbkRhdGEgPSB7fTsKICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7CiAgICAgICAgaWYgKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICBwbGFpbkRhdGFba2V5XSA9IGRhdGFba2V5XTsKICAgICAgICB9CiAgICAgIH0pOwoKICAgICAgaWYgKGZhbHNlKSB7fQoKICAgICAgcmV0dXJuIHBsYWluRGF0YTsKICAgIH0KCiAgICB2YXIgJGludGVybmFsSG9va3MgPSBbJ2RhdGEnLCAnYmVmb3JlQ3JlYXRlJywgJ2NyZWF0ZWQnLCAnYmVmb3JlTW91bnQnLCAnbW91bnRlZCcsICdiZWZvcmVEZXN0cm95JywgJ2Rlc3Ryb3llZCcsICdiZWZvcmVVcGRhdGUnLCAndXBkYXRlZCcsICdhY3RpdmF0ZWQnLCAnZGVhY3RpdmF0ZWQnLCAncmVuZGVyJywgJ2Vycm9yQ2FwdHVyZWQnIC8vIDIuNQogICAgXTsKCiAgICBmdW5jdGlvbiBjb21wb25lbnRGYWN0b3J5KENvbXBvbmVudCwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBvcHRpb25zLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgQ29tcG9uZW50Ll9jb21wb25lbnRUYWcgfHwgQ29tcG9uZW50Lm5hbWU7IC8vIHByb3RvdHlwZSBwcm9wcy4KCiAgICAgIHZhciBwcm90byA9IENvbXBvbmVudC5wcm90b3R5cGU7CiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsKICAgICAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfSAvLyBob29rcwoKCiAgICAgICAgaWYgKCRpbnRlcm5hbEhvb2tzLmluZGV4T2Yoa2V5KSA+IC0xKSB7CiAgICAgICAgICBvcHRpb25zW2tleV0gPSBwcm90b1trZXldOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBrZXkpOwoKICAgICAgICBpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gdm9pZCAwKSB7CiAgICAgICAgICAvLyBtZXRob2RzCiAgICAgICAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICAgICAgKG9wdGlvbnMubWV0aG9kcyB8fCAob3B0aW9ucy5tZXRob2RzID0ge30pKVtrZXldID0gZGVzY3JpcHRvci52YWx1ZTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIHR5cGVzY3JpcHQgZGVjb3JhdGVkIGRhdGEKICAgICAgICAgICAgKG9wdGlvbnMubWl4aW5zIHx8IChvcHRpb25zLm1peGlucyA9IFtdKSkucHVzaCh7CiAgICAgICAgICAgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHsKICAgICAgICAgICAgICAgIHZhciBfYTsKCiAgICAgICAgICAgICAgICByZXR1cm4gX2EgPSB7fSwgX2Fba2V5XSA9IGRlc2NyaXB0b3IudmFsdWUsIF9hOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmIChkZXNjcmlwdG9yLmdldCB8fCBkZXNjcmlwdG9yLnNldCkgewogICAgICAgICAgLy8gY29tcHV0ZWQgcHJvcGVydGllcwogICAgICAgICAgKG9wdGlvbnMuY29tcHV0ZWQgfHwgKG9wdGlvbnMuY29tcHV0ZWQgPSB7fSkpW2tleV0gPSB7CiAgICAgICAgICAgIGdldDogZGVzY3JpcHRvci5nZXQsCiAgICAgICAgICAgIHNldDogZGVzY3JpcHRvci5zZXQKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICB9KTsKICAgICAgKG9wdGlvbnMubWl4aW5zIHx8IChvcHRpb25zLm1peGlucyA9IFtdKSkucHVzaCh7CiAgICAgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHsKICAgICAgICAgIHJldHVybiBjb2xsZWN0RGF0YUZyb21Db25zdHJ1Y3Rvcih0aGlzLCBDb21wb25lbnQpOwogICAgICAgIH0KICAgICAgfSk7IC8vIGRlY29yYXRlIG9wdGlvbnMKCiAgICAgIHZhciBkZWNvcmF0b3JzID0gQ29tcG9uZW50Ll9fZGVjb3JhdG9yc19fOwoKICAgICAgaWYgKGRlY29yYXRvcnMpIHsKICAgICAgICBkZWNvcmF0b3JzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7CiAgICAgICAgICByZXR1cm4gZm4ob3B0aW9ucyk7CiAgICAgICAgfSk7CiAgICAgICAgZGVsZXRlIENvbXBvbmVudC5fX2RlY29yYXRvcnNfXzsKICAgICAgfSAvLyBmaW5kIHN1cGVyCgoKICAgICAgdmFyIHN1cGVyUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29tcG9uZW50LnByb3RvdHlwZSk7CiAgICAgIHZhciBTdXBlciA9IHN1cGVyUHJvdG8gaW5zdGFuY2VvZiBWdWUgPyBzdXBlclByb3RvLmNvbnN0cnVjdG9yIDogVnVlOwogICAgICB2YXIgRXh0ZW5kZWQgPSBTdXBlci5leHRlbmQob3B0aW9ucyk7CiAgICAgIGZvcndhcmRTdGF0aWNNZW1iZXJzKEV4dGVuZGVkLCBDb21wb25lbnQsIFN1cGVyKTsKCiAgICAgIGlmIChyZWZsZWN0aW9uSXNTdXBwb3J0ZWQpIHsKICAgICAgICBjb3B5UmVmbGVjdGlvbk1ldGFkYXRhKEV4dGVuZGVkLCBDb21wb25lbnQpOwogICAgICB9CgogICAgICByZXR1cm4gRXh0ZW5kZWQ7CiAgICB9CgogICAgdmFyIHJlc2VydmVkUHJvcGVydHlOYW1lcyA9IFsvLyBVbmlxdWUgaWQKICAgICdjaWQnLCAvLyBTdXBlciBWdWUgY29uc3RydWN0b3IKICAgICdzdXBlcicsIC8vIENvbXBvbmVudCBvcHRpb25zIHRoYXQgd2lsbCBiZSB1c2VkIGJ5IHRoZSBjb21wb25lbnQKICAgICdvcHRpb25zJywgJ3N1cGVyT3B0aW9ucycsICdleHRlbmRPcHRpb25zJywgJ3NlYWxlZE9wdGlvbnMnLCAvLyBQcml2YXRlIGFzc2V0cwogICAgJ2NvbXBvbmVudCcsICdkaXJlY3RpdmUnLCAnZmlsdGVyJ107CgogICAgZnVuY3Rpb24gZm9yd2FyZFN0YXRpY01lbWJlcnMoRXh0ZW5kZWQsIE9yaWdpbmFsLCBTdXBlcikgewogICAgICAvLyBXZSBoYXZlIHRvIHVzZSBnZXRPd25Qcm9wZXJ0eU5hbWVzIHNpbmNlIEJhYmVsIHJlZ2lzdGVycyBtZXRob2RzIGFzIG5vbi1lbnVtZXJhYmxlCiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9yaWdpbmFsKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsKICAgICAgICAvLyBgcHJvdG90eXBlYCBzaG91bGQgbm90IGJlIG92ZXJ3cml0dGVuCiAgICAgICAgaWYgKGtleSA9PT0gJ3Byb3RvdHlwZScpIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9IC8vIFNvbWUgYnJvd3NlcnMgZG9lcyBub3QgYWxsb3cgcmVjb25maWd1cmUgYnVpbHQtaW4gcHJvcGVydGllcwoKCiAgICAgICAgdmFyIGV4dGVuZGVkRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRXh0ZW5kZWQsIGtleSk7CgogICAgICAgIGlmIChleHRlbmRlZERlc2NyaXB0b3IgJiYgIWV4dGVuZGVkRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CgogICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPcmlnaW5hbCwga2V5KTsgLy8gSWYgdGhlIHVzZXIgYWdlbnQgZG9lcyBub3Qgc3VwcG9ydCBgX19wcm90b19fYCBvciBpdHMgZmFtaWx5IChJRSA8PSAxMCksCiAgICAgICAgLy8gdGhlIHN1YiBjbGFzcyBwcm9wZXJ0aWVzIG1heSBiZSBpbmhlcml0ZWQgcHJvcGVydGllcyBmcm9tIHRoZSBzdXBlciBjbGFzcyBpbiBUeXBlU2NyaXB0LgogICAgICAgIC8vIFdlIG5lZWQgdG8gZXhjbHVkZSBzdWNoIHByb3BlcnRpZXMgdG8gcHJldmVudCB0byBvdmVyd3JpdGUKICAgICAgICAvLyB0aGUgY29tcG9uZW50IG9wdGlvbnMgb2JqZWN0IHdoaWNoIHN0b3JlZCBvbiB0aGUgZXh0ZW5kZWQgY29uc3RydWN0b3IgKFNlZSAjMTkyKS4KICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSByZWZlcmVuY2VkIHZhbHVlIChvYmplY3Qgb3IgZnVuY3Rpb24pLAogICAgICAgIC8vIHdlIGNhbiBjaGVjayBlcXVhbGl0eSBvZiB0aGVtIGFuZCBleGNsdWRlIGl0IGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSByZWZlcmVuY2UuCiAgICAgICAgLy8gSWYgaXQgaXMgYSBwcmltaXRpdmUgdmFsdWUsIGl0IHdpbGwgYmUgZm9yd2FyZGVkIGZvciBzYWZldHkuCgogICAgICAgIGlmICghaGFzUHJvdG8pIHsKICAgICAgICAgIC8vIE9ubHkgYGNpZGAgaXMgZXhwbGljaXRseSBleGx1ZGVkIGZyb20gcHJvcGVydHkgZm9yd2FyZGluZwogICAgICAgICAgLy8gYmVjYXVzZSB3ZSBjYW5ub3QgZGV0ZWN0IHdoZXRoZXIgaXQgaXMgYSBpbmhlcml0ZWQgcHJvcGVydHkgb3Igbm90CiAgICAgICAgICAvLyBvbiB0aGUgbm8gYF9fcHJvdG9fX2AgZW52aXJvbm1lbnQgZXZlbiB0aG91Z2ggdGhlIHByb3BlcnR5IGlzIHJlc2VydmVkLgogICAgICAgICAgaWYgKGtleSA9PT0gJ2NpZCcpIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQoKICAgICAgICAgIHZhciBzdXBlckRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFN1cGVyLCBrZXkpOwoKICAgICAgICAgIGlmICghaXNQcmltaXRpdmUoZGVzY3JpcHRvci52YWx1ZSkgJiYgc3VwZXJEZXNjcmlwdG9yICYmIHN1cGVyRGVzY3JpcHRvci52YWx1ZSA9PT0gZGVzY3JpcHRvci52YWx1ZSkgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBXYXJuIGlmIHRoZSB1c2VycyBtYW51YWxseSBkZWNsYXJlIHJlc2VydmVkIHByb3BlcnRpZXMKCgogICAgICAgIGlmIChmYWxzZSkge30KCiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV4dGVuZGVkLCBrZXksIGRlc2NyaXB0b3IpOwogICAgICB9KTsKICAgIH0KCiAgICBmdW5jdGlvbiBDb21wb25lbnQob3B0aW9ucykgewogICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICByZXR1cm4gY29tcG9uZW50RmFjdG9yeShvcHRpb25zKTsKICAgICAgfQoKICAgICAgcmV0dXJuIGZ1bmN0aW9uIChDb21wb25lbnQpIHsKICAgICAgICByZXR1cm4gY29tcG9uZW50RmFjdG9yeShDb21wb25lbnQsIG9wdGlvbnMpOwogICAgICB9OwogICAgfQoKICAgIENvbXBvbmVudC5yZWdpc3Rlckhvb2tzID0gZnVuY3Rpb24gcmVnaXN0ZXJIb29rcyhrZXlzKSB7CiAgICAgICRpbnRlcm5hbEhvb2tzLnB1c2guYXBwbHkoJGludGVybmFsSG9va3MsIGtleXMpOwogICAgfTsKCiAgICBleHBvcnRzWyJkZWZhdWx0Il0gPSBDb21wb25lbnQ7CiAgICBleHBvcnRzLmNyZWF0ZURlY29yYXRvciA9IGNyZWF0ZURlY29yYXRvcjsKICAgIGV4cG9ydHMubWl4aW5zID0gbWl4aW5zOwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICI2NmExIjoKICAvKioqLwogIGZ1bmN0aW9uIGExKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgInVzZSBzdHJpY3QiOwoKICAgIHZhciBfX2Fzc2lnbiA9IHRoaXMgJiYgdGhpcy5fX2Fzc2lnbiB8fCBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7CiAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykgewogICAgICAgIHMgPSBhcmd1bWVudHNbaV07CgogICAgICAgIGZvciAodmFyIHAgaW4gcykgewogICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gdDsKICAgIH07CgogICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgewogICAgICB2YWx1ZTogdHJ1ZQogICAgfSk7CgogICAgZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQsIGZpbHRlcnMsIGhhbmRsZXIpIHsKICAgICAgZm9yICh2YXIgX2kgPSAwLCBmaWx0ZXJzXzEgPSBmaWx0ZXJzOyBfaSA8IGZpbHRlcnNfMS5sZW5ndGg7IF9pKyspIHsKICAgICAgICB2YXIgZmlsdGVyID0gZmlsdGVyc18xW19pXTsKCiAgICAgICAgaWYgKCFmaWx0ZXIoZXZlbnQpKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAoaGFuZGxlcikgewogICAgICAgIGhhbmRsZXIoZXZlbnQpOwogICAgICB9CiAgICB9CgogICAgdmFyIGtleUNvZGVzID0gewogICAgICBlc2M6IDI3LAogICAgICB0YWI6IDksCiAgICAgIGVudGVyOiAxMywKICAgICAgc3BhY2U6IDMyLAogICAgICB1cDogMzgsCiAgICAgIGRvd246IDQwLAogICAgICBkZWw6IFs4LCA0Nl0sCiAgICAgIGxlZnQ6IDM3LAogICAgICByaWdodDogMzkKICAgIH07CgogICAgZnVuY3Rpb24gY3JlYXRlS2V5RmlsdGVyKGtleXMpIHsKICAgICAgdmFyIGNvZGVzID0gW107CgogICAgICBmb3IgKHZhciBfaSA9IDAsIGtleXNfMSA9IGtleXM7IF9pIDwga2V5c18xLmxlbmd0aDsgX2krKykgewogICAgICAgIHZhciBrZXkgPSBrZXlzXzFbX2ldOwoKICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIGNvZGVzLnB1c2goa2V5KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFyIGNvZGUgPSBrZXlDb2Rlc1trZXldOwoKICAgICAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gIm51bWJlciIpIHsKICAgICAgICAgICAgY29kZXMucHVzaChjb2RlKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvZGVzLnB1c2guYXBwbHkoY29kZXMsIGNvZGUpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgc3dpdGNoIChjb2Rlcy5sZW5ndGgpIHsKICAgICAgICBjYXNlIDA6CiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF8pIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfTsKCiAgICAgICAgY2FzZSAxOgogICAgICAgICAgdmFyIGNvZGVfMSA9IGNvZGVzWzBdOwogICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICAgIHJldHVybiBlLmtleUNvZGUgPT09IGNvZGVfMTsKICAgICAgICAgIH07CgogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHsKICAgICAgICAgICAgcmV0dXJuIGNvZGVzLmluZGV4T2YoZS5rZXlDb2RlKSA+PSAwOwogICAgICAgICAgfTsKICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIGRlZmluZUNoaWxkTW9kaWZpZXIodGFyZ2V0LCBjdXJyZW50RmlsdGVycywgbmFtZSwgZmlsdGVyLCBjaGlsZHJlbikgewogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7CiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICAvLyBjYWxsIHRoaXMgZ2V0dGVyIGF0IG1vc3Qgb25jZS4KICAgICAgICAgIC8vIHJldXNlIGNyZWF0ZWQgaW5zdGFuY2UgYWZ0ZXIgbmV4dCB0aW1lLgogICAgICAgICAgdmFyIHJldCA9IGNyZWF0ZU1vZGlmaWVyKGN1cnJlbnRGaWx0ZXJzLmNvbmNhdChbZmlsdGVyXSksIGNoaWxkcmVuKTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHsKICAgICAgICAgICAgdmFsdWU6IHJldCwKICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgICByZXR1cm4gcmV0OwogICAgICAgIH0sCiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgfSk7CiAgICB9CgogICAgZnVuY3Rpb24gZGVmaW5lS2V5Q29kZU1vZGlmaWVycyh0YXJnZXQsIGZpbHRlcnMsIGNoaWxkcmVuKSB7CiAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gX2xvb3BfMShuYW1lXzEpIHsKICAgICAgICB2YXIga2V5TmFtZSA9IG5hbWVfMTsKCiAgICAgICAgaWYgKGtleU5hbWUgPT09ICJsZWZ0IiB8fCBrZXlOYW1lID09PSAicmlnaHQiKSB7CiAgICAgICAgICByZXR1cm4gImNvbnRpbnVlIjsKICAgICAgICB9CgogICAgICAgIHZhciBjb2RlID0ga2V5Q29kZXNba2V5TmFtZV07CgogICAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIGRlZmluZUNoaWxkTW9kaWZpZXIodGFyZ2V0LCBmaWx0ZXJzLCBrZXlOYW1lLCBmdW5jdGlvbiAoZSkgewogICAgICAgICAgICByZXR1cm4gZS5rZXlDb2RlID09PSBjb2RlOwogICAgICAgICAgfSwgY2hpbGRyZW4pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgYzFfMSA9IGNvZGVbMF0sCiAgICAgICAgICAgICAgYzJfMSA9IGNvZGVbMV07CiAgICAgICAgICBkZWZpbmVDaGlsZE1vZGlmaWVyKHRhcmdldCwgZmlsdGVycywga2V5TmFtZSwgZnVuY3Rpb24gKGUpIHsKICAgICAgICAgICAgcmV0dXJuIGUua2V5Q29kZSA9PT0gYzFfMSB8fCBlLmtleUNvZGUgPT09IGMyXzE7CiAgICAgICAgICB9LCBjaGlsZHJlbik7CiAgICAgICAgfQogICAgICB9OwoKICAgICAgZm9yICh2YXIgbmFtZV8xIGluIGtleUNvZGVzKSB7CiAgICAgICAgX2xvb3BfMShuYW1lXzEpOwogICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gZGVmaW5lS2V5cyh0YXJnZXQsIGZpbHRlcnMsIGNoaWxkcmVuKSB7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICJrZXlzIiwgewogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgdmFyIF90aGlzID0gdGhpczsKCiAgICAgICAgICB2YXIga2V5c0Z1bmN0aW9uID0gZnVuY3Rpb24ga2V5c0Z1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgYXJncyA9IFtdOwoKICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHsKICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9ICJrZXlzOiIgKyBhcmdzLnRvU3RyaW5nKCk7CiAgICAgICAgICAgIHZhciBtb2RpZmllciA9IF90aGlzW3Byb3BOYW1lXTsKCiAgICAgICAgICAgIGlmIChtb2RpZmllciAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG1vZGlmaWVyOwogICAgICAgICAgICB9CgogICAgICAgICAgICB2YXIgZmlsdGVyID0gY3JlYXRlS2V5RmlsdGVyKGFyZ3MpOwogICAgICAgICAgICBkZWZpbmVDaGlsZE1vZGlmaWVyKF90aGlzLCBmaWx0ZXJzLCBwcm9wTmFtZSwgZmlsdGVyLCBjaGlsZHJlbik7CiAgICAgICAgICAgIHJldHVybiBfdGhpc1twcm9wTmFtZV07CiAgICAgICAgICB9OwoKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAia2V5cyIsIHsKICAgICAgICAgICAgdmFsdWU6IGtleXNGdW5jdGlvbiwKICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgICByZXR1cm4ga2V5c0Z1bmN0aW9uOwogICAgICAgIH0sCiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgfSk7CiAgICB9CgogICAgZnVuY3Rpb24gZGVmaW5lRXhhY3QodGFyZ2V0LCBmaWx0ZXJzLCBjaGlsZHJlbikgewogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCAiZXhhY3QiLCB7CiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzOwoKICAgICAgICAgIHZhciBleGFjdEZ1bmN0aW9uID0gZnVuY3Rpb24gZXhhY3RGdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTsKCiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7CiAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldOwogICAgICAgICAgICB9CgogICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSAiZXhhY3Q6IiArIGFyZ3MudG9TdHJpbmcoKTsKICAgICAgICAgICAgdmFyIG1vZGlmaWVyID0gX3RoaXNbcHJvcE5hbWVdOwoKICAgICAgICAgICAgaWYgKG1vZGlmaWVyICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICByZXR1cm4gbW9kaWZpZXI7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHZhciBleHBlY3RlZCA9IHsKICAgICAgICAgICAgICBjdHJsOiBmYWxzZSwKICAgICAgICAgICAgICBzaGlmdDogZmFsc2UsCiAgICAgICAgICAgICAgYWx0OiBmYWxzZSwKICAgICAgICAgICAgICBtZXRhOiBmYWxzZQogICAgICAgICAgICB9OwogICAgICAgICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZykgewogICAgICAgICAgICAgIHJldHVybiBleHBlY3RlZFthcmddID0gdHJ1ZTsKICAgICAgICAgICAgfSk7CgogICAgICAgICAgICB2YXIgZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGUpIHsKICAgICAgICAgICAgICByZXR1cm4gISFlLmN0cmxLZXkgPT09IGV4cGVjdGVkLmN0cmwgJiYgISFlLnNoaWZ0S2V5ID09PSBleHBlY3RlZC5zaGlmdCAmJiAhIWUuYWx0S2V5ID09PSBleHBlY3RlZC5hbHQgJiYgISFlLm1ldGFLZXkgPT09IGV4cGVjdGVkLm1ldGE7CiAgICAgICAgICAgIH07CgogICAgICAgICAgICBkZWZpbmVDaGlsZE1vZGlmaWVyKF90aGlzLCBmaWx0ZXJzLCBwcm9wTmFtZSwgZmlsdGVyLCBjaGlsZHJlbik7CiAgICAgICAgICAgIHJldHVybiBfdGhpc1twcm9wTmFtZV07CiAgICAgICAgICB9OwoKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAiZXhhY3QiLCB7CiAgICAgICAgICAgIHZhbHVlOiBleGFjdEZ1bmN0aW9uLAogICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICAgIHJldHVybiBleGFjdEZ1bmN0aW9uOwogICAgICAgIH0sCiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgfSk7CiAgICB9CgogICAgZnVuY3Rpb24gY3JlYXRlTW9kaWZpZXIoZmlsdGVycywgY2hpbGRyZW4pIHsKICAgICAgZnVuY3Rpb24gbShhcmcpIHsKICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24pIHsKICAgICAgICAgIC8vIEV2ZW50SGFuZGxlciA9PiBFdmVudEhhbmRsZXIKICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHsKICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUV2ZW50KGV2ZW50LCBmaWx0ZXJzLCBhcmcpOwogICAgICAgICAgfTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8gRXZlbnQgPT4gdm9pZAogICAgICAgICAgaGFuZGxlRXZlbnQoYXJnLCBmaWx0ZXJzKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmIChjaGlsZHJlbi5rZXlib2FyZCB8fCBjaGlsZHJlbi5tb3VzZSkgewogICAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBfX2Fzc2lnbih7fSwgY2hpbGRyZW4sIHsKICAgICAgICAgIGtleWJvYXJkOiBmYWxzZSwKICAgICAgICAgIG1vdXNlOiBmYWxzZQogICAgICAgIH0pOwoKICAgICAgICBpZiAoY2hpbGRyZW4ua2V5Ym9hcmQpIHsKICAgICAgICAgIGRlZmluZUtleUNvZGVNb2RpZmllcnMobSwgZmlsdGVycywgbmV4dENoaWxkcmVuKTsKICAgICAgICAgIGRlZmluZUtleXMobSwgZmlsdGVycywgbmV4dENoaWxkcmVuKTsKICAgICAgICB9CgogICAgICAgIGlmIChjaGlsZHJlbi5tb3VzZSkgewogICAgICAgICAgZGVmaW5lQ2hpbGRNb2RpZmllcihtLCBmaWx0ZXJzLCAibWlkZGxlIiwgZnVuY3Rpb24gKGUpIHsKICAgICAgICAgICAgcmV0dXJuIGUuYnV0dG9uID09PSAxOwogICAgICAgICAgfSwgbmV4dENoaWxkcmVuKTsKICAgICAgICB9CgogICAgICAgIGRlZmluZUNoaWxkTW9kaWZpZXIobSwgZmlsdGVycywgImxlZnQiLCBmdW5jdGlvbiAoZSkgewogICAgICAgICAgcmV0dXJuIGUua2V5Q29kZSA9PT0gMzcgfHwgZS5idXR0b24gPT09IDA7CiAgICAgICAgfSwgbmV4dENoaWxkcmVuKTsKICAgICAgICBkZWZpbmVDaGlsZE1vZGlmaWVyKG0sIGZpbHRlcnMsICJyaWdodCIsIGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICByZXR1cm4gZS5rZXlDb2RlID09PSAzOSB8fCBlLmJ1dHRvbiA9PT0gMjsKICAgICAgICB9LCBuZXh0Q2hpbGRyZW4pOwogICAgICB9CgogICAgICBpZiAoY2hpbGRyZW4uZXhhY3QpIHsKICAgICAgICB2YXIgbmV4dENoaWxkcmVuID0gX19hc3NpZ24oe30sIGNoaWxkcmVuLCB7CiAgICAgICAgICBleGFjdDogZmFsc2UsCiAgICAgICAgICBtb2RrZXk6IGZhbHNlCiAgICAgICAgfSk7CgogICAgICAgIGRlZmluZUV4YWN0KG0sIGZpbHRlcnMsIG5leHRDaGlsZHJlbik7CiAgICAgIH0KCiAgICAgIGlmIChjaGlsZHJlbi5tb2RrZXkpIHsKICAgICAgICB2YXIgbmV4dENoaWxkcmVuID0gX19hc3NpZ24oe30sIGNoaWxkcmVuLCB7CiAgICAgICAgICBleGFjdDogZmFsc2UKICAgICAgICB9KTsKCiAgICAgICAgZGVmaW5lQ2hpbGRNb2RpZmllcihtLCBmaWx0ZXJzLCAiY3RybCIsIGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICByZXR1cm4gZS5jdHJsS2V5OwogICAgICAgIH0sIG5leHRDaGlsZHJlbik7CiAgICAgICAgZGVmaW5lQ2hpbGRNb2RpZmllcihtLCBmaWx0ZXJzLCAic2hpZnQiLCBmdW5jdGlvbiAoZSkgewogICAgICAgICAgcmV0dXJuIGUuc2hpZnRLZXk7CiAgICAgICAgfSwgbmV4dENoaWxkcmVuKTsKICAgICAgICBkZWZpbmVDaGlsZE1vZGlmaWVyKG0sIGZpbHRlcnMsICJhbHQiLCBmdW5jdGlvbiAoZSkgewogICAgICAgICAgcmV0dXJuIGUuYWx0S2V5OwogICAgICAgIH0sIG5leHRDaGlsZHJlbik7CiAgICAgICAgZGVmaW5lQ2hpbGRNb2RpZmllcihtLCBmaWx0ZXJzLCAibWV0YSIsIGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICByZXR1cm4gZS5tZXRhS2V5OwogICAgICAgIH0sIG5leHRDaGlsZHJlbik7CiAgICAgICAgZGVmaW5lQ2hpbGRNb2RpZmllcihtLCBmaWx0ZXJzLCAibm9jdHJsIiwgZnVuY3Rpb24gKGUpIHsKICAgICAgICAgIHJldHVybiAhZS5jdHJsS2V5OwogICAgICAgIH0sIG5leHRDaGlsZHJlbik7CiAgICAgICAgZGVmaW5lQ2hpbGRNb2RpZmllcihtLCBmaWx0ZXJzLCAibm9zaGlmdCIsIGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICByZXR1cm4gIWUuc2hpZnRLZXk7CiAgICAgICAgfSwgbmV4dENoaWxkcmVuKTsKICAgICAgICBkZWZpbmVDaGlsZE1vZGlmaWVyKG0sIGZpbHRlcnMsICJub2FsdCIsIGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICByZXR1cm4gIWUuYWx0S2V5OwogICAgICAgIH0sIG5leHRDaGlsZHJlbik7CiAgICAgICAgZGVmaW5lQ2hpbGRNb2RpZmllcihtLCBmaWx0ZXJzLCAibm9tZXRhIiwgZnVuY3Rpb24gKGUpIHsKICAgICAgICAgIHJldHVybiAhZS5tZXRhS2V5OwogICAgICAgIH0sIG5leHRDaGlsZHJlbik7CiAgICAgIH0KCiAgICAgIGRlZmluZUNoaWxkTW9kaWZpZXIobSwgZmlsdGVycywgInN0b3AiLCBmdW5jdGlvbiAoZSkgewogICAgICAgIHJldHVybiBlLnN0b3BQcm9wYWdhdGlvbigpIHx8IHRydWU7CiAgICAgIH0sIGNoaWxkcmVuKTsKICAgICAgZGVmaW5lQ2hpbGRNb2RpZmllcihtLCBmaWx0ZXJzLCAicHJldmVudCIsIGZ1bmN0aW9uIChlKSB7CiAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKSB8fCB0cnVlOwogICAgICB9LCBjaGlsZHJlbik7CiAgICAgIGRlZmluZUNoaWxkTW9kaWZpZXIobSwgZmlsdGVycywgInNlbGYiLCBmdW5jdGlvbiAoZSkgewogICAgICAgIHJldHVybiBlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0OwogICAgICB9LCBjaGlsZHJlbik7CiAgICAgIHJldHVybiBtOwogICAgfQoKICAgIGV4cG9ydHMubW9kaWZpZXJzID0gY3JlYXRlTW9kaWZpZXIoW10sIHsKICAgICAga2V5Ym9hcmQ6IHRydWUsCiAgICAgIG1vdXNlOiB0cnVlLAogICAgICBtb2RrZXk6IHRydWUsCiAgICAgIGV4YWN0OiB0cnVlCiAgICB9KTsKICAgIC8qKiovCiAgfSwKCiAgLyoqKi8KICAiNjc2MiI6CiAgLyoqKi8KICBmdW5jdGlvbiBfKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgInVzZSBzdHJpY3QiOyAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXMKCiAgICB2YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oIjVjYTEiKTsKCiAgICB2YXIgJGluY2x1ZGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiYzM2NiIpKHRydWUpOwoKICAgICRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7CiAgICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbAogICAgICAvKiAsIGZyb21JbmRleCA9IDAgKi8KICAgICAgKSB7CiAgICAgICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpOwogICAgICB9CiAgICB9KTsKCiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKCI5YzZjIikoJ2luY2x1ZGVzJyk7CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICI2ODIxIjoKICAvKioqLwogIGZ1bmN0aW9uIF8obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3MKICAgIHZhciBJT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNjI2YSIpOwoKICAgIHZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygiYmUxMyIpOwoKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgICAgIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICI2OWE4IjoKICAvKioqLwogIGZ1bmN0aW9uIGE4KG1vZHVsZSwgZXhwb3J0cykgewogICAgdmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkgewogICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICI2YTk5IjoKICAvKioqLwogIGZ1bmN0aW9uIGE5OShtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIC8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKQogICAgdmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiZDNmNCIpOyAvLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZQogICAgLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmcKCgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHsKICAgICAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDsKICAgICAgdmFyIGZuLCB2YWw7CiAgICAgIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsOwogICAgICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDsKICAgICAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsOwogICAgICB0aHJvdyBUeXBlRXJyb3IoIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZSIpOwogICAgfTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgIjZiNTQiOgogIC8qKiovCiAgZnVuY3Rpb24gYjU0KG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgInVzZSBzdHJpY3QiOwoKICAgIF9fd2VicGFja19yZXF1aXJlX18oIjM4NDYiKTsKCiAgICB2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJjYjdjIik7CgogICAgdmFyICRmbGFncyA9IF9fd2VicGFja19yZXF1aXJlX18oIjBiZmIiKTsKCiAgICB2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI5ZTFlIik7CgogICAgdmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7CiAgICB2YXIgJHRvU3RyaW5nID0gLy4vW1RPX1NUUklOR107CgogICAgdmFyIGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShmbikgewogICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyYWJhIikoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmbiwgdHJ1ZSk7CiAgICB9OyAvLyAyMS4yLjUuMTQgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZygpCgoKICAgIGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fKCI3OWU1IikoZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoewogICAgICAgIHNvdXJjZTogJ2EnLAogICAgICAgIGZsYWdzOiAnYicKICAgICAgfSkgIT0gJy9hL2InOwogICAgfSkpIHsKICAgICAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCkgewogICAgICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7CiAgICAgICAgcmV0dXJuICcvJy5jb25jYXQoUi5zb3VyY2UsICcvJywgJ2ZsYWdzJyBpbiBSID8gUi5mbGFncyA6ICFERVNDUklQVE9SUyAmJiBSIGluc3RhbmNlb2YgUmVnRXhwID8gJGZsYWdzLmNhbGwoUikgOiB1bmRlZmluZWQpOwogICAgICB9KTsgLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWUKICAgIH0gZWxzZSBpZiAoJHRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HKSB7CiAgICAgIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpIHsKICAgICAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwodGhpcyk7CiAgICAgIH0pOwogICAgfQogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiNzMzMyI6CiAgLyoqKi8KICBmdW5jdGlvbiBfKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgInVzZSBzdHJpY3QiOyAvLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pCgogICAgdmFyIGdldEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIwZDU4Iik7CgogICAgdmFyIGdPUFMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyNjIxIik7CgogICAgdmFyIHBJRSA9IF9fd2VicGFja19yZXF1aXJlX18oIjUyYTciKTsKCiAgICB2YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI0YmY4Iik7CgogICAgdmFyIElPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI2MjZhIik7CgogICAgdmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduOyAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZykKCiAgICBtb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IF9fd2VicGFja19yZXF1aXJlX18oIjc5ZTUiKShmdW5jdGlvbiAoKSB7CiAgICAgIHZhciBBID0ge307CiAgICAgIHZhciBCID0ge307IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZgoKICAgICAgdmFyIFMgPSBTeW1ib2woKTsKICAgICAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnOwogICAgICBBW1NdID0gNzsKICAgICAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgewogICAgICAgIEJba10gPSBrOwogICAgICB9KTsKICAgICAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7CiAgICB9KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgewogICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzCiAgICAgIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTsKICAgICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoOwogICAgICB2YXIgaW5kZXggPSAxOwogICAgICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjsKICAgICAgdmFyIGlzRW51bSA9IHBJRS5mOwoKICAgICAgd2hpbGUgKGFMZW4gPiBpbmRleCkgewogICAgICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pOwogICAgICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTsKICAgICAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7CiAgICAgICAgdmFyIGogPSAwOwogICAgICAgIHZhciBrZXk7CgogICAgICAgIHdoaWxlIChsZW5ndGggPiBqKSB7CiAgICAgICAgICBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIFQ7CiAgICB9IDogJGFzc2lnbjsKICAgIC8qKiovCiAgfSwKCiAgLyoqKi8KICAiNzUxNCI6CiAgLyoqKi8KICBmdW5jdGlvbiBfKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgInVzZSBzdHJpY3QiOyAvLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpCgogICAgdmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI1Y2ExIik7CgogICAgdmFyICRmaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMGE0OSIpKDUpOwoKICAgIHZhciBLRVkgPSAnZmluZCc7CiAgICB2YXIgZm9yY2VkID0gdHJ1ZTsgLy8gU2hvdWxkbid0IHNraXAgaG9sZXMKCiAgICBpZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHsKICAgICAgZm9yY2VkID0gZmFsc2U7CiAgICB9KTsKICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7CiAgICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbgogICAgICAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8KICAgICAgKSB7CiAgICAgICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTsKICAgICAgfQogICAgfSk7CgogICAgX193ZWJwYWNrX3JlcXVpcmVfXygiOWM2YyIpKEtFWSk7CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICI3NzI2IjoKICAvKioqLwogIGZ1bmN0aW9uIF8obW9kdWxlLCBleHBvcnRzKSB7CiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOAogICAgdmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYwogICAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpOwogICAgaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZgoKICAgIC8qKiovCiAgfSwKCiAgLyoqKi8KICAiNzdmMSI6CiAgLyoqKi8KICBmdW5jdGlvbiBmMShtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIHZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI0NTg4Iik7CgogICAgdmFyIG1heCA9IE1hdGgubWF4OwogICAgdmFyIG1pbiA9IE1hdGgubWluOwoKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHsKICAgICAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpOwogICAgICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICI3OWU1IjoKICAvKioqLwogIGZ1bmN0aW9uIGU1KG1vZHVsZSwgZXhwb3J0cykgewogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykgewogICAgICB0cnkgewogICAgICAgIHJldHVybiAhIWV4ZWMoKTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiN2ExYSI6CiAgLyoqKi8KICBmdW5jdGlvbiBhMWEobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7CgogICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pOwogICAgLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLwoKCiAgICBfX3dlYnBhY2tfZXhwb3J0c19fWyJkZWZhdWx0Il0gPSB7CiAgICAgIGZ1bmN0aW9uYWw6IHRydWUsCiAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKF9oLCBfdm0pIHsKICAgICAgICB2YXIgX2MgPSBfdm0uX2M7CiAgICAgICAgcmV0dXJuIF9jKCdzdmcnLCB7CiAgICAgICAgICAiY2xhc3MiOiBbX3ZtLmRhdGFbImNsYXNzIl0sIF92bS5kYXRhLnN0YXRpY0NsYXNzXSwKICAgICAgICAgIHN0eWxlOiBbX3ZtLmRhdGEuc3R5bGUsIF92bS5kYXRhLnN0YXRpY1N0eWxlXSwKICAgICAgICAgIGF0dHJzOiB7CiAgICAgICAgICAgICJ4bWxucyI6ICJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIsCiAgICAgICAgICAgICJ2aWV3Qm94IjogIjAgMCAzMiAzMiIKICAgICAgICAgIH0KICAgICAgICB9LCBbX2MoJ3BhdGgnLCB7CiAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAiZCI6ICJNMjIuNjY3IDRsNyA2LTcgNiA3IDYtNyA2di00aC0zLjY1M2wtMy43Ni0zLjc2IDIuODI3LTIuODI3TDIwLjY2OCAyMGgydi04aC0ybC0xMiAxMmgtNnYtNGg0LjM0N2wxMi0xMmgzLjY1M1Y0em0tMjAgNGg2bDMuNzYgMy43Nkw5LjYgMTQuNTg3IDcuMDEzIDEySDIuNjY2Vjh6IgogICAgICAgICAgfQogICAgICAgIH0pXSk7CiAgICAgIH0KICAgIH07CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgIjdhNTYiOgogIC8qKiovCiAgZnVuY3Rpb24gYTU2KG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgInVzZSBzdHJpY3QiOwoKICAgIHZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI3NzI2Iik7CgogICAgdmFyIGRQID0gX193ZWJwYWNrX3JlcXVpcmVfXygiODZjYyIpOwoKICAgIHZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oIjllMWUiKTsKCiAgICB2YXIgU1BFQ0lFUyA9IF9fd2VicGFja19yZXF1aXJlX18oIjJiNGMiKSgnc3BlY2llcycpOwoKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkgewogICAgICB2YXIgQyA9IGdsb2JhbFtLRVldOwogICAgICBpZiAoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkgZFAuZihDLCBTUEVDSUVTLCB7CiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICB9KTsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICI3ZjIwIjoKICAvKioqLwogIGZ1bmN0aW9uIGYyMChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIHZhciBkZWYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI4NmNjIikuZjsKCiAgICB2YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNjlhOCIpOwoKICAgIHZhciBUQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyYjRjIikoJ3RvU3RyaW5nVGFnJyk7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkgewogICAgICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsKICAgICAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICAgICAgdmFsdWU6IHRhZwogICAgICB9KTsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICI3ZjdmIjoKICAvKioqLwogIGZ1bmN0aW9uIGY3Zihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIHZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oIjg2Y2MiKS5mOwoKICAgIHZhciBGUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7CiAgICB2YXIgbmFtZVJFID0gL15ccypmdW5jdGlvbiAoW14gKF0qKS87CiAgICB2YXIgTkFNRSA9ICduYW1lJzsgLy8gMTkuMi40LjIgbmFtZQoKICAgIE5BTUUgaW4gRlByb3RvIHx8IF9fd2VicGFja19yZXF1aXJlX18oIjllMWUiKSAmJiBkUChGUHJvdG8sIE5BTUUsIHsKICAgICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICB0cnkgewogICAgICAgICAgcmV0dXJuICgnJyArIHRoaXMpLm1hdGNoKG5hbWVSRSlbMV07CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuICcnOwogICAgICAgIH0KICAgICAgfQogICAgfSk7CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgIjgwNzkiOgogIC8qKiovCiAgZnVuY3Rpb24gXyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIHZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI3NzI2Iik7CgogICAgdmFyIG1hY3JvdGFzayA9IF9fd2VicGFja19yZXF1aXJlX18oIjE5OTEiKS5zZXQ7CgogICAgdmFyIE9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7CiAgICB2YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzOwogICAgdmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTsKICAgIHZhciBpc05vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyZDk1IikocHJvY2VzcykgPT0gJ3Byb2Nlc3MnOwoKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgewogICAgICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5OwoKICAgICAgdmFyIGZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7CiAgICAgICAgdmFyIHBhcmVudCwgZm47CiAgICAgICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpOwoKICAgICAgICB3aGlsZSAoaGVhZCkgewogICAgICAgICAgZm4gPSBoZWFkLmZuOwogICAgICAgICAgaGVhZCA9IGhlYWQubmV4dDsKCiAgICAgICAgICB0cnkgewogICAgICAgICAgICBmbigpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7ZWxzZSBsYXN0ID0gdW5kZWZpbmVkOwogICAgICAgICAgICB0aHJvdyBlOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgbGFzdCA9IHVuZGVmaW5lZDsKICAgICAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTsKICAgICAgfTsgLy8gTm9kZS5qcwoKCiAgICAgIGlmIChpc05vZGUpIHsKICAgICAgICBub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkoKSB7CiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTsKICAgICAgICB9OyAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgU2FmYXJpIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOQoKICAgICAgfSBlbHNlIGlmIChPYnNlcnZlciAmJiAhKGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci5zdGFuZGFsb25lKSkgewogICAgICAgIHZhciB0b2dnbGUgPSB0cnVlOwogICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpOwogICAgICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7CiAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlCiAgICAgICAgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3CgogICAgICAgIG5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSgpIHsKICAgICAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7CiAgICAgICAgfTsgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2UKCiAgICAgIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHsKICAgICAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMgogICAgICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7CgogICAgICAgIG5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSgpIHsKICAgICAgICAgIHByb21pc2UudGhlbihmbHVzaCk7CiAgICAgICAgfTsgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjoKICAgICAgICAvLyAtIHNldEltbWVkaWF0ZQogICAgICAgIC8vIC0gTWVzc2FnZUNoYW5uZWwKICAgICAgICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnCiAgICAgICAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2UKICAgICAgICAvLyAtIHNldFRpbWVvdXQKCiAgICAgIH0gZWxzZSB7CiAgICAgICAgbm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5KCkgewogICAgICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKQogICAgICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7CiAgICAgICAgfTsKICAgICAgfQoKICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikgewogICAgICAgIHZhciB0YXNrID0gewogICAgICAgICAgZm46IGZuLAogICAgICAgICAgbmV4dDogdW5kZWZpbmVkCiAgICAgICAgfTsKICAgICAgICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzazsKCiAgICAgICAgaWYgKCFoZWFkKSB7CiAgICAgICAgICBoZWFkID0gdGFzazsKICAgICAgICAgIG5vdGlmeSgpOwogICAgICAgIH0KCiAgICAgICAgbGFzdCA9IHRhc2s7CiAgICAgIH07CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiODM3OCI6CiAgLyoqKi8KICBmdW5jdGlvbiBfKG1vZHVsZSwgZXhwb3J0cykgewogICAgdmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsKICAgICAgdmVyc2lvbjogJzIuNS43JwogICAgfTsKICAgIGlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmCgogICAgLyoqKi8KICB9LAoKICAvKioqLwogICI4NGQ4IjoKICAvKioqLwogIGZ1bmN0aW9uIGQ4KG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgInVzZSBzdHJpY3QiOwoKICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTsKICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8KCgogICAgX193ZWJwYWNrX2V4cG9ydHNfX1siZGVmYXVsdCJdID0gewogICAgICBmdW5jdGlvbmFsOiB0cnVlLAogICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihfaCwgX3ZtKSB7CiAgICAgICAgdmFyIF9jID0gX3ZtLl9jOwogICAgICAgIHJldHVybiBfYygnc3ZnJywgewogICAgICAgICAgImNsYXNzIjogW192bS5kYXRhWyJjbGFzcyJdLCBfdm0uZGF0YS5zdGF0aWNDbGFzc10sCiAgICAgICAgICBzdHlsZTogW192bS5kYXRhLnN0eWxlLCBfdm0uZGF0YS5zdGF0aWNTdHlsZV0sCiAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAieG1sbnMiOiAiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLAogICAgICAgICAgICAidmlld0JveCI6ICIwIDAgMTYgMzEiCiAgICAgICAgICB9CiAgICAgICAgfSwgW19jKCdwYXRoJywgewogICAgICAgICAgYXR0cnM6IHsKICAgICAgICAgICAgImQiOiAiTTE1LjU1MiAxNS4xNjhxLjQ0OC4zMi40NDguODMyIDAgLjQ0OC0uNDQ4Ljc2OEwxLjg1NiAyNS4yOHEtLjc2OC41MTItMS4zMTIuMTkyVDAgMjQuMTkyVjcuNzQ0cTAtLjk2LjU0NC0xLjI4dDEuMzEyLjE5MnoiCiAgICAgICAgICB9CiAgICAgICAgfSldKTsKICAgICAgfQogICAgfTsKICAgIC8qKiovCiAgfSwKCiAgLyoqKi8KICAiODRmMiI6CiAgLyoqKi8KICBmdW5jdGlvbiBmMihtb2R1bGUsIGV4cG9ydHMpIHsKICAgIG1vZHVsZS5leHBvcnRzID0ge307CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgIjg2Y2MiOgogIC8qKiovCiAgZnVuY3Rpb24gY2MobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJjYjdjIik7CgogICAgdmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygiYzY5YSIpOwoKICAgIHZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oIjZhOTkiKTsKCiAgICB2YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CiAgICBleHBvcnRzLmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI5ZTFlIikgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7CiAgICAgIGFuT2JqZWN0KE8pOwogICAgICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7CiAgICAgIGFuT2JqZWN0KEF0dHJpYnV0ZXMpOwogICAgICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7CiAgICAgICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgLyogZW1wdHkgKi8KICAgICAgfQogICAgICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpOwogICAgICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTsKICAgICAgcmV0dXJuIE87CiAgICB9OwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICI4ODVkIjoKICAvKioqLwogIGZ1bmN0aW9uIGQobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7CgogICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pOwogICAgLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLwoKCiAgICBfX3dlYnBhY2tfZXhwb3J0c19fWyJkZWZhdWx0Il0gPSB7CiAgICAgIGZ1bmN0aW9uYWw6IHRydWUsCiAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKF9oLCBfdm0pIHsKICAgICAgICB2YXIgX2MgPSBfdm0uX2M7CiAgICAgICAgcmV0dXJuIF9jKCdzdmcnLCB7CiAgICAgICAgICAiY2xhc3MiOiBbX3ZtLmRhdGFbImNsYXNzIl0sIF92bS5kYXRhLnN0YXRpY0NsYXNzXSwKICAgICAgICAgIHN0eWxlOiBbX3ZtLmRhdGEuc3R5bGUsIF92bS5kYXRhLnN0YXRpY1N0eWxlXSwKICAgICAgICAgIGF0dHJzOiB7CiAgICAgICAgICAgICJ4bWxucyI6ICJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIsCiAgICAgICAgICAgICJ2aWV3Qm94IjogIjAgMCAzMiAzMiIKICAgICAgICAgIH0KICAgICAgICB9LCBbX2MoJ3BhdGgnLCB7CiAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAiZCI6ICJNNCAxNkM0IDkuNCA5LjQgNCAxNiA0czEyIDUuNCAxMiAxMmMwIDEuMi0uOCAyLTIgMnMtMi0uOC0yLTJjMC00LjQtMy42LTgtOC04cy04IDMuNi04IDggMy42IDggOCA4YzEuMiAwIDIgLjggMiAycy0uOCAyLTIgMkM5LjQgMjggNCAyMi42IDQgMTZ6IgogICAgICAgICAgfQogICAgICAgIH0pXSk7CiAgICAgIH0KICAgIH07CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgIjhiOTciOgogIC8qKiovCiAgZnVuY3Rpb24gYjk3KG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuCgogICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi8KICAgIHZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oImQzZjQiKTsKCiAgICB2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJjYjdjIik7CgogICAgdmFyIGNoZWNrID0gZnVuY3Rpb24gY2hlY2soTywgcHJvdG8pIHsKICAgICAgYW5PYmplY3QoTyk7CiAgICAgIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyAiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlISIpOwogICAgfTsKCiAgICBtb2R1bGUuZXhwb3J0cyA9IHsKICAgICAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZQogICAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBzZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI5YjQzIikoRnVuY3Rpb24uY2FsbCwgX193ZWJwYWNrX3JlcXVpcmVfXygiMTFlOSIpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7CiAgICAgICAgICBzZXQodGVzdCwgW10pOwogICAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgYnVnZ3kgPSB0cnVlOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7CiAgICAgICAgICBjaGVjayhPLCBwcm90byk7CiAgICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87ZWxzZSBzZXQoTywgcHJvdG8pOwogICAgICAgICAgcmV0dXJuIE87CiAgICAgICAgfTsKICAgICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSwKICAgICAgY2hlY2s6IGNoZWNrCiAgICB9OwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICI4YmJmIjoKICAvKioqLwogIGZ1bmN0aW9uIGJiZihtb2R1bGUsIGV4cG9ydHMpIHsKICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgidnVlIik7CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgIjkwNmIiOgogIC8qKiovCiAgZnVuY3Rpb24gYihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgICJ1c2Ugc3RyaWN0IjsKCiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7CiAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovCgoKICAgIF9fd2VicGFja19leHBvcnRzX19bImRlZmF1bHQiXSA9IHsKICAgICAgZnVuY3Rpb25hbDogdHJ1ZSwKICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoX2gsIF92bSkgewogICAgICAgIHZhciBfYyA9IF92bS5fYzsKICAgICAgICByZXR1cm4gX2MoJ3N2ZycsIHsKICAgICAgICAgICJjbGFzcyI6IFtfdm0uZGF0YVsiY2xhc3MiXSwgX3ZtLmRhdGEuc3RhdGljQ2xhc3NdLAogICAgICAgICAgc3R5bGU6IFtfdm0uZGF0YS5zdHlsZSwgX3ZtLmRhdGEuc3RhdGljU3R5bGVdLAogICAgICAgICAgYXR0cnM6IHsKICAgICAgICAgICAgInhtbG5zIjogImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiwKICAgICAgICAgICAgInZpZXdCb3giOiAiMCAwIDIyIDMyIgogICAgICAgICAgfQogICAgICAgIH0sIFtfYygncGF0aCcsIHsKICAgICAgICAgIGF0dHJzOiB7CiAgICAgICAgICAgICJkIjogIk0yMC44IDE0LjRxLjcwNCAwIDEuMTUyLjQ4VDIyLjQgMTZ0LS40OCAxLjEyLTEuMTIuNDhIMS42cS0uNjQgMC0xLjEyLS40OFQwIDE2dC40NDgtMS4xMlQxLjYgMTQuNGgxOS4yek0xLjYgMTEuMnEtLjY0IDAtMS4xMi0uNDhUMCA5LjZ0LjQ0OC0xLjEyVDEuNiA4aDE5LjJxLjcwNCAwIDEuMTUyLjQ4VDIyLjQgOS42dC0uNDggMS4xMi0xLjEyLjQ4SDEuNnptMTkuMiA5LjZxLjcwNCAwIDEuMTUyLjQ4dC40NDggMS4xMi0uNDggMS4xMi0xLjEyLjQ4SDEuNnEtLjY0IDAtMS4xMi0uNDhUMCAyMi40dC40NDgtMS4xMlQxLjYgMjAuOGgxOS4yeiIKICAgICAgICAgIH0KICAgICAgICB9KV0pOwogICAgICB9CiAgICB9OwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICI5MDkzIjoKICAvKioqLwogIGZ1bmN0aW9uIF8obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pCiAgICB2YXIgJGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJjZTEwIik7CgogICAgdmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJlMTFlIikuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7CgogICAgZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7CiAgICAgIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICI5NmNmIjoKICAvKioqLwogIGZ1bmN0aW9uIGNmKG1vZHVsZSwgZXhwb3J0cykgewogICAgLyoqCiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4KICAgICAqCiAgICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGUKICAgICAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4KICAgICAqLwogICAgIWZ1bmN0aW9uIChnbG9iYWwpIHsKICAgICAgInVzZSBzdHJpY3QiOwoKICAgICAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTsKICAgICAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5OwogICAgICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC4KCiAgICAgIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gImZ1bmN0aW9uIiA/IFN5bWJvbCA6IHt9OwogICAgICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8ICJAQGl0ZXJhdG9yIjsKICAgICAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgIkBAYXN5bmNJdGVyYXRvciI7CiAgICAgIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgIkBAdG9TdHJpbmdUYWciOwogICAgICB2YXIgaW5Nb2R1bGUgPSBfdHlwZW9mMyhtb2R1bGUpID09PSAib2JqZWN0IjsKICAgICAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lOwoKICAgICAgaWYgKHJ1bnRpbWUpIHsKICAgICAgICBpZiAoaW5Nb2R1bGUpIHsKICAgICAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSwKICAgICAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuCiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7CiAgICAgICAgfSAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzCiAgICAgICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LgoKCiAgICAgICAgcmV0dXJuOwogICAgICB9IC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlcgogICAgICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuCgoKICAgICAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307CgogICAgICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7CiAgICAgICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuCiAgICAgICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7CiAgICAgICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTsKICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTsgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LAogICAgICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy4KCiAgICAgICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpOwogICAgICAgIHJldHVybiBnZW5lcmF0b3I7CiAgICAgIH0KCiAgICAgIHJ1bnRpbWUud3JhcCA9IHdyYXA7IC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvbgogICAgICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGQKICAgICAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlCiAgICAgIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2UKICAgICAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZAogICAgICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nCiAgICAgIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlCiAgICAgIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZQogICAgICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoCiAgICAgIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS4KCiAgICAgIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykgewogICAgICAgIHRyeSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICB0eXBlOiAibm9ybWFsIiwKICAgICAgICAgICAgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKQogICAgICAgICAgfTsKICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHR5cGU6ICJ0aHJvdyIsCiAgICAgICAgICAgIGFyZzogZXJyCiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgfQoKICAgICAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSAic3VzcGVuZGVkU3RhcnQiOwogICAgICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9ICJzdXNwZW5kZWRZaWVsZCI7CiAgICAgIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9ICJleGVjdXRpbmciOwogICAgICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSAiY29tcGxldGVkIjsgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhcwogICAgICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuCgogICAgICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9OyAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmQKICAgICAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yCiAgICAgIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyCiAgICAgIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuCgogICAgICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fQoKICAgICAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fQoKICAgICAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0CiAgICAgIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuCgoKICAgICAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307CgogICAgICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CgogICAgICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7CiAgICAgIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTsKCiAgICAgIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkgewogICAgICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkCiAgICAgICAgLy8gb2YgdGhlIHBvbHlmaWxsLgogICAgICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7CiAgICAgIH0KCiAgICAgIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTsKICAgICAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTsKICAgICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjsKICAgICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID0gR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSAiR2VuZXJhdG9yRnVuY3Rpb24iOyAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZQogICAgICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLgoKICAgICAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkgewogICAgICAgIFsibmV4dCIsICJ0aHJvdyIsICJyZXR1cm4iXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsKICAgICAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGFyZykgewogICAgICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTsKICAgICAgICAgIH07CiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHsKICAgICAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09ICJmdW5jdGlvbiIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yOwogICAgICAgIHJldHVybiBjdG9yID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhbgogICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS4KICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSAiR2VuZXJhdG9yRnVuY3Rpb24iIDogZmFsc2U7CiAgICAgIH07CgogICAgICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7CiAgICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikgewogICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7CgogICAgICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkgewogICAgICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gIkdlbmVyYXRvckZ1bmN0aW9uIjsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTsKICAgICAgICByZXR1cm4gZ2VuRnVuOwogICAgICB9OyAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG8KICAgICAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3QKICAgICAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCAiX19hd2FpdCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXMKICAgICAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC4KCgogICAgICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24gKGFyZykgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICBfX2F3YWl0OiBhcmcKICAgICAgICB9OwogICAgICB9OwoKICAgICAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHsKICAgICAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7CgogICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAidGhyb3ciKSB7CiAgICAgICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnOwogICAgICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7CgogICAgICAgICAgICBpZiAodmFsdWUgJiYgX3R5cGVvZjModmFsdWUpID09PSAib2JqZWN0IiAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgIl9fYXdhaXQiKSkgewogICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsKICAgICAgICAgICAgICAgIGludm9rZSgibmV4dCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpOwogICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsKICAgICAgICAgICAgICAgIGludm9rZSgidGhyb3ciLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkgewogICAgICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzCiAgICAgICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlCiAgICAgICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGUKICAgICAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZQogICAgICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90CiAgICAgICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZQogICAgICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW4KICAgICAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXQKICAgICAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWQKICAgICAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFjawogICAgICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aAogICAgICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGUKICAgICAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlCiAgICAgICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kCiAgICAgICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uCiAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkOwogICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTsKICAgICAgICAgICAgfSwgcmVqZWN0KTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIHZhciBwcmV2aW91c1Byb21pc2U7CgogICAgICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHsKICAgICAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgewogICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWwKICAgICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLAogICAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZgogICAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG8KICAgICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLAogICAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG8KICAgICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHkKICAgICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzCiAgICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseQogICAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGUKICAgICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5CiAgICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuCiAgICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXIKICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci4KICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7CiAgICAgICAgfSAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LAogICAgICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLgoKCiAgICAgICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTsKICAgICAgfQoKICAgICAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTsKCiAgICAgIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgewogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwoKICAgICAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjsgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZgogICAgICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2YKICAgICAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuCgogICAgICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7CiAgICAgICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSk7CiAgICAgICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLgogICAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7CiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTsKICAgICAgICB9KTsKICAgICAgfTsKCiAgICAgIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgewogICAgICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykgewogICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmciKTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7CiAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgICB0aHJvdyBhcmc7CiAgICAgICAgICAgIH0gLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzoKICAgICAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZQoKCiAgICAgICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7CiAgICAgICAgICB9CgogICAgICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7CiAgICAgICAgICBjb250ZXh0LmFyZyA9IGFyZzsKCiAgICAgICAgICB3aGlsZSAodHJ1ZSkgewogICAgICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlOwoKICAgICAgICAgICAgaWYgKGRlbGVnYXRlKSB7CiAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7CgogICAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkgewogICAgICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsKICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gIm5leHQiKSB7CiAgICAgICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzCiAgICAgICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi4KICAgICAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHsKICAgICAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7CiAgICAgICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZzsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpOwogICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSAicmV0dXJuIikgewogICAgICAgICAgICAgIGNvbnRleHQuYWJydXB0KCJyZXR1cm4iLCBjb250ZXh0LmFyZyk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7CiAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTsKCiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gIm5vcm1hbCIpIHsKICAgICAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09CiAgICAgICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLgogICAgICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lID8gR2VuU3RhdGVDb21wbGV0ZWQgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkOwoKICAgICAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgewogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsCiAgICAgICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmUKICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAidGhyb3ciKSB7CiAgICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDsgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZQogICAgICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuCgogICAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gInRocm93IjsKICAgICAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9IC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZQogICAgICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlCiAgICAgIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLAogICAgICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC4KCgogICAgICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7CiAgICAgICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTsKCiAgICAgICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3cKICAgICAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuCiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDsKCiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yWyJyZXR1cm4iXSkgewogICAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGEKICAgICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuCiAgICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSAicmV0dXJuIjsKICAgICAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDsKICAgICAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTsKCiAgICAgICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSAidGhyb3ciKSB7CiAgICAgICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbQogICAgICAgICAgICAgICAgLy8gInJldHVybiIgdG8gInRocm93IiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy4KICAgICAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSAidGhyb3ciOwogICAgICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2QiKTsKICAgICAgICAgIH0KCiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDsKICAgICAgICB9CgogICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7CgogICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gInRocm93IikgewogICAgICAgICAgY29udGV4dC5tZXRob2QgPSAidGhyb3ciOwogICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnOwogICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7CiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDsKICAgICAgICB9CgogICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZzsKCiAgICAgICAgaWYgKCFpbmZvKSB7CiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9ICJ0aHJvdyI7CiAgICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0Iik7CiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDsKICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsOwogICAgICAgIH0KCiAgICAgICAgaWYgKGluZm8uZG9uZSkgewogICAgICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnkKICAgICAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuCiAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTsgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLgoKICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7IC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyAidGhyb3ciIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGUKICAgICAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWYKICAgICAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyAibmV4dCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlbgogICAgICAgICAgLy8gImNvbnN1bWVkIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhcwogICAgICAgICAgLy8gInJldHVybiIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlCiAgICAgICAgICAvLyBvdXRlciBnZW5lcmF0b3IuCgogICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSAicmV0dXJuIikgewogICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9ICJuZXh0IjsKICAgICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC4KICAgICAgICAgIHJldHVybiBpbmZvOwogICAgICAgIH0gLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGgKICAgICAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLgoKCiAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7CiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7CiAgICAgIH0gLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGUKICAgICAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLgoKCiAgICAgIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7CiAgICAgIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9ICJHZW5lcmF0b3IiOyAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZQogICAgICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZQogICAgICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvcgogICAgICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi4KICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuCgogICAgICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CgogICAgICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gIltvYmplY3QgR2VuZXJhdG9yXSI7CiAgICAgIH07CgogICAgICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykgewogICAgICAgIHZhciBlbnRyeSA9IHsKICAgICAgICAgIHRyeUxvYzogbG9jc1swXQogICAgICAgIH07CgogICAgICAgIGlmICgxIGluIGxvY3MpIHsKICAgICAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTsKICAgICAgICB9CgogICAgICAgIGlmICgyIGluIGxvY3MpIHsKICAgICAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdOwogICAgICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdOwogICAgICAgIH0KCiAgICAgICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpOwogICAgICB9CgogICAgICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7CiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307CiAgICAgICAgcmVjb3JkLnR5cGUgPSAibm9ybWFsIjsKICAgICAgICBkZWxldGUgcmVjb3JkLmFyZzsKICAgICAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkOwogICAgICB9CgogICAgICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7CiAgICAgICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoCiAgICAgICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbQogICAgICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC4KICAgICAgICB0aGlzLnRyeUVudHJpZXMgPSBbewogICAgICAgICAgdHJ5TG9jOiAicm9vdCIKICAgICAgICB9XTsKICAgICAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7CiAgICAgICAgdGhpcy5yZXNldCh0cnVlKTsKICAgICAgfQoKICAgICAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkgewogICAgICAgIHZhciBrZXlzID0gW107CgogICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHsKICAgICAgICAgIGtleXMucHVzaChrZXkpOwogICAgICAgIH0KCiAgICAgICAga2V5cy5yZXZlcnNlKCk7IC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwCiAgICAgICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi4KCiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7CiAgICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHsKICAgICAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7CgogICAgICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkgewogICAgICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7CiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7CiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlCiAgICAgICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpcwogICAgICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uCgoKICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7CiAgICAgICAgICByZXR1cm4gbmV4dDsKICAgICAgICB9OwogICAgICB9OwoKICAgICAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7CiAgICAgICAgaWYgKGl0ZXJhYmxlKSB7CiAgICAgICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07CgogICAgICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7CiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgcmV0dXJuIGl0ZXJhYmxlOwogICAgICAgICAgfQoKICAgICAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkgewogICAgICAgICAgICB2YXIgaSA9IC0xLAogICAgICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7CiAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkgewogICAgICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkgewogICAgICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07CiAgICAgICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7CiAgICAgICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTsKICAgICAgICAgICAgICByZXR1cm4gbmV4dDsKICAgICAgICAgICAgfTsKCiAgICAgICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0OwogICAgICAgICAgfQogICAgICAgIH0gLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLgoKCiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIG5leHQ6IGRvbmVSZXN1bHQKICAgICAgICB9OwogICAgICB9CgogICAgICBydW50aW1lLnZhbHVlcyA9IHZhbHVlczsKCiAgICAgIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsCiAgICAgICAgICBkb25lOiB0cnVlCiAgICAgICAgfTsKICAgICAgfQoKICAgICAgQ29udGV4dC5wcm90b3R5cGUgPSB7CiAgICAgICAgY29uc3RydWN0b3I6IENvbnRleHQsCiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHsKICAgICAgICAgIHRoaXMucHJldiA9IDA7CiAgICAgICAgICB0aGlzLm5leHQgPSAwOyAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwncwogICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi4KCiAgICAgICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkOwogICAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7CiAgICAgICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDsKICAgICAgICAgIHRoaXMubWV0aG9kID0gIm5leHQiOwogICAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7CiAgICAgICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTsKCiAgICAgICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHsKICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7CiAgICAgICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczoKICAgICAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICJ0IiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7CiAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHsKICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7CiAgICAgICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdOwogICAgICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjsKCiAgICAgICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSAidGhyb3ciKSB7CiAgICAgICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnOwogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiB0aGlzLnJ2YWw7CiAgICAgICAgfSwKICAgICAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7CiAgICAgICAgICBpZiAodGhpcy5kb25lKSB7CiAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjsKICAgICAgICAgIH0KCiAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7CgogICAgICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7CiAgICAgICAgICAgIHJlY29yZC50eXBlID0gInRocm93IjsKICAgICAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjsKICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jOwoKICAgICAgICAgICAgaWYgKGNhdWdodCkgewogICAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssCiAgICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS4KICAgICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9ICJuZXh0IjsKICAgICAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgcmV0dXJuICEhY2F1Z2h0OwogICAgICAgICAgfQoKICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsKICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOwogICAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsKCiAgICAgICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09ICJyb290IikgewogICAgICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlCiAgICAgICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvCiAgICAgICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi4KICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKCJlbmQiKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHsKICAgICAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgImNhdGNoTG9jIik7CiAgICAgICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgImZpbmFsbHlMb2MiKTsKCiAgICAgICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgewogICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgewogICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgewogICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHkiKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHR5cGUsIGFyZykgewogICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgewogICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07CgogICAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgImZpbmFsbHlMb2MiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7CiAgICAgICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5OwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJiAodHlwZSA9PT0gImJyZWFrIiB8fCB0eXBlID09PSAiY29udGludWUiKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHsKICAgICAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYQogICAgICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suCiAgICAgICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7CiAgICAgICAgICB9CgogICAgICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307CiAgICAgICAgICByZWNvcmQudHlwZSA9IHR5cGU7CiAgICAgICAgICByZWNvcmQuYXJnID0gYXJnOwoKICAgICAgICAgIGlmIChmaW5hbGx5RW50cnkpIHsKICAgICAgICAgICAgdGhpcy5tZXRob2QgPSAibmV4dCI7CiAgICAgICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jOwogICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDsKICAgICAgICAgIH0KCiAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpOwogICAgICAgIH0sCiAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHsKICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gInRocm93IikgewogICAgICAgICAgICB0aHJvdyByZWNvcmQuYXJnOwogICAgICAgICAgfQoKICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gImJyZWFrIiB8fCByZWNvcmQudHlwZSA9PT0gImNvbnRpbnVlIikgewogICAgICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnOwogICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gInJldHVybiIpIHsKICAgICAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnOwogICAgICAgICAgICB0aGlzLm1ldGhvZCA9ICJyZXR1cm4iOwogICAgICAgICAgICB0aGlzLm5leHQgPSAiZW5kIjsKICAgICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09ICJub3JtYWwiICYmIGFmdGVyTG9jKSB7CiAgICAgICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jOwogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsOwogICAgICAgIH0sCiAgICAgICAgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykgewogICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgewogICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07CgogICAgICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykgewogICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpOwogICAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpOwogICAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiY2F0Y2giOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7CiAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7CiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsKCiAgICAgICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykgewogICAgICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOwoKICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnOwogICAgICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICByZXR1cm4gdGhyb3duOwogICAgICAgICAgICB9CiAgICAgICAgICB9IC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvbgogICAgICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLgoKCiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdCIpOwogICAgICAgIH0sCiAgICAgICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykgewogICAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHsKICAgICAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksCiAgICAgICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsCiAgICAgICAgICAgIG5leHRMb2M6IG5leHRMb2MKICAgICAgICAgIH07CgogICAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAibmV4dCIpIHsKICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3QKICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLgogICAgICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDsKICAgICAgICAgIH0KCiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDsKICAgICAgICB9CiAgICAgIH07CiAgICB9KCAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0bwogICAgLy8gRnVuY3Rpb24gY29uc3RydWN0b3IgaWYgd2UncmUgaW4gZ2xvYmFsIHN0cmljdCBtb2RlLiBUaGF0IGlzIHNhZGx5IGEgZm9ybQogICAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS4KICAgIGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9KCkgfHwgRnVuY3Rpb24oInJldHVybiB0aGlzIikoKSk7CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgIjk3NDQiOgogIC8qKiovCiAgZnVuY3Rpb24gXyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgICJ1c2Ugc3RyaWN0IjsKCiAgICB2YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNDU4OCIpOwoKICAgIHZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygiYmUxMyIpOwoKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwZWF0KGNvdW50KSB7CiAgICAgIHZhciBzdHIgPSBTdHJpbmcoZGVmaW5lZCh0aGlzKSk7CiAgICAgIHZhciByZXMgPSAnJzsKICAgICAgdmFyIG4gPSB0b0ludGVnZXIoY291bnQpOwogICAgICBpZiAobiA8IDAgfHwgbiA9PSBJbmZpbml0eSkgdGhyb3cgUmFuZ2VFcnJvcigiQ291bnQgY2FuJ3QgYmUgbmVnYXRpdmUiKTsKCiAgICAgIGZvciAoOyBuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpIHsKICAgICAgICBpZiAobiAmIDEpIHJlcyArPSBzdHI7CiAgICAgIH0KCiAgICAgIHJldHVybiByZXM7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiOWI0MyI6CiAgLyoqKi8KICBmdW5jdGlvbiBiNDMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmcKICAgIHZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJkOGU4Iik7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkgewogICAgICBhRnVuY3Rpb24oZm4pOwogICAgICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47CgogICAgICBzd2l0Y2ggKGxlbmd0aCkgewogICAgICAgIGNhc2UgMToKICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkgewogICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTsKICAgICAgICAgIH07CgogICAgICAgIGNhc2UgMjoKICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikgewogICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTsKICAgICAgICAgIH07CgogICAgICAgIGNhc2UgMzoKICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykgewogICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTsKICAgICAgICAgIH07CiAgICAgIH0KCiAgICAgIHJldHVybiBmdW5jdGlvbiAoKQogICAgICAvKiAuLi5hcmdzICovCiAgICAgIHsKICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTsKICAgICAgfTsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICI5YzZjIjoKICAvKioqLwogIGZ1bmN0aW9uIGM2Yyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIC8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc10KICAgIHZhciBVTlNDT1BBQkxFUyA9IF9fd2VicGFja19yZXF1aXJlX18oIjJiNGMiKSgndW5zY29wYWJsZXMnKTsKCiAgICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTsKICAgIGlmIChBcnJheVByb3RvW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIF9fd2VicGFja19yZXF1aXJlX18oIjMyZTkiKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pOwoKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkgewogICAgICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICI5YzgwIjoKICAvKioqLwogIGZ1bmN0aW9uIGM4MChtb2R1bGUsIGV4cG9ydHMpIHsKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHsKICAgICAgdHJ5IHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgZTogZmFsc2UsCiAgICAgICAgICB2OiBleGVjKCkKICAgICAgICB9OwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGU6IHRydWUsCiAgICAgICAgICB2OiBlCiAgICAgICAgfTsKICAgICAgfQogICAgfTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgIjlkZWYiOgogIC8qKiovCiAgZnVuY3Rpb24gZGVmKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgLy8gNy4xLjE1IFRvTGVuZ3RoCiAgICB2YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNDU4OCIpOwoKICAgIHZhciBtaW4gPSBNYXRoLm1pbjsKCiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogICAgICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MQogICAgfTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgIjllMWUiOgogIC8qKiovCiAgZnVuY3Rpb24gZTFlKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eQogICAgbW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXygiNzllNSIpKGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7CiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gNzsKICAgICAgICB9CiAgICAgIH0pLmEgIT0gNzsKICAgIH0pOwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICJhMjVmIjoKICAvKioqLwogIGZ1bmN0aW9uIGEyNWYobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNzcyNiIpOwoKICAgIHZhciBuYXZpZ2F0b3IgPSBnbG9iYWwubmF2aWdhdG9yOwogICAgbW9kdWxlLmV4cG9ydHMgPSBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJzsKICAgIC8qKiovCiAgfSwKCiAgLyoqKi8KICAiYTQ4MSI6CiAgLyoqKi8KICBmdW5jdGlvbiBhNDgxKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgLy8gQEByZXBsYWNlIGxvZ2ljCiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyMTRmIikoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2UpIHsKICAgICAgLy8gMjEuMS4zLjE0IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKQogICAgICByZXR1cm4gW2Z1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkgewogICAgICAgICd1c2Ugc3RyaWN0JzsKCiAgICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpOwogICAgICAgIHZhciBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdOwogICAgICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKSA6ICRyZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTsKICAgICAgfSwgJHJlcGxhY2VdOwogICAgfSk7CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICJhNWI4IjoKICAvKioqLwogIGZ1bmN0aW9uIGE1YjgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7IC8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpCgogICAgdmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oImQ4ZTgiKTsKCiAgICBmdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7CiAgICAgIHZhciByZXNvbHZlLCByZWplY3Q7CiAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7CiAgICAgICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpOwogICAgICAgIHJlc29sdmUgPSAkJHJlc29sdmU7CiAgICAgICAgcmVqZWN0ID0gJCRyZWplY3Q7CiAgICAgIH0pOwogICAgICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7CiAgICAgIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7CiAgICB9CgogICAgbW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7CiAgICAgIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiYWE3NyI6CiAgLyoqKi8KICBmdW5jdGlvbiBhYTc3KG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgdmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI1Y2ExIik7CgogICAgdmFyIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJiZTEzIik7CgogICAgdmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNzllNSIpOwoKICAgIHZhciBzcGFjZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJmZGVmIik7CgogICAgdmFyIHNwYWNlID0gJ1snICsgc3BhY2VzICsgJ10nOwogICAgdmFyIG5vbiA9ICJcdTIwMEJceDg1IjsKICAgIHZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKTsKICAgIHZhciBydHJpbSA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7CgogICAgdmFyIGV4cG9ydGVyID0gZnVuY3Rpb24gZXhwb3J0ZXIoS0VZLCBleGVjLCBBTElBUykgewogICAgICB2YXIgZXhwID0ge307CiAgICAgIHZhciBGT1JDRSA9IGZhaWxzKGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gISFzcGFjZXNbS0VZXSgpIHx8IG5vbltLRVldKCkgIT0gbm9uOwogICAgICB9KTsKICAgICAgdmFyIGZuID0gZXhwW0tFWV0gPSBGT1JDRSA/IGV4ZWModHJpbSkgOiBzcGFjZXNbS0VZXTsKICAgICAgaWYgKEFMSUFTKSBleHBbQUxJQVNdID0gZm47CiAgICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0UsICdTdHJpbmcnLCBleHApOwogICAgfTsgLy8gMSAtPiBTdHJpbmcjdHJpbUxlZnQKICAgIC8vIDIgLT4gU3RyaW5nI3RyaW1SaWdodAogICAgLy8gMyAtPiBTdHJpbmcjdHJpbQoKCiAgICB2YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbiAoc3RyaW5nLCBUWVBFKSB7CiAgICAgIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpOwogICAgICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7CiAgICAgIGlmIChUWVBFICYgMikgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTsKICAgICAgcmV0dXJuIHN0cmluZzsKICAgIH07CgogICAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlcjsKICAgIC8qKiovCiAgfSwKCiAgLyoqKi8KICAiYWFlMyI6CiAgLyoqKi8KICBmdW5jdGlvbiBhYWUzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpCiAgICB2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJkM2Y0Iik7CgogICAgdmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oIjJkOTUiKTsKCiAgICB2YXIgTUFUQ0ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyYjRjIikoJ21hdGNoJyk7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICAgICAgdmFyIGlzUmVnRXhwOwogICAgICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiYWI1NyI6CiAgLyoqKi8KICBmdW5jdGlvbiBhYjU3KG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMjM1MCIpKGZhbHNlKTsgLy8gaW1wb3J0cwogICAgLy8gbW9kdWxlCgogICAgZXhwb3J0cy5wdXNoKFttb2R1bGUuaSwgIi5hcGxheWVye2JhY2tncm91bmQ6I2ZmZjtmb250LWZhbWlseTpBcmlhbCxIZWx2ZXRpY2Esc2Fucy1zZXJpZjttYXJnaW46NXB4Oy13ZWJraXQtYm94LXNoYWRvdzowIDJweCAycHggMCByZ2JhKDAsMCwwLC4wNyksMCAxcHggNXB4IDAgcmdiYSgwLDAsMCwuMSk7Ym94LXNoYWRvdzowIDJweCAycHggMCByZ2JhKDAsMCwwLC4wNyksMCAxcHggNXB4IDAgcmdiYSgwLDAsMCwuMSk7Ym9yZGVyLXJhZGl1czoycHg7b3ZlcmZsb3c6aGlkZGVuOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtsaW5lLWhlaWdodDpub3JtYWw7cG9zaXRpb246cmVsYXRpdmV9LmFwbGF5ZXIgKnstd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveH0uYXBsYXllciBzdmd7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0uYXBsYXllciBzdmcgY2lyY2xlLC5hcGxheWVyIHN2ZyBwYXRoe2ZpbGw6I2ZmZn0uYXBsYXllci5hcGxheWVyLXdpdGhsaXN0IC5hcGxheWVyLWluZm97Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2U5ZTllOX0uYXBsYXllci5hcGxheWVyLXdpdGhsaXN0IC5hcGxheWVyLWxpc3R7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlfS5hcGxheWVyLmFwbGF5ZXItd2l0aGxpc3QgLmFwbGF5ZXItaWNvbi1vcmRlciwuYXBsYXllci5hcGxheWVyLXdpdGhsaXN0IC5hcGxheWVyLWluZm8gLmFwbGF5ZXItY29udHJvbGxlciAuYXBsYXllci10aW1lIC5hcGxheWVyLWljb24uYXBsYXllci1pY29uLW1lbnV7ZGlzcGxheTppbmxpbmV9LmFwbGF5ZXIuYXBsYXllci13aXRobHJjIC5hcGxheWVyLXBpY3toZWlnaHQ6OTBweDt3aWR0aDo5MHB4fS5hcGxheWVyLmFwbGF5ZXItd2l0aGxyYyAuYXBsYXllci1pbmZve21hcmdpbi1sZWZ0OjkwcHg7aGVpZ2h0OjkwcHg7cGFkZGluZzoxMHB4IDdweCAwIDdweH0uYXBsYXllci5hcGxheWVyLXdpdGhscmMgLmFwbGF5ZXItbHJje2Rpc3BsYXk6YmxvY2t9LmFwbGF5ZXIuYXBsYXllci1uYXJyb3d7d2lkdGg6NjZweH0uYXBsYXllci5hcGxheWVyLW5hcnJvdyAuYXBsYXllci1pbmZvLC5hcGxheWVyLmFwbGF5ZXItbmFycm93IC5hcGxheWVyLWxpc3R7ZGlzcGxheTpub25lfS5hcGxheWVyLmFwbGF5ZXItbmFycm93IC5hcGxheWVyLWJvZHksLmFwbGF5ZXIuYXBsYXllci1uYXJyb3cgLmFwbGF5ZXItcGlje2hlaWdodDo2NnB4O3dpZHRoOjY2cHh9LmFwbGF5ZXIuYXBsYXllci1maXhlZHtwb3NpdGlvbjpmaXhlZDtib3R0b206MDtsZWZ0OjA7cmlnaHQ6MDttYXJnaW46MDt6LWluZGV4Ojk5O292ZXJmbG93OnZpc2libGU7bWF4LXdpZHRoOjQwMHB4Oy13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZX0uYXBsYXllci5hcGxheWVyLWZpeGVkIC5hcGxheWVyLWxpc3R7bWFyZ2luLWJvdHRvbTo2NXB4O2JvcmRlcjoxcHggc29saWQgI2VlZTtib3JkZXItYm90dG9tOm5vbmU7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fS5hcGxheWVyLmFwbGF5ZXItZml4ZWQgLmFwbGF5ZXItYm9keXtwb3NpdGlvbjpmaXhlZDtib3R0b206MDtsZWZ0OjA7cmlnaHQ6MDttYXJnaW46MDt6LWluZGV4Ojk5O2JhY2tncm91bmQ6I2ZmZjtwYWRkaW5nLXJpZ2h0OjE4cHg7LXdlYmtpdC10cmFuc2l0aW9uOndpZHRoIC4zcyBlYXNlO3RyYW5zaXRpb246d2lkdGggLjNzIGVhc2U7bWF4LXdpZHRoOjQwMHB4O3dpZHRoOmNhbGMoMTAwJSAtIDE4cHgpfS5hcGxheWVyLmFwbGF5ZXItZml4ZWQgLmFwbGF5ZXItbHJje2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246Zml4ZWQ7Ym90dG9tOjEwcHg7bGVmdDowO3JpZ2h0OjA7bWFyZ2luOjA7ei1pbmRleDo5ODtwb2ludGVyLWV2ZW50czpub25lO3RleHQtc2hhZG93Oi0xcHggLTFweCAwICNmZmZ9LmFwbGF5ZXIuYXBsYXllci1maXhlZCAuYXBsYXllci1scmM6YWZ0ZXIsLmFwbGF5ZXIuYXBsYXllci1maXhlZCAuYXBsYXllci1scmM6YmVmb3Jle2Rpc3BsYXk6bm9uZX0uYXBsYXllci5hcGxheWVyLWZpeGVkIC5hcGxheWVyLWluZm97LXdlYmtpdC10cmFuc2Zvcm06c2NhbGVYKDEpO3RyYW5zZm9ybTpzY2FsZVgoMSk7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjAgMDt0cmFuc2Zvcm0tb3JpZ2luOjAgMDstd2Via2l0LXRyYW5zaXRpb246YWxsIC4zcyBlYXNlO3RyYW5zaXRpb246YWxsIC4zcyBlYXNlO2JvcmRlci1ib3R0b206bm9uZTtib3JkZXItdG9wOjFweCBzb2xpZCAjZTllOWU5fS5hcGxheWVyLmFwbGF5ZXItZml4ZWQgLmFwbGF5ZXItaW5mbyAuYXBsYXllci1tdXNpY3t3aWR0aDpjYWxjKDEwMCUgLSAxMDVweCl9LmFwbGF5ZXIuYXBsYXllci1maXhlZCAuYXBsYXllci1taW5pc3dpdGNoZXJ7ZGlzcGxheTpibG9ja30uYXBsYXllci5hcGxheWVyLWZpeGVkLmFwbGF5ZXItbmFycm93IC5hcGxheWVyLWluZm97ZGlzcGxheTpibG9jazstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVgoMCk7dHJhbnNmb3JtOnNjYWxlWCgwKX0uYXBsYXllci5hcGxheWVyLWZpeGVkLmFwbGF5ZXItbmFycm93IC5hcGxheWVyLWJvZHl7d2lkdGg6NjZweCFpbXBvcnRhbnR9LmFwbGF5ZXIuYXBsYXllci1maXhlZC5hcGxheWVyLW5hcnJvdyAuYXBsYXllci1taW5pc3dpdGNoZXIgLmFwbGF5ZXItaWNvbnstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGVZKDApO3RyYW5zZm9ybTpyb3RhdGVZKDApfS5hcGxheWVyLmFwbGF5ZXItZml4ZWQgLmFwbGF5ZXItaWNvbi1iYWNrLC5hcGxheWVyLmFwbGF5ZXItZml4ZWQgLmFwbGF5ZXItaWNvbi1mb3J3YXJkLC5hcGxheWVyLmFwbGF5ZXItZml4ZWQgLmFwbGF5ZXItaWNvbi1scmMsLmFwbGF5ZXIuYXBsYXllci1maXhlZCAuYXBsYXllci1pY29uLXBsYXl7ZGlzcGxheTppbmxpbmUtYmxvY2t9LmFwbGF5ZXIuYXBsYXllci1maXhlZCAuYXBsYXllci1pY29uLWJhY2ssLmFwbGF5ZXIuYXBsYXllci1maXhlZCAuYXBsYXllci1pY29uLWZvcndhcmQsLmFwbGF5ZXIuYXBsYXllci1maXhlZCAuYXBsYXllci1pY29uLW1lbnUsLmFwbGF5ZXIuYXBsYXllci1maXhlZCAuYXBsYXllci1pY29uLXBsYXl7cG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOjI3cHg7d2lkdGg6MjBweDtoZWlnaHQ6MjBweH0uYXBsYXllci5hcGxheWVyLWZpeGVkIC5hcGxheWVyLWljb24tYmFja3tyaWdodDo3NXB4fS5hcGxheWVyLmFwbGF5ZXItZml4ZWQgLmFwbGF5ZXItaWNvbi1wbGF5e3JpZ2h0OjUwcHh9LmFwbGF5ZXIuYXBsYXllci1maXhlZCAuYXBsYXllci1pY29uLWZvcndhcmR7cmlnaHQ6MjVweH0uYXBsYXllci5hcGxheWVyLWZpeGVkIC5hcGxheWVyLWljb24tbWVudXtyaWdodDowfS5hcGxheWVyLmFwbGF5ZXItYXJyb3cgLmFwbGF5ZXItaWNvbi1sb29wLC5hcGxheWVyLmFwbGF5ZXItYXJyb3cgLmFwbGF5ZXItaWNvbi1vcmRlciwuYXBsYXllci5hcGxheWVyLW1vYmlsZSAuYXBsYXllci1pY29uLXZvbHVtZS1kb3duLC5hcGxheWVyLmFwbGF5ZXItbW9iaWxlIC5hcGxheWVyLWljb24tdm9sdW1lLXVwe2Rpc3BsYXk6bm9uZX0uYXBsYXllci5hcGxheWVyLWxvYWRpbmcgLmFwbGF5ZXItaW5mbyAuYXBsYXllci1jb250cm9sbGVyIC5hcGxheWVyLWxvYWRpbmctaWNvbntkaXNwbGF5OmJsb2NrfS5hcGxheWVyLmFwbGF5ZXItbG9hZGluZyAuYXBsYXllci1pbmZvIC5hcGxheWVyLWNvbnRyb2xsZXIgLmFwbGF5ZXItYmFyLXdyYXAgLmFwbGF5ZXItYmFyIC5hcGxheWVyLXBsYXllZCAuYXBsYXllci10aHVtYnstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSgxKTt0cmFuc2Zvcm06c2NhbGUoMSl9LmFwbGF5ZXIgLmFwbGF5ZXItYm9keXtwb3NpdGlvbjpyZWxhdGl2ZX0uYXBsYXllciAuYXBsYXllci1pY29ue3dpZHRoOjE1cHg7aGVpZ2h0OjE1cHg7Ym9yZGVyOm5vbmU7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtvdXRsaW5lOm5vbmU7Y3Vyc29yOnBvaW50ZXI7b3BhY2l0eTouODt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7cGFkZGluZzowO2ZvbnQtc2l6ZToxMnB4O21hcmdpbjowO2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5hcGxheWVyIC5hcGxheWVyLWljb24gcGF0aHstd2Via2l0LXRyYW5zaXRpb246YWxsIC4ycyBlYXNlLWluLW91dDt0cmFuc2l0aW9uOmFsbCAuMnMgZWFzZS1pbi1vdXR9LmFwbGF5ZXIgLmFwbGF5ZXItaWNvbi1iYWNrLC5hcGxheWVyIC5hcGxheWVyLWljb24tZm9yd2FyZCwuYXBsYXllciAuYXBsYXllci1pY29uLWxyYywuYXBsYXllciAuYXBsYXllci1pY29uLW9yZGVyLC5hcGxheWVyIC5hcGxheWVyLWljb24tcGxheXtkaXNwbGF5Om5vbmV9LmFwbGF5ZXIgLmFwbGF5ZXItaWNvbi1scmMtaW5hY3Rpdml0eSBzdmd7b3BhY2l0eTouNH0uYXBsYXllciAuYXBsYXllci1pY29uLWZvcndhcmR7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDE4MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpfS5hcGxheWVyIC5hcGxheWVyLWxyYy1jb250ZW50e2Rpc3BsYXk6bm9uZX0uYXBsYXllciAuYXBsYXllci1waWN7cG9zaXRpb246cmVsYXRpdmU7ZmxvYXQ6bGVmdDtoZWlnaHQ6NjZweDt3aWR0aDo2NnB4O2JhY2tncm91bmQtc2l6ZTpjb3ZlcjtiYWNrZ3JvdW5kLXBvc2l0aW9uOjUwJTstd2Via2l0LXRyYW5zaXRpb246YWxsIC4zcyBlYXNlO3RyYW5zaXRpb246YWxsIC4zcyBlYXNlO2N1cnNvcjpwb2ludGVyfS5hcGxheWVyIC5hcGxheWVyLXBpYzpob3ZlciAuYXBsYXllci1idXR0b257b3BhY2l0eToxfS5hcGxheWVyIC5hcGxheWVyLXBpYyAuYXBsYXllci1idXR0b257cG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyLXJhZGl1czo1MCU7b3BhY2l0eTouODt0ZXh0LXNoYWRvdzowIDFweCAxcHggcmdiYSgwLDAsMCwuMik7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4IDFweCByZ2JhKDAsMCwwLC4yKTtib3gtc2hhZG93OjAgMXB4IDFweCByZ2JhKDAsMCwwLC4yKTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjIpOy13ZWJraXQtdHJhbnNpdGlvbjphbGwgLjFzIGVhc2U7dHJhbnNpdGlvbjphbGwgLjFzIGVhc2V9LmFwbGF5ZXIgLmFwbGF5ZXItcGljIC5hcGxheWVyLWJ1dHRvbiBwYXRoe2ZpbGw6I2ZmZn0uYXBsYXllciAuYXBsYXllci1waWMgLmFwbGF5ZXItaGlkZXtkaXNwbGF5Om5vbmV9LmFwbGF5ZXIgLmFwbGF5ZXItcGljIC5hcGxheWVyLXBsYXl7d2lkdGg6MjZweDtoZWlnaHQ6MjZweDtib3JkZXI6MnB4IHNvbGlkICNmZmY7Ym90dG9tOjUwJTtyaWdodDo1MCU7bWFyZ2luOjAgLTE1cHggLTE1cHggMH0uYXBsYXllciAuYXBsYXllci1waWMgLmFwbGF5ZXItcGxheSBzdmd7cG9zaXRpb246YWJzb2x1dGU7dG9wOjNweDtsZWZ0OjRweDtoZWlnaHQ6MjBweDt3aWR0aDoyMHB4fS5hcGxheWVyIC5hcGxheWVyLXBpYyAuYXBsYXllci1wYXVzZXt3aWR0aDoxNnB4O2hlaWdodDoxNnB4O2JvcmRlcjoycHggc29saWQgI2ZmZjtib3R0b206NHB4O3JpZ2h0OjRweH0uYXBsYXllciAuYXBsYXllci1waWMgLmFwbGF5ZXItcGF1c2Ugc3Zne3Bvc2l0aW9uOmFic29sdXRlO3RvcDoycHg7bGVmdDoycHg7aGVpZ2h0OjEycHg7d2lkdGg6MTJweH0uYXBsYXllciAuYXBsYXllci1pbmZve21hcmdpbi1sZWZ0OjY2cHg7cGFkZGluZzoxNHB4IDdweCAwIDEwcHg7aGVpZ2h0OjY2cHg7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fS5hcGxheWVyIC5hcGxheWVyLWluZm8gLmFwbGF5ZXItbXVzaWN7b3ZlcmZsb3c6aGlkZGVuO3doaXRlLXNwYWNlOm5vd3JhcDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO21hcmdpbjowIDAgMTNweCA1cHg7LXdlYmtpdC11c2VyLXNlbGVjdDp0ZXh0Oy1tb3otdXNlci1zZWxlY3Q6dGV4dDstbXMtdXNlci1zZWxlY3Q6dGV4dDt1c2VyLXNlbGVjdDp0ZXh0O2N1cnNvcjpkZWZhdWx0O3BhZGRpbmctYm90dG9tOjJweDtoZWlnaHQ6MjBweH0uYXBsYXllciAuYXBsYXllci1pbmZvIC5hcGxheWVyLW11c2ljIC5hcGxheWVyLXRpdGxle2ZvbnQtc2l6ZToxNHB4fS5hcGxheWVyIC5hcGxheWVyLWluZm8gLmFwbGF5ZXItbXVzaWMgLmFwbGF5ZXItYXV0aG9ye2ZvbnQtc2l6ZToxMnB4O2NvbG9yOiM2NjZ9LmFwbGF5ZXIgLmFwbGF5ZXItaW5mbyAuYXBsYXllci1jb250cm9sbGVye3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXh9LmFwbGF5ZXIgLmFwbGF5ZXItaW5mbyAuYXBsYXllci1jb250cm9sbGVyIC5hcGxheWVyLWJhci13cmFwe21hcmdpbjowIDAgMCA1cHg7cGFkZGluZzo0cHggMDtjdXJzb3I6cG9pbnRlciFpbXBvcnRhbnQ7LXdlYmtpdC1ib3gtZmxleDoxOy1tcy1mbGV4OjE7ZmxleDoxfS5hcGxheWVyIC5hcGxheWVyLWluZm8gLmFwbGF5ZXItY29udHJvbGxlciAuYXBsYXllci1iYXItd3JhcDpob3ZlciAuYXBsYXllci1iYXIgLmFwbGF5ZXItcGxheWVkIC5hcGxheWVyLXRodW1iey13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDEpO3RyYW5zZm9ybTpzY2FsZSgxKX0uYXBsYXllciAuYXBsYXllci1pbmZvIC5hcGxheWVyLWNvbnRyb2xsZXIgLmFwbGF5ZXItYmFyLXdyYXAgLmFwbGF5ZXItYmFye3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDoycHg7d2lkdGg6MTAwJTtiYWNrZ3JvdW5kOiNjZGNkY2R9LmFwbGF5ZXIgLmFwbGF5ZXItaW5mbyAuYXBsYXllci1jb250cm9sbGVyIC5hcGxheWVyLWJhci13cmFwIC5hcGxheWVyLWJhciAuYXBsYXllci1sb2FkZWR7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowO2JvdHRvbTowO2JhY2tncm91bmQ6I2FhYTtoZWlnaHQ6MnB4Oy13ZWJraXQtdHJhbnNpdGlvbjphbGwgLjVzIGVhc2U7dHJhbnNpdGlvbjphbGwgLjVzIGVhc2V9LmFwbGF5ZXIgLmFwbGF5ZXItaW5mbyAuYXBsYXllci1jb250cm9sbGVyIC5hcGxheWVyLWJhci13cmFwIC5hcGxheWVyLWJhciAuYXBsYXllci1wbGF5ZWR7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowO2JvdHRvbTowO2hlaWdodDoycHg7LXdlYmtpdC10cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjNzIGVhc2U7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4zcyBlYXNlfS5hcGxheWVyIC5hcGxheWVyLWluZm8gLmFwbGF5ZXItY29udHJvbGxlciAuYXBsYXllci1iYXItd3JhcCAuYXBsYXllci1iYXIgLmFwbGF5ZXItcGxheWVkIC5hcGxheWVyLXRodW1ie3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjVweDttYXJnaW4tdG9wOi00cHg7bWFyZ2luLXJpZ2h0Oi0xMHB4O2hlaWdodDoxMHB4O3dpZHRoOjEwcHg7Ym9yZGVyLXJhZGl1czo1MCU7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuM3MgZWFzZS1pbi1vdXQ7dHJhbnNpdGlvbjphbGwgLjNzIGVhc2UtaW4tb3V0Oy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDApO3RyYW5zZm9ybTpzY2FsZSgwKX0uYXBsYXllciAuYXBsYXllci1pbmZvIC5hcGxheWVyLWNvbnRyb2xsZXIgLmFwbGF5ZXItdGltZXtwb3NpdGlvbjpyZWxhdGl2ZTtyaWdodDowO2JvdHRvbTo0cHg7aGVpZ2h0OjE3cHg7Y29sb3I6Izk5OTtmb250LXNpemU6MTFweDtwYWRkaW5nLWxlZnQ6N3B4fS5hcGxheWVyIC5hcGxheWVyLWluZm8gLmFwbGF5ZXItY29udHJvbGxlciAuYXBsYXllci10aW1lIC5hcGxheWVyLXRpbWUtaW5uZXJ7dmVydGljYWwtYWxpZ246bWlkZGxlfS5hcGxheWVyIC5hcGxheWVyLWluZm8gLmFwbGF5ZXItY29udHJvbGxlciAuYXBsYXllci10aW1lIC5hcGxheWVyLWljb257Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMnMgZWFzZTt0cmFuc2l0aW9uOmFsbCAuMnMgZWFzZX0uYXBsYXllciAuYXBsYXllci1pbmZvIC5hcGxheWVyLWNvbnRyb2xsZXIgLmFwbGF5ZXItdGltZSAuYXBsYXllci1pY29uIHBhdGh7ZmlsbDojNjY2fS5hcGxheWVyIC5hcGxheWVyLWluZm8gLmFwbGF5ZXItY29udHJvbGxlciAuYXBsYXllci10aW1lIC5hcGxheWVyLWljb24uYXBsYXllci1pY29uLWxvb3B7bWFyZ2luLXJpZ2h0OjJweH0uYXBsYXllciAuYXBsYXllci1pbmZvIC5hcGxheWVyLWNvbnRyb2xsZXIgLmFwbGF5ZXItdGltZSAuYXBsYXllci1pY29uOmhvdmVyIHBhdGh7ZmlsbDojMDAwfS5hcGxheWVyIC5hcGxheWVyLWluZm8gLmFwbGF5ZXItY29udHJvbGxlciAuYXBsYXllci10aW1lIC5hcGxheWVyLWljb24uYXBsYXllci1pY29uLW1lbnUsLmFwbGF5ZXIgLmFwbGF5ZXItaW5mbyAuYXBsYXllci1jb250cm9sbGVyIC5hcGxheWVyLXRpbWUuYXBsYXllci10aW1lLW5hcnJvdyAuYXBsYXllci1pY29uLW1lbnUsLmFwbGF5ZXIgLmFwbGF5ZXItaW5mbyAuYXBsYXllci1jb250cm9sbGVyIC5hcGxheWVyLXRpbWUuYXBsYXllci10aW1lLW5hcnJvdyAuYXBsYXllci1pY29uLW1vZGV7ZGlzcGxheTpub25lfS5hcGxheWVyIC5hcGxheWVyLWluZm8gLmFwbGF5ZXItY29udHJvbGxlciAuYXBsYXllci12b2x1bWUtd3JhcHtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tbGVmdDozcHg7Y3Vyc29yOnBvaW50ZXIhaW1wb3J0YW50fS5hcGxheWVyIC5hcGxheWVyLWluZm8gLmFwbGF5ZXItY29udHJvbGxlciAuYXBsYXllci12b2x1bWUtd3JhcDpob3ZlciAuYXBsYXllci12b2x1bWUtYmFyLXdyYXB7aGVpZ2h0OjQwcHh9LmFwbGF5ZXIgLmFwbGF5ZXItaW5mbyAuYXBsYXllci1jb250cm9sbGVyIC5hcGxheWVyLXZvbHVtZS13cmFwIC5hcGxheWVyLXZvbHVtZS1iYXItd3JhcHtwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MTVweDtyaWdodDotM3B4O3dpZHRoOjI1cHg7aGVpZ2h0OjA7ei1pbmRleDo5OTtvdmVyZmxvdzpoaWRkZW47LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMnMgZWFzZS1pbi1vdXQ7dHJhbnNpdGlvbjphbGwgLjJzIGVhc2UtaW4tb3V0fS5hcGxheWVyIC5hcGxheWVyLWluZm8gLmFwbGF5ZXItY29udHJvbGxlciAuYXBsYXllci12b2x1bWUtd3JhcCAuYXBsYXllci12b2x1bWUtYmFyLXdyYXAuYXBsYXllci12b2x1bWUtYmFyLXdyYXAtYWN0aXZle2hlaWdodDo0MHB4fS5hcGxheWVyIC5hcGxheWVyLWluZm8gLmFwbGF5ZXItY29udHJvbGxlciAuYXBsYXllci12b2x1bWUtd3JhcCAuYXBsYXllci12b2x1bWUtYmFyLXdyYXAgLmFwbGF5ZXItdm9sdW1lLWJhcntwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDtyaWdodDoxMHB4O3dpZHRoOjVweDtoZWlnaHQ6MzVweDtiYWNrZ3JvdW5kOiNhYWE7Ym9yZGVyLXJhZGl1czoyLjVweDtvdmVyZmxvdzpoaWRkZW59LmFwbGF5ZXIgLmFwbGF5ZXItaW5mbyAuYXBsYXllci1jb250cm9sbGVyIC5hcGxheWVyLXZvbHVtZS13cmFwIC5hcGxheWVyLXZvbHVtZS1iYXItd3JhcCAuYXBsYXllci12b2x1bWUtYmFyIC5hcGxheWVyLXZvbHVtZXtwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDtyaWdodDowO3dpZHRoOjVweDstd2Via2l0LXRyYW5zaXRpb246YWxsIC4xcyBlYXNlO3RyYW5zaXRpb246YWxsIC4xcyBlYXNlfS5hcGxheWVyIC5hcGxheWVyLWluZm8gLmFwbGF5ZXItY29udHJvbGxlciAuYXBsYXllci1sb2FkaW5nLWljb257ZGlzcGxheTpub25lfS5hcGxheWVyIC5hcGxheWVyLWluZm8gLmFwbGF5ZXItY29udHJvbGxlciAuYXBsYXllci1sb2FkaW5nLWljb24gc3Zne3Bvc2l0aW9uOmFic29sdXRlOy13ZWJraXQtYW5pbWF0aW9uOnJvdGF0ZSAxcyBsaW5lYXIgaW5maW5pdGU7YW5pbWF0aW9uOnJvdGF0ZSAxcyBsaW5lYXIgaW5maW5pdGV9LmFwbGF5ZXIgLmFwbGF5ZXItbHJje2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjpyZWxhdGl2ZTtoZWlnaHQ6MzBweDt0ZXh0LWFsaWduOmNlbnRlcjtvdmVyZmxvdzpoaWRkZW47bWFyZ2luOi0xMHB4IDAgN3B4fS5hcGxheWVyIC5hcGxheWVyLWxyYzpiZWZvcmV7dG9wOjA7aGVpZ2h0OjEwJTtiYWNrZ3JvdW5kOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLGxlZnQgdG9wLGxlZnQgYm90dG9tLGZyb20oI2ZmZiksdG8oaHNsYSgwLDAlLDEwMCUsMCkpKTtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCgxODBkZWcsI2ZmZiAwLGhzbGEoMCwwJSwxMDAlLDApKTtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9XCIjZmZmZmZmXCIsZW5kQ29sb3JzdHI9XCIjMDBmZmZmZmZcIixHcmFkaWVudFR5cGU9MCl9LmFwbGF5ZXIgLmFwbGF5ZXItbHJjOmFmdGVyLC5hcGxheWVyIC5hcGxheWVyLWxyYzpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoxO2Rpc3BsYXk6YmxvY2s7b3ZlcmZsb3c6aGlkZGVuO3dpZHRoOjEwMCU7Y29udGVudDpcIiBcIn0uYXBsYXllciAuYXBsYXllci1scmM6YWZ0ZXJ7Ym90dG9tOjA7aGVpZ2h0OjMzJTtiYWNrZ3JvdW5kOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLGxlZnQgdG9wLGxlZnQgYm90dG9tLGZyb20oaHNsYSgwLDAlLDEwMCUsMCkpLHRvKGhzbGEoMCwwJSwxMDAlLC44KSkpO2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KDE4MGRlZyxoc2xhKDAsMCUsMTAwJSwwKSAwLGhzbGEoMCwwJSwxMDAlLC44KSk7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPVwiIzAwZmZmZmZmXCIsZW5kQ29sb3JzdHI9XCIjY2NmZmZmZmZcIixHcmFkaWVudFR5cGU9MCl9LmFwbGF5ZXIgLmFwbGF5ZXItbHJjIHB7Zm9udC1zaXplOjEycHg7Y29sb3I6IzY2NjtsaW5lLWhlaWdodDoxNnB4IWltcG9ydGFudDtoZWlnaHQ6MTZweCFpbXBvcnRhbnQ7cGFkZGluZzowIWltcG9ydGFudDttYXJnaW46MCFpbXBvcnRhbnQ7LXdlYmtpdC10cmFuc2l0aW9uLXByb3BlcnR5OmZvbnQtc2l6ZSxjb2xvcixvcGFjaXR5O3RyYW5zaXRpb24tcHJvcGVydHk6Zm9udC1zaXplLGNvbG9yLG9wYWNpdHk7LXdlYmtpdC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLW91dDt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLW91dDstd2Via2l0LXRyYW5zaXRpb24tZHVyYXRpb246LjVzO3RyYW5zaXRpb24tZHVyYXRpb246LjVzO29wYWNpdHk6LjQ7b3ZlcmZsb3c6aGlkZGVufS5hcGxheWVyIC5hcGxheWVyLWxyYyBwLmFwbGF5ZXItbHJjLWN1cnJlbnR7b3BhY2l0eToxO292ZXJmbG93OnZpc2libGU7aGVpZ2h0OmF1dG8haW1wb3J0YW50O21pbi1oZWlnaHQ6MTZweH0uYXBsYXllciAuYXBsYXllci1scmMuYXBsYXllci1scmMtaGlkZXtkaXNwbGF5Om5vbmV9LmFwbGF5ZXIgLmFwbGF5ZXItbHJjIC5hcGxheWVyLWxyYy1jb250ZW50c3t3aWR0aDoxMDAlOy13ZWJraXQtdHJhbnNpdGlvbjphbGwgLjVzIGVhc2Utb3V0O3RyYW5zaXRpb246YWxsIC41cyBlYXNlLW91dDstd2Via2l0LXVzZXItc2VsZWN0OnRleHQ7LW1vei11c2VyLXNlbGVjdDp0ZXh0Oy1tcy11c2VyLXNlbGVjdDp0ZXh0O3VzZXItc2VsZWN0OnRleHQ7Y3Vyc29yOmRlZmF1bHR9LmFwbGF5ZXIgLmFwbGF5ZXItbGlzdHtvdmVyZmxvdzphdXRvOy13ZWJraXQtdHJhbnNpdGlvbjphbGwgLjVzIGVhc2U7dHJhbnNpdGlvbjphbGwgLjVzIGVhc2U7d2lsbC1jaGFuZ2U6aGVpZ2h0O2Rpc3BsYXk6bm9uZTtvdmVyZmxvdzpoaWRkZW47bGlzdC1zdHlsZS10eXBlOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowO292ZXJmbG93LXk6YXV0b30uYXBsYXllciAuYXBsYXllci1saXN0Ojotd2Via2l0LXNjcm9sbGJhcnt3aWR0aDo1cHh9LmFwbGF5ZXIgLmFwbGF5ZXItbGlzdDo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7Ym9yZGVyLXJhZGl1czozcHg7YmFja2dyb3VuZC1jb2xvcjojZWVlfS5hcGxheWVyIC5hcGxheWVyLWxpc3Q6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2NjY30uYXBsYXllciAuYXBsYXllci1saXN0IGxpe3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDozMnB4O2xpbmUtaGVpZ2h0OjMycHg7cGFkZGluZzowIDE1cHg7Zm9udC1zaXplOjEycHg7Ym9yZGVyLXRvcDoxcHggc29saWQgI2U5ZTllOTtjdXJzb3I6cG9pbnRlcjstd2Via2l0LXRyYW5zaXRpb246YWxsIC4ycyBlYXNlO3RyYW5zaXRpb246YWxsIC4ycyBlYXNlO292ZXJmbG93OmhpZGRlbjttYXJnaW46MH0uYXBsYXllciAuYXBsYXllci1saXN0IGxpOmZpcnN0LWNoaWxke2JvcmRlci10b3A6bm9uZX0uYXBsYXllciAuYXBsYXllci1saXN0IGxpOmhvdmVye2JhY2tncm91bmQ6I2VmZWZlZn0uYXBsYXllciAuYXBsYXllci1saXN0IGxpLmFwbGF5ZXItbGlzdC1saWdodHtiYWNrZ3JvdW5kOiNlOWU5ZTl9LmFwbGF5ZXIgLmFwbGF5ZXItbGlzdCBsaS5hcGxheWVyLWxpc3QtbGlnaHQgLmFwbGF5ZXItbGlzdC1jdXJ7ZGlzcGxheTppbmxpbmUtYmxvY2t9LmFwbGF5ZXIgLmFwbGF5ZXItbGlzdCBsaSAuYXBsYXllci1saXN0LWN1cntkaXNwbGF5Om5vbmU7d2lkdGg6M3B4O2hlaWdodDoyMnB4O3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6NXB4Oy13ZWJraXQtdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4zcyBlYXNlO3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuM3MgZWFzZTtjdXJzb3I6cG9pbnRlcn0uYXBsYXllciAuYXBsYXllci1saXN0IGxpIC5hcGxheWVyLWxpc3QtaW5kZXh7Y29sb3I6IzY2NjttYXJnaW4tcmlnaHQ6MTJweDtjdXJzb3I6cG9pbnRlcn0uYXBsYXllciAuYXBsYXllci1saXN0IGxpIC5hcGxheWVyLWxpc3QtYXV0aG9ye2NvbG9yOiM2NjY7ZmxvYXQ6cmlnaHQ7Y3Vyc29yOnBvaW50ZXJ9LmFwbGF5ZXIgLmFwbGF5ZXItbm90aWNle29wYWNpdHk6MDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjE7dG9wOjUwJTtsZWZ0OjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsLTUwJSk7Zm9udC1zaXplOjEycHg7Ym9yZGVyLXJhZGl1czo0cHg7cGFkZGluZzo1cHggMTBweDstd2Via2l0LXRyYW5zaXRpb246YWxsIC4zcyBlYXNlLWluLW91dDt0cmFuc2l0aW9uOmFsbCAuM3MgZWFzZS1pbi1vdXQ7b3ZlcmZsb3c6aGlkZGVuO2NvbG9yOiNmZmY7cG9pbnRlci1ldmVudHM6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOiNmNGY0ZjU7Y29sb3I6IzkwOTM5OX0uYXBsYXllciAuYXBsYXllci1taW5pc3dpdGNoZXJ7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7aGVpZ2h0OjEwMCU7YmFja2dyb3VuZDojZTZlNmU2O3dpZHRoOjE4cHg7Ym9yZGVyLXJhZGl1czowIDJweCAycHggMH0uYXBsYXllciAuYXBsYXllci1taW5pc3dpdGNoZXIgLmFwbGF5ZXItaWNvbntoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZVkoMTgwZGVnKTt0cmFuc2Zvcm06cm90YXRlWSgxODBkZWcpOy13ZWJraXQtdHJhbnNpdGlvbjphbGwgLjNzIGVhc2U7dHJhbnNpdGlvbjphbGwgLjNzIGVhc2V9LmFwbGF5ZXIgLmFwbGF5ZXItbWluaXN3aXRjaGVyIC5hcGxheWVyLWljb24gcGF0aHtmaWxsOiM2NjZ9LmFwbGF5ZXIgLmFwbGF5ZXItbWluaXN3aXRjaGVyIC5hcGxheWVyLWljb246aG92ZXIgcGF0aHtmaWxsOiMwMDB9QC13ZWJraXQta2V5ZnJhbWVzIGFwbGF5ZXItcm9sbHswJXtsZWZ0OjB9dG97bGVmdDotMTAwJX19QGtleWZyYW1lcyBhcGxheWVyLXJvbGx7MCV7bGVmdDowfXRve2xlZnQ6LTEwMCV9fUAtd2Via2l0LWtleWZyYW1lcyByb3RhdGV7MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDApO3RyYW5zZm9ybTpyb3RhdGUoMCl9dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDF0dXJuKTt0cmFuc2Zvcm06cm90YXRlKDF0dXJuKX19QGtleWZyYW1lcyByb3RhdGV7MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDApO3RyYW5zZm9ybTpyb3RhdGUoMCl9dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDF0dXJuKTt0cmFuc2Zvcm06cm90YXRlKDF0dXJuKX19IiwgIiJdKTsgLy8gZXhwb3J0cwoKICAgIC8qKiovCiAgfSwKCiAgLyoqKi8KICAiYWM2YSI6CiAgLyoqKi8KICBmdW5jdGlvbiBhYzZhKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgdmFyICRpdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJjYWRmIik7CgogICAgdmFyIGdldEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIwZDU4Iik7CgogICAgdmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMmFiYSIpOwoKICAgIHZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI3NzI2Iik7CgogICAgdmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIzMmU5Iik7CgogICAgdmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oIjg0ZjIiKTsKCiAgICB2YXIgd2tzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMmI0YyIpOwoKICAgIHZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTsKICAgIHZhciBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpOwogICAgdmFyIEFycmF5VmFsdWVzID0gSXRlcmF0b3JzLkFycmF5OwogICAgdmFyIERPTUl0ZXJhYmxlcyA9IHsKICAgICAgQ1NTUnVsZUxpc3Q6IHRydWUsCiAgICAgIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLgogICAgICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSwKICAgICAgQ1NTVmFsdWVMaXN0OiBmYWxzZSwKICAgICAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLAogICAgICBET01SZWN0TGlzdDogZmFsc2UsCiAgICAgIERPTVN0cmluZ0xpc3Q6IGZhbHNlLAogICAgICBET01Ub2tlbkxpc3Q6IHRydWUsCiAgICAgIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSwKICAgICAgRmlsZUxpc3Q6IGZhbHNlLAogICAgICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsCiAgICAgIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSwKICAgICAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSwKICAgICAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLAogICAgICBNZWRpYUxpc3Q6IHRydWUsCiAgICAgIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLgogICAgICBNaW1lVHlwZUFycmF5OiBmYWxzZSwKICAgICAgTmFtZWROb2RlTWFwOiBmYWxzZSwKICAgICAgTm9kZUxpc3Q6IHRydWUsCiAgICAgIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLAogICAgICBQbHVnaW46IGZhbHNlLAogICAgICBQbHVnaW5BcnJheTogZmFsc2UsCiAgICAgIFNWR0xlbmd0aExpc3Q6IGZhbHNlLAogICAgICBTVkdOdW1iZXJMaXN0OiBmYWxzZSwKICAgICAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLAogICAgICBTVkdQb2ludExpc3Q6IGZhbHNlLAogICAgICBTVkdTdHJpbmdMaXN0OiBmYWxzZSwKICAgICAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsCiAgICAgIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLAogICAgICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwKICAgICAgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuCiAgICAgIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLAogICAgICBUZXh0VHJhY2tMaXN0OiBmYWxzZSwKICAgICAgVG91Y2hMaXN0OiBmYWxzZQogICAgfTsKCiAgICBmb3IgKHZhciBjb2xsZWN0aW9ucyA9IGdldEtleXMoRE9NSXRlcmFibGVzKSwgaSA9IDA7IGkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGkrKykgewogICAgICB2YXIgTkFNRSA9IGNvbGxlY3Rpb25zW2ldOwogICAgICB2YXIgZXhwbGljaXQgPSBET01JdGVyYWJsZXNbTkFNRV07CiAgICAgIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdOwogICAgICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlOwogICAgICB2YXIga2V5OwoKICAgICAgaWYgKHByb3RvKSB7CiAgICAgICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7CiAgICAgICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7CiAgICAgICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7CiAgICAgICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSB7CiAgICAgICAgICBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICJhZGVjIjoKICAvKioqLwogIGZ1bmN0aW9uIGFkZWMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7CgogICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pOwogICAgLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLwoKCiAgICBfX3dlYnBhY2tfZXhwb3J0c19fWyJkZWZhdWx0Il0gPSB7CiAgICAgIGZ1bmN0aW9uYWw6IHRydWUsCiAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKF9oLCBfdm0pIHsKICAgICAgICB2YXIgX2MgPSBfdm0uX2M7CiAgICAgICAgcmV0dXJuIF9jKCdzdmcnLCB7CiAgICAgICAgICAiY2xhc3MiOiBbX3ZtLmRhdGFbImNsYXNzIl0sIF92bS5kYXRhLnN0YXRpY0NsYXNzXSwKICAgICAgICAgIHN0eWxlOiBbX3ZtLmRhdGEuc3R5bGUsIF92bS5kYXRhLnN0YXRpY1N0eWxlXSwKICAgICAgICAgIGF0dHJzOiB7CiAgICAgICAgICAgICJ4bWxucyI6ICJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIsCiAgICAgICAgICAgICJ2aWV3Qm94IjogIjAgMCAyOCAzMiIKICAgICAgICAgIH0KICAgICAgICB9LCBbX2MoJ3BhdGgnLCB7CiAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAiZCI6ICJNMTMuNzI4IDYuMjcydjE5LjQ1NnEwIC40NDgtLjM1Mi44dC0uOC4zMi0uOC0uMzJsLTUuOTUyLTUuOTUySDEuMTUycS0uNDggMC0uOC0uMzUydC0uMzUyLS44di02Ljg0OHEwLS40OC4zNTItLjh0LjgtLjM1Mmg0LjY3Mmw1Ljk1Mi01Ljk1MnEuMzItLjMyLjgtLjMydC44LjMyLjM1Mi44eiIKICAgICAgICAgIH0KICAgICAgICB9KV0pOwogICAgICB9CiAgICB9OwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICJiMzQ5IjoKICAvKioqLwogIGZ1bmN0aW9uIGIzNDkobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7CgogICAgdmFyIF9fZXh0ZW5kcyA9IHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24gKCkgewogICAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7CiAgICAgICAgX19wcm90b19fOiBbXQogICAgICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsKICAgICAgICBkLl9fcHJvdG9fXyA9IGI7CiAgICAgIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHsKICAgICAgICBmb3IgKHZhciBwIGluIGIpIHsKICAgICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsKICAgICAgICB9CiAgICAgIH07CgogICAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHsKICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpOwoKICAgICAgICBmdW5jdGlvbiBfXygpIHsKICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBkOwogICAgICAgIH0KCiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpOwogICAgICB9OwogICAgfSgpOwoKICAgIHZhciBfX2Fzc2lnbiA9IHRoaXMgJiYgdGhpcy5fX2Fzc2lnbiB8fCBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7CiAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykgewogICAgICAgIHMgPSBhcmd1bWVudHNbaV07CgogICAgICAgIGZvciAodmFyIHAgaW4gcykgewogICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gdDsKICAgIH07CgogICAgdmFyIF9faW1wb3J0RGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24gKG1vZCkgewogICAgICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDogewogICAgICAgICJkZWZhdWx0IjogbW9kCiAgICAgIH07CiAgICB9OwoKICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsKICAgICAgdmFsdWU6IHRydWUKICAgIH0pOwoKICAgIHZhciB2dWVfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKCI4YmJmIikpOwoKICAgIHZhciBDb21wb25lbnQgPQogICAgLyoqIEBjbGFzcyAqLwogICAgZnVuY3Rpb24gKF9zdXBlcikgewogICAgICBfX2V4dGVuZHMoQ29tcG9uZW50LCBfc3VwZXIpOwoKICAgICAgZnVuY3Rpb24gQ29tcG9uZW50KCkgewogICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzOwoKICAgICAgICBfdGhpcy5fdHN4YXR0cnMgPSB1bmRlZmluZWQ7CiAgICAgICAgX3RoaXMuJHNjb3BlZFNsb3RzID0gdW5kZWZpbmVkOwogICAgICAgIHJldHVybiBfdGhpczsKICAgICAgfQoKICAgICAgcmV0dXJuIENvbXBvbmVudDsKICAgIH0odnVlXzFbImRlZmF1bHQiXSk7CgogICAgZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7CiAgICAvKioKICAgICAqIENyZWF0ZSBjb21wb25lbnQgZnJvbSBjb21wb25lbnQgb3B0aW9ucyAoQ29tcGF0aWJsZSB3aXRoIFZ1ZS5leHRlbmQpCiAgICAgKi8KCiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQob3B0cykgewogICAgICByZXR1cm4gdnVlXzFbImRlZmF1bHQiXS5leHRlbmQob3B0cyk7CiAgICB9CgogICAgZXhwb3J0cy5jcmVhdGVDb21wb25lbnQgPSBjcmVhdGVDb21wb25lbnQ7CiAgICB2YXIgZmFjdG9yeUltcGwgPSB7CiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uIGNvbnZlcnQoYykgewogICAgICAgIHJldHVybiBjOwogICAgICB9LAogICAgICBleHRlbmRGcm9tOiBmdW5jdGlvbiBleHRlbmRGcm9tKGMpIHsKICAgICAgICByZXR1cm4gYzsKICAgICAgfQogICAgfTsKICAgIC8qKgogICAgICogU3BlY2lmeSBQcm9wcyBhbmQgRXZlbnQgdHlwZXMgb2YgY29tcG9uZW50CiAgICAgKgogICAgICogVXNhZ2U6CiAgICAgKiAgLy8gR2V0IFRTWC1zdXBwb3J0ZWQgY29tcG9uZW50IHdpdGggcHJvcHMoYG5hbWVgLCBgdmFsdWVgKSBhbmQgZXZlbnQoYG9uSW5wdXRgKQogICAgICogIGNvbnN0IE5ld0NvbXBvbmVudCA9IHRzeC5vZlR5cGU8eyBuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfSwgeyBvbklucHV0OiBzdHJpbmcgfT4uY29udmVydChDb21wb25lbnQpOwogICAgICovCgogICAgZnVuY3Rpb24gb2ZUeXBlKCkgewogICAgICByZXR1cm4gZmFjdG9yeUltcGw7CiAgICB9CgogICAgZXhwb3J0cy5vZlR5cGUgPSBvZlR5cGU7CgogICAgZnVuY3Rpb24gd2l0aE5hdGl2ZU9uKGNvbXBvbmVudFR5cGUpIHsKICAgICAgcmV0dXJuIGNvbXBvbmVudFR5cGU7CiAgICB9CgogICAgZXhwb3J0cy53aXRoTmF0aXZlT24gPSB3aXRoTmF0aXZlT247CgogICAgZnVuY3Rpb24gd2l0aEh0bWxBdHRycyhjb21wb25lbnRUeXBlKSB7CiAgICAgIHJldHVybiBjb21wb25lbnRUeXBlOwogICAgfQoKICAgIGV4cG9ydHMud2l0aEh0bWxBdHRycyA9IHdpdGhIdG1sQXR0cnM7CgogICAgZnVuY3Rpb24gd2l0aFVua25vd25Qcm9wcyhjb21wb25lbnRUeXBlKSB7CiAgICAgIHJldHVybiBjb21wb25lbnRUeXBlOwogICAgfQoKICAgIGV4cG9ydHMud2l0aFVua25vd25Qcm9wcyA9IHdpdGhVbmtub3duUHJvcHM7CgogICAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50RmFjdG9yeShiYXNlLCBtaXhpbnMpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7CiAgICAgICAgICB2YXIgbWVyZ2VkTWl4aW5zID0gb3B0aW9ucy5taXhpbnMgPyBvcHRpb25zLm1peGlucy5jb25jYXQobWl4aW5zKSA6IG1peGluczsKICAgICAgICAgIHJldHVybiBiYXNlLmV4dGVuZChfX2Fzc2lnbih7fSwgb3B0aW9ucywgewogICAgICAgICAgICBtaXhpbnM6IG1lcmdlZE1peGlucwogICAgICAgICAgfSkpOwogICAgICAgIH0sCiAgICAgICAgbWl4aW46IGZ1bmN0aW9uIG1peGluKG1peGluT2JqZWN0KSB7CiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50RmFjdG9yeShiYXNlLCBtaXhpbnMuY29uY2F0KFttaXhpbk9iamVjdF0pKTsKICAgICAgICB9CiAgICAgIH07CiAgICB9CgogICAgZnVuY3Rpb24gY3JlYXRlRXh0ZW5kYWJsZUNvbXBvbmVudEZhY3RvcnkoKSB7CiAgICAgIHJldHVybiB7CiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUob3B0aW9ucykgewogICAgICAgICAgcmV0dXJuIHZ1ZV8xWyJkZWZhdWx0Il0uZXh0ZW5kKG9wdGlvbnMpOwogICAgICAgIH0sCiAgICAgICAgZXh0ZW5kRnJvbTogZnVuY3Rpb24gZXh0ZW5kRnJvbShiYXNlKSB7CiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50RmFjdG9yeShiYXNlLCBbXSk7CiAgICAgICAgfSwKICAgICAgICBtaXhpbjogZnVuY3Rpb24gbWl4aW4obWl4aW5PYmplY3QpIHsKICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnRGYWN0b3J5KHZ1ZV8xWyJkZWZhdWx0Il0sIFttaXhpbk9iamVjdF0pOwogICAgICAgIH0KICAgICAgfTsKICAgIH0KCiAgICBleHBvcnRzLmNvbXBvbmVudEZhY3RvcnkgPSBjcmVhdGVFeHRlbmRhYmxlQ29tcG9uZW50RmFjdG9yeSgpOwoKICAgIGZ1bmN0aW9uIGNvbXBvbmVudEZhY3RvcnlPZigpIHsKICAgICAgcmV0dXJuIGV4cG9ydHMuY29tcG9uZW50RmFjdG9yeTsKICAgIH0KCiAgICBleHBvcnRzLmNvbXBvbmVudEZhY3RvcnlPZiA9IGNvbXBvbmVudEZhY3RvcnlPZjsKICAgIC8qKgogICAgICogU2hvcnRoYW5kIG9mIGBjb21wb25lbnRGYWN0b3J5LmNyZWF0ZWAKICAgICAqLwoKICAgIGV4cG9ydHMuY29tcG9uZW50ID0gZXhwb3J0cy5jb21wb25lbnRGYWN0b3J5LmNyZWF0ZTsKICAgIGV4cG9ydHMuZXh0ZW5kRnJvbSA9IGV4cG9ydHMuY29tcG9uZW50RmFjdG9yeS5leHRlbmRGcm9tOwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICJiY2FhIjoKICAvKioqLwogIGZ1bmN0aW9uIGJjYWEobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJjYjdjIik7CgogICAgdmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiZDNmNCIpOwoKICAgIHZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IF9fd2VicGFja19yZXF1aXJlX18oImE1YjgiKTsKCiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7CiAgICAgIGFuT2JqZWN0KEMpOwogICAgICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7CiAgICAgIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7CiAgICAgIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTsKICAgICAgcmVzb2x2ZSh4KTsKICAgICAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiYmRiYSI6CiAgLyoqKi8KICBmdW5jdGlvbiBiZGJhKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgInVzZSBzdHJpY3QiOwoKICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTsKICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8KCgogICAgX193ZWJwYWNrX2V4cG9ydHNfX1siZGVmYXVsdCJdID0gewogICAgICBmdW5jdGlvbmFsOiB0cnVlLAogICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihfaCwgX3ZtKSB7CiAgICAgICAgdmFyIF9jID0gX3ZtLl9jOwogICAgICAgIHJldHVybiBfYygnc3ZnJywgewogICAgICAgICAgImNsYXNzIjogW192bS5kYXRhWyJjbGFzcyJdLCBfdm0uZGF0YS5zdGF0aWNDbGFzc10sCiAgICAgICAgICBzdHlsZTogW192bS5kYXRhLnN0eWxlLCBfdm0uZGF0YS5zdGF0aWNTdHlsZV0sCiAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAieG1sbnMiOiAiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLAogICAgICAgICAgICAidmlld0JveCI6ICIwIDAgMjggMzIiCiAgICAgICAgICB9CiAgICAgICAgfSwgW19jKCdwYXRoJywgewogICAgICAgICAgYXR0cnM6IHsKICAgICAgICAgICAgImQiOiAiTTEzLjcyOCA2LjI3MnYxOS40NTZxMCAuNDQ4LS4zNTIuOHQtLjguMzItLjgtLjMybC01Ljk1Mi01Ljk1MkgxLjE1MnEtLjQ4IDAtLjgtLjM1MnQtLjM1Mi0uOHYtNi44NDhxMC0uNDguMzUyLS44dC44LS4zNTJoNC42NzJsNS45NTItNS45NTJxLjMyLS4zMi44LS4zMnQuOC4zMi4zNTIuOHpNMjAuNTc2IDE2cTAgMS4zNDQtLjc2OCAyLjUyOHQtMi4wMTYgMS42NjRxLS4xNi4wOTYtLjQ0OC4wOTYtLjQ0OCAwLS44LS4zMnQtLjMyLS44MzJxMC0uMzg0LjE5Mi0uNjR0LjU0NC0uNDQ4LjYwOC0uMzg0LjUxMi0uNjQuMTkyLTEuMDI0LS4xOTItMS4wMjQtLjUxMi0uNjQtLjYwOC0uMzg0LS41NDQtLjQ0OC0uMTkyLS42NHEwLS40OC4zMi0uODMydC44LS4zMnEuMjg4IDAgLjQ0OC4wOTYgMS4yNDguNDggMi4wMTYgMS42NjRUMjAuNTc2IDE2eiIKICAgICAgICAgIH0KICAgICAgICB9KV0pOwogICAgICB9CiAgICB9OwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICJiZTEzIjoKICAvKioqLwogIGZ1bmN0aW9uIGJlMTMobW9kdWxlLCBleHBvcnRzKSB7CiAgICAvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KQogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICAgICAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgIiArIGl0KTsKICAgICAgcmV0dXJuIGl0OwogICAgfTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgImJmNWMiOgogIC8qKiovCiAgZnVuY3Rpb24gYmY1Yyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgICJ1c2Ugc3RyaWN0IjsKCiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7CiAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovCgoKICAgIF9fd2VicGFja19leHBvcnRzX19bImRlZmF1bHQiXSA9IHsKICAgICAgZnVuY3Rpb25hbDogdHJ1ZSwKICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoX2gsIF92bSkgewogICAgICAgIHZhciBfYyA9IF92bS5fYzsKICAgICAgICByZXR1cm4gX2MoJ3N2ZycsIHsKICAgICAgICAgICJjbGFzcyI6IFtfdm0uZGF0YVsiY2xhc3MiXSwgX3ZtLmRhdGEuc3RhdGljQ2xhc3NdLAogICAgICAgICAgc3R5bGU6IFtfdm0uZGF0YS5zdHlsZSwgX3ZtLmRhdGEuc3RhdGljU3R5bGVdLAogICAgICAgICAgYXR0cnM6IHsKICAgICAgICAgICAgInhtbG5zIjogImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiwKICAgICAgICAgICAgInZpZXdCb3giOiAiMCAwIDMyIDMyIgogICAgICAgICAgfQogICAgICAgIH0sIFtfYygncGF0aCcsIHsKICAgICAgICAgIGF0dHJzOiB7CiAgICAgICAgICAgICJkIjogIk0yMiAxNkwxMS44OTUgNS40IDEwIDcuMzg3IDE4LjIxMSAxNiAxMCAyNC42MTJsMS44OTUgMS45ODggOC4yMTEtOC42MTN6IgogICAgICAgICAgfQogICAgICAgIH0pXSk7CiAgICAgIH0KICAgIH07CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgImMzNjYiOgogIC8qKiovCiAgZnVuY3Rpb24gYzM2Nihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIC8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2YKICAgIC8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzCiAgICB2YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNjgyMSIpOwoKICAgIHZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oIjlkZWYiKTsKCiAgICB2YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNzdmMSIpOwoKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7CiAgICAgIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHsKICAgICAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7CiAgICAgICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTsKICAgICAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpOwogICAgICAgIHZhciB2YWx1ZTsgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobQogICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUKCiAgICAgICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHsKICAgICAgICAgIHZhbHVlID0gT1tpbmRleCsrXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZQoKICAgICAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7IC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3QKICAgICAgICB9IGVsc2UgZm9yICg7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7CiAgICAgICAgICBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgewogICAgICAgICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTsKICAgICAgfTsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICJjM2FiIjoKICAvKioqLwogIGZ1bmN0aW9uIGMzYWIobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7CgogICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pOwogICAgLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLwoKCiAgICBfX3dlYnBhY2tfZXhwb3J0c19fWyJkZWZhdWx0Il0gPSB7CiAgICAgIGZ1bmN0aW9uYWw6IHRydWUsCiAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKF9oLCBfdm0pIHsKICAgICAgICB2YXIgX2MgPSBfdm0uX2M7CiAgICAgICAgcmV0dXJuIF9jKCdzdmcnLCB7CiAgICAgICAgICAiY2xhc3MiOiBbX3ZtLmRhdGFbImNsYXNzIl0sIF92bS5kYXRhLnN0YXRpY0NsYXNzXSwKICAgICAgICAgIHN0eWxlOiBbX3ZtLmRhdGEuc3R5bGUsIF92bS5kYXRhLnN0YXRpY1N0eWxlXSwKICAgICAgICAgIGF0dHJzOiB7CiAgICAgICAgICAgICJ4bWxucyI6ICJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIsCiAgICAgICAgICAgICJ2aWV3Qm94IjogIjAgMCAyOSAzMiIKICAgICAgICAgIH0KICAgICAgICB9LCBbX2MoJ3BhdGgnLCB7CiAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAiZCI6ICJNMi42NjcgNy4wMjdsMS43MDctMS42OTMgMjIuMjkzIDIyLjI5My0xLjY5MyAxLjcwNy00LTRIOS4zMzR2NGwtNS4zMzMtNS4zMzMgNS4zMzMtNS4zMzN2NGg4Ljk3M2wtOC45NzMtOC45NzN2Ljk3M0g2LjY2N3YtMy42NGwtNC00em0yMCAxMC4zMDZoMi42Njd2NS41NzNsLTIuNjY3LTIuNjY3di0yLjkwN3ptMC0xMC42NjZ2LTRMMjggOGwtNS4zMzMgNS4zMzN2LTRIMTEuNzZMOS4wOTMgNi42NjZoMTMuNTczeiIKICAgICAgICAgIH0KICAgICAgICB9KV0pOwogICAgICB9CiAgICB9OwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICJjNWY2IjoKICAvKioqLwogIGZ1bmN0aW9uIGM1ZjYobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7CgogICAgdmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oIjc3MjYiKTsKCiAgICB2YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNjlhOCIpOwoKICAgIHZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyZDk1Iik7CgogICAgdmFyIGluaGVyaXRJZlJlcXVpcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNWRiYyIpOwoKICAgIHZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oIjZhOTkiKTsKCiAgICB2YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI3OWU1Iik7CgogICAgdmFyIGdPUE4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI5MDkzIikuZjsKCiAgICB2YXIgZ09QRCA9IF9fd2VicGFja19yZXF1aXJlX18oIjExZTkiKS5mOwoKICAgIHZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oIjg2Y2MiKS5mOwoKICAgIHZhciAkdHJpbSA9IF9fd2VicGFja19yZXF1aXJlX18oImFhNzciKS50cmltOwoKICAgIHZhciBOVU1CRVIgPSAnTnVtYmVyJzsKICAgIHZhciAkTnVtYmVyID0gZ2xvYmFsW05VTUJFUl07CiAgICB2YXIgQmFzZSA9ICROdW1iZXI7CiAgICB2YXIgcHJvdG8gPSAkTnVtYmVyLnByb3RvdHlwZTsgLy8gT3BlcmEgfjEyIGhhcyBicm9rZW4gT2JqZWN0I3RvU3RyaW5nCgogICAgdmFyIEJST0tFTl9DT0YgPSBjb2YoX193ZWJwYWNrX3JlcXVpcmVfXygiMmFlYiIpKHByb3RvKSkgPT0gTlVNQkVSOwogICAgdmFyIFRSSU0gPSAoJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGUpOyAvLyA3LjEuMyBUb051bWJlcihhcmd1bWVudCkKCiAgICB2YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcihhcmd1bWVudCkgewogICAgICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgZmFsc2UpOwoKICAgICAgaWYgKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKSB7CiAgICAgICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpOwogICAgICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMCk7CiAgICAgICAgdmFyIHRoaXJkLCByYWRpeCwgbWF4Q29kZTsKCiAgICAgICAgaWYgKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpIHsKICAgICAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTsKICAgICAgICAgIGlmICh0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMCkgcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeAogICAgICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09IDQ4KSB7CiAgICAgICAgICBzd2l0Y2ggKGl0LmNoYXJDb2RlQXQoMSkpIHsKICAgICAgICAgICAgY2FzZSA2NjoKICAgICAgICAgICAgY2FzZSA5ODoKICAgICAgICAgICAgICByYWRpeCA9IDI7CiAgICAgICAgICAgICAgbWF4Q29kZSA9IDQ5OwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAvLyBmYXN0IGVxdWFsIC9eMGJbMDFdKyQvaQoKICAgICAgICAgICAgY2FzZSA3OToKICAgICAgICAgICAgY2FzZSAxMTE6CiAgICAgICAgICAgICAgcmFkaXggPSA4OwogICAgICAgICAgICAgIG1heENvZGUgPSA1NTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgLy8gZmFzdCBlcXVhbCAvXjBvWzAtN10rJC9pCgogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIHJldHVybiAraXQ7CiAgICAgICAgICB9CgogICAgICAgICAgZm9yICh2YXIgZGlnaXRzID0gaXQuc2xpY2UoMiksIGkgPSAwLCBsID0gZGlnaXRzLmxlbmd0aCwgY29kZTsgaSA8IGw7IGkrKykgewogICAgICAgICAgICBjb2RlID0gZGlnaXRzLmNoYXJDb2RlQXQoaSk7IC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbAogICAgICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9scwoKICAgICAgICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSkgcmV0dXJuIE5hTjsKICAgICAgICAgIH0KCiAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gK2l0OwogICAgfTsKCiAgICBpZiAoISROdW1iZXIoJyAwbzEnKSB8fCAhJE51bWJlcignMGIxJykgfHwgJE51bWJlcignKzB4MScpKSB7CiAgICAgICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpIHsKICAgICAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZTsKICAgICAgICB2YXIgdGhhdCA9IHRoaXM7CiAgICAgICAgcmV0dXJuIHRoYXQgaW5zdGFuY2VvZiAkTnVtYmVyIC8vIGNoZWNrIG9uIDEuLmNvbnN0cnVjdG9yKGZvbykgY2FzZQogICAgICAgICYmIChCUk9LRU5fQ09GID8gZmFpbHMoZnVuY3Rpb24gKCkgewogICAgICAgICAgcHJvdG8udmFsdWVPZi5jYWxsKHRoYXQpOwogICAgICAgIH0pIDogY29mKHRoYXQpICE9IE5VTUJFUikgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSh0b051bWJlcihpdCkpLCB0aGF0LCAkTnVtYmVyKSA6IHRvTnVtYmVyKGl0KTsKICAgICAgfTsKCiAgICAgIGZvciAodmFyIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI5ZTFlIikgPyBnT1BOKEJhc2UpIDogKCAvLyBFUzM6CiAgICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICsgLy8gRVM2IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVM2IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6CiAgICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJykuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspIHsKICAgICAgICBpZiAoaGFzKEJhc2UsIGtleSA9IGtleXNbal0pICYmICFoYXMoJE51bWJlciwga2V5KSkgewogICAgICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgJE51bWJlci5wcm90b3R5cGUgPSBwcm90bzsKICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSAkTnVtYmVyOwoKICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXygiMmFiYSIpKGdsb2JhbCwgTlVNQkVSLCAkTnVtYmVyKTsKICAgIH0KICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgImM2OWEiOgogIC8qKiovCiAgZnVuY3Rpb24gYzY5YShtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIG1vZHVsZS5leHBvcnRzID0gIV9fd2VicGFja19yZXF1aXJlX18oIjllMWUiKSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXygiNzllNSIpKGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfcmVxdWlyZV9fKCIyMzBlIikoJ2RpdicpLCAnYScsIHsKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHJldHVybiA3OwogICAgICAgIH0KICAgICAgfSkuYSAhPSA3OwogICAgfSk7CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgImNhNWEiOgogIC8qKiovCiAgZnVuY3Rpb24gY2E1YShtb2R1bGUsIGV4cG9ydHMpIHsKICAgIHZhciBpZCA9IDA7CiAgICB2YXIgcHggPSBNYXRoLnJhbmRvbSgpOwoKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkgewogICAgICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpOwogICAgfTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgImNhZGYiOgogIC8qKiovCiAgZnVuY3Rpb24gY2FkZihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgICJ1c2Ugc3RyaWN0IjsKCiAgICB2YXIgYWRkVG9VbnNjb3BhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oIjljNmMiKTsKCiAgICB2YXIgc3RlcCA9IF9fd2VicGFja19yZXF1aXJlX18oImQ1M2IiKTsKCiAgICB2YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiODRmMiIpOwoKICAgIHZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI2ODIxIik7IC8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKCkKICAgIC8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpCiAgICAvLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpCiAgICAvLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKCkKCgogICAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIwMWY5IikoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkgewogICAgICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0CgogICAgICB0aGlzLl9pID0gMDsgLy8gbmV4dCBpbmRleAoKICAgICAgdGhpcy5fayA9IGtpbmQ7IC8vIGtpbmQKICAgICAgLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpCiAgICB9LCBmdW5jdGlvbiAoKSB7CiAgICAgIHZhciBPID0gdGhpcy5fdDsKICAgICAgdmFyIGtpbmQgPSB0aGlzLl9rOwogICAgICB2YXIgaW5kZXggPSB0aGlzLl9pKys7CgogICAgICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHsKICAgICAgICB0aGlzLl90ID0gdW5kZWZpbmVkOwogICAgICAgIHJldHVybiBzdGVwKDEpOwogICAgICB9CgogICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTsKICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTsKICAgICAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pOwogICAgfSwgJ3ZhbHVlcycpOyAvLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpCgogICAgSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTsKICAgIGFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTsKICAgIGFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpOwogICAgYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpOwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICJjYjdjIjoKICAvKioqLwogIGZ1bmN0aW9uIGNiN2MobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJkM2Y0Iik7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICAgICAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTsKICAgICAgcmV0dXJuIGl0OwogICAgfTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgImNkMWMiOgogIC8qKiovCiAgZnVuY3Rpb24gY2QxYyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIC8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aCkKICAgIHZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJlODUzIik7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwsIGxlbmd0aCkgewogICAgICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpOwogICAgfTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgImNlMTAiOgogIC8qKiovCiAgZnVuY3Rpb24gY2UxMChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIHZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI2OWE4Iik7CgogICAgdmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oIjY4MjEiKTsKCiAgICB2YXIgYXJyYXlJbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygiYzM2NiIpKGZhbHNlKTsKCiAgICB2YXIgSUVfUFJPVE8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI2MTNiIikoJ0lFX1BST1RPJyk7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykgewogICAgICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpOwogICAgICB2YXIgaSA9IDA7CiAgICAgIHZhciByZXN1bHQgPSBbXTsKICAgICAgdmFyIGtleTsKCiAgICAgIGZvciAoa2V5IGluIE8pIHsKICAgICAgICBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpOwogICAgICB9IC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXMKCgogICAgICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgewogICAgICAgIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHsKICAgICAgICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gcmVzdWx0OwogICAgfTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgImQyNjMiOgogIC8qKiovCiAgZnVuY3Rpb24gZDI2Myhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgICJ1c2Ugc3RyaWN0IjsgLy8gQi4yLjMuNiBTdHJpbmcucHJvdG90eXBlLmZpeGVkKCkKCiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKCIzODZiIikoJ2ZpeGVkJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHsKICAgICAgcmV0dXJuIGZ1bmN0aW9uIGZpeGVkKCkgewogICAgICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICd0dCcsICcnLCAnJyk7CiAgICAgIH07CiAgICB9KTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgImQyYzgiOgogIC8qKiovCiAgZnVuY3Rpb24gZDJjOChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIC8vIGhlbHBlciBmb3IgU3RyaW5nI3tzdGFydHNXaXRoLCBlbmRzV2l0aCwgaW5jbHVkZXN9CiAgICB2YXIgaXNSZWdFeHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJhYWUzIik7CgogICAgdmFyIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJiZTEzIik7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgc2VhcmNoU3RyaW5nLCBOQU1FKSB7CiAgICAgIGlmIChpc1JlZ0V4cChzZWFyY2hTdHJpbmcpKSB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZyMnICsgTkFNRSArICIgZG9lc24ndCBhY2NlcHQgcmVnZXghIik7CiAgICAgIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiZDNmNCI6CiAgLyoqKi8KICBmdW5jdGlvbiBkM2Y0KG1vZHVsZSwgZXhwb3J0cykgewogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICAgICAgcmV0dXJuIF90eXBlb2YzKGl0KSA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJzsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICJkNTNiIjoKICAvKioqLwogIGZ1bmN0aW9uIGQ1M2IobW9kdWxlLCBleHBvcnRzKSB7CiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkgewogICAgICByZXR1cm4gewogICAgICAgIHZhbHVlOiB2YWx1ZSwKICAgICAgICBkb25lOiAhIWRvbmUKICAgICAgfTsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICJkOGU4IjoKICAvKioqLwogIGZ1bmN0aW9uIGQ4ZTgobW9kdWxlLCBleHBvcnRzKSB7CiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogICAgICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7CiAgICAgIHJldHVybiBpdDsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICJkYWY4IjoKICAvKioqLwogIGZ1bmN0aW9uIGRhZjgobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7CgogICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pOwogICAgLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLwoKCiAgICBfX3dlYnBhY2tfZXhwb3J0c19fWyJkZWZhdWx0Il0gPSB7CiAgICAgIGZ1bmN0aW9uYWw6IHRydWUsCiAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKF9oLCBfdm0pIHsKICAgICAgICB2YXIgX2MgPSBfdm0uX2M7CiAgICAgICAgcmV0dXJuIF9jKCdzdmcnLCB7CiAgICAgICAgICAiY2xhc3MiOiBbX3ZtLmRhdGFbImNsYXNzIl0sIF92bS5kYXRhLnN0YXRpY0NsYXNzXSwKICAgICAgICAgIHN0eWxlOiBbX3ZtLmRhdGEuc3R5bGUsIF92bS5kYXRhLnN0YXRpY1N0eWxlXSwKICAgICAgICAgIGF0dHJzOiB7CiAgICAgICAgICAgICJ4bWxucyI6ICJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIsCiAgICAgICAgICAgICJ2aWV3Qm94IjogIjAgMCAxNyAzMiIKICAgICAgICAgIH0KICAgICAgICB9LCBbX2MoJ3BhdGgnLCB7CiAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAiZCI6ICJNMTQuMDggNC44cTIuODggMCAyLjg4IDIuMDQ4djE4LjI0cTAgMi4xMTItMi44OCAyLjExMnQtMi44OC0yLjExMlY2Ljg0OHEwLTIuMDQ4IDIuODgtMi4wNDh6bS0xMS4yIDBxMi44OCAwIDIuODggMi4wNDh2MTguMjRxMCAyLjExMi0yLjg4IDIuMTEyVDAgMjUuMDg4VjYuODQ4UTAgNC44IDIuODggNC44eiIKICAgICAgICAgIH0KICAgICAgICB9KV0pOwogICAgICB9CiAgICB9OwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICJkY2JjIjoKICAvKioqLwogIGZ1bmN0aW9uIGRjYmMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyYWJhIik7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHsKICAgICAgZm9yICh2YXIga2V5IGluIHNyYykgewogICAgICAgIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7CiAgICAgIH0KCiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiZTExZSI6CiAgLyoqKi8KICBmdW5jdGlvbiBlMTFlKG1vZHVsZSwgZXhwb3J0cykgewogICAgLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5cwogICAgbW9kdWxlLmV4cG9ydHMgPSAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJy5zcGxpdCgnLCcpOwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICJlODUzIjoKICAvKioqLwogIGZ1bmN0aW9uIGU4NTMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICB2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJkM2Y0Iik7CgogICAgdmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIxMTY5Iik7CgogICAgdmFyIFNQRUNJRVMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyYjRjIikoJ3NwZWNpZXMnKTsKCiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCkgewogICAgICB2YXIgQzsKCiAgICAgIGlmIChpc0FycmF5KG9yaWdpbmFsKSkgewogICAgICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjsgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2sKCiAgICAgICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDsKCiAgICAgICAgaWYgKGlzT2JqZWN0KEMpKSB7CiAgICAgICAgICBDID0gQ1tTUEVDSUVTXTsKICAgICAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQzsKICAgIH07CiAgICAvKioqLwoKICB9LAoKICAvKioqLwogICJlYmQ2IjoKICAvKioqLwogIGZ1bmN0aW9uIGViZDYobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcikKICAgIHZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oImNiN2MiKTsKCiAgICB2YXIgYUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygiZDhlOCIpOwoKICAgIHZhciBTUEVDSUVTID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMmI0YyIpKCdzcGVjaWVzJyk7CgogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgRCkgewogICAgICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yOwogICAgICB2YXIgUzsKICAgICAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpOwogICAgfTsKICAgIC8qKiovCgogIH0sCgogIC8qKiovCiAgImY1NTkiOgogIC8qKiovCiAgZnVuY3Rpb24gZjU1OShtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgICJ1c2Ugc3RyaWN0IjsgLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSkKCiAgICB2YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oIjVjYTEiKTsKCiAgICB2YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI5ZGVmIik7CgogICAgdmFyIGNvbnRleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJkMmM4Iik7CgogICAgdmFyIFNUQVJUU19XSVRIID0gJ3N0YXJ0c1dpdGgnOwogICAgdmFyICRzdGFydHNXaXRoID0gJydbU1RBUlRTX1dJVEhdOwogICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBfX3dlYnBhY2tfcmVxdWlyZV9fKCI1MTQ3IikoU1RBUlRTX1dJVEgpLCAnU3RyaW5nJywgewogICAgICBzdGFydHNXaXRoOiBmdW5jdGlvbiBzdGFydHNXaXRoKHNlYXJjaFN0cmluZwogICAgICAvKiAsIHBvc2l0aW9uID0gMCAqLwogICAgICApIHsKICAgICAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBTVEFSVFNfV0lUSCk7CiAgICAgICAgdmFyIGluZGV4ID0gdG9MZW5ndGgoTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSk7CiAgICAgICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpOwogICAgICAgIHJldHVybiAkc3RhcnRzV2l0aCA/ICRzdGFydHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBpbmRleCkgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7CiAgICAgIH0KICAgIH0pOwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICJmNTc2IjoKICAvKioqLwogIGZ1bmN0aW9uIGY1NzYobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7CiAgICAidXNlIHN0cmljdCI7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kCgogICAgdmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI1Y2ExIik7CgogICAgdmFyICRwYWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyZTA4Iik7CgogICAgdmFyIHVzZXJBZ2VudCA9IF9fd2VicGFja19yZXF1aXJlX18oImEyNWYiKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzI4MAoKCiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIC9WZXJzaW9uXC8xMFwuXGQrKFwuXGQrKT8gU2FmYXJpXC8vLnRlc3QodXNlckFnZW50KSwgJ1N0cmluZycsIHsKICAgICAgcGFkU3RhcnQ6IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aAogICAgICAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi8KICAgICAgKSB7CiAgICAgICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdHJ1ZSk7CiAgICAgIH0KICAgIH0pOwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICJmNjA1IjoKICAvKioqLwogIGZ1bmN0aW9uIGY2MDUobW9kdWxlLCBleHBvcnRzKSB7CiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7CiAgICAgIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpIHsKICAgICAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpOwogICAgICB9CgogICAgICByZXR1cm4gaXQ7CiAgICB9OwogICAgLyoqKi8KCiAgfSwKCiAgLyoqKi8KICAiZjc1MSI6CiAgLyoqKi8KICBmdW5jdGlvbiBmNzUxKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSkKICAgIHZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNWNhMSIpOwoKICAgICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgewogICAgICBhc3NpZ246IF9fd2VicGFja19yZXF1aXJlX18oIjczMzMiKQogICAgfSk7CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgImY4NjYiOgogIC8qKiovCiAgZnVuY3Rpb24gZjg2Nihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgICJ1c2Ugc3RyaWN0IjsKCiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7CiAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovCgoKICAgIF9fd2VicGFja19leHBvcnRzX19bImRlZmF1bHQiXSA9IHsKICAgICAgZnVuY3Rpb25hbDogdHJ1ZSwKICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoX2gsIF92bSkgewogICAgICAgIHZhciBfYyA9IF92bS5fYzsKICAgICAgICByZXR1cm4gX2MoJ3N2ZycsIHsKICAgICAgICAgICJjbGFzcyI6IFtfdm0uZGF0YVsiY2xhc3MiXSwgX3ZtLmRhdGEuc3RhdGljQ2xhc3NdLAogICAgICAgICAgc3R5bGU6IFtfdm0uZGF0YS5zdHlsZSwgX3ZtLmRhdGEuc3RhdGljU3R5bGVdLAogICAgICAgICAgYXR0cnM6IHsKICAgICAgICAgICAgInhtbG5zIjogImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiwKICAgICAgICAgICAgInZpZXdCb3giOiAiMCAwIDI5IDMyIgogICAgICAgICAgfQogICAgICAgIH0sIFtfYygncGF0aCcsIHsKICAgICAgICAgIGF0dHJzOiB7CiAgICAgICAgICAgICJkIjogIk05LjMzMyA5LjMzM2gxMy4zMzN2NEwyNy45OTkgOGwtNS4zMzMtNS4zMzN2NGgtMTZ2OGgyLjY2N1Y5LjMzNHptMTMuMzM0IDEzLjMzNEg5LjMzNHYtNEw0LjAwMSAyNGw1LjMzMyA1LjMzM3YtNGgxNnYtOGgtMi42Njd2NS4zMzN6IgogICAgICAgICAgfQogICAgICAgIH0pXSk7CiAgICAgIH0KICAgIH07CiAgICAvKioqLwogIH0sCgogIC8qKiovCiAgImZhYjIiOgogIC8qKiovCiAgZnVuY3Rpb24gZmFiMihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsKICAgIHZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oIjc3MjYiKS5kb2N1bWVudDsKCiAgICBtb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsKICAgIC8qKiovCiAgfSwKCiAgLyoqKi8KICAiZmIxNSI6CiAgLyoqKi8KICBmdW5jdGlvbiBmYjE1KG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgewogICAgInVzZSBzdHJpY3QiOwoKICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTsgLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHZ1ZS9jbGktc2VydmljZS9saWIvY29tbWFuZHMvYnVpbGQvc2V0UHVibGljUGF0aC5qcwogICAgLy8gVGhpcyBmaWxlIGlzIGltcG9ydGVkIGludG8gbGliL3djIGNsaWVudCBidW5kbGVzLgoKCiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgdmFyIHNldFB1YmxpY1BhdGhfaTsKCiAgICAgIGlmICgoc2V0UHVibGljUGF0aF9pID0gd2luZG93LmRvY3VtZW50LmN1cnJlbnRTY3JpcHQpICYmIChzZXRQdWJsaWNQYXRoX2kgPSBzZXRQdWJsaWNQYXRoX2kuc3JjLm1hdGNoKC8oLitcLylbXi9dK1wuanMoXD8uKik/JC8pKSkgewogICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucCA9IHNldFB1YmxpY1BhdGhfaVsxXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZQogICAgICB9CiAgICB9IC8vIEluZGljYXRlIHRvIHdlYnBhY2sgdGhhdCB0aGlzIGZpbGUgY2FuIGJlIGNvbmNhdGVuYXRlZAoKICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8KCgogICAgdmFyIHNldFB1YmxpY1BhdGggPSBudWxsOyAvLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcwoKICAgIHZhciBlczZfb2JqZWN0X2Fzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oImY3NTEiKTsgLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanMKCgogICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgewogICAgICBpZiAoa2V5IGluIG9iaikgewogICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgewogICAgICAgICAgdmFsdWU6IHZhbHVlLAogICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgICAgICAgIHdyaXRhYmxlOiB0cnVlCiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTsKICAgICAgfQoKICAgICAgcmV0dXJuIG9iajsKICAgIH0gLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0U3ByZWFkLmpzCgoKICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7CiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307CiAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOwoKICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsKICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7CiAgICAgICAgICB9KSk7CiAgICAgICAgfQoKICAgICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgewogICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7CiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9IC8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanMKCgogICAgdmFyIGVzNl9udW1iZXJfY29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJjNWY2Iik7IC8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanMKCgogICAgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgewogICAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsKICAgICAgdmFyIHRhcmdldCA9IHt9OwogICAgICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7CiAgICAgIHZhciBrZXksIGk7CgogICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgewogICAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07CiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsKICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOwogICAgICB9CgogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfSAvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllcy5qcwoKCiAgICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgewogICAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsKCiAgICAgIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsKCiAgICAgIHZhciBrZXksIGk7CgogICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgewogICAgICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOwoKICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgewogICAgICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsKICAgICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7CiAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOwogICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9IC8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aG91dEhvbGVzLmpzCgoKICAgIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsKICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgewogICAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBhcnIyW2ldID0gYXJyW2ldOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIGFycjI7CiAgICAgIH0KICAgIH0gLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5LmpzCgoKICAgIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgewogICAgICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09ICJbb2JqZWN0IEFyZ3VtZW50c10iKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsKICAgIH0gLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWQuanMKCgogICAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgewogICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZSIpOwogICAgfSAvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheS5qcwoKCiAgICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7CiAgICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7CiAgICB9IC8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMKCgogICAgdmFyIHdlYl9kb21faXRlcmFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJhYzZhIik7IC8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzCgoKICAgIHZhciBlczZfcHJvbWlzZSA9IF9fd2VicGFja19yZXF1aXJlX18oIjU1MWMiKTsgLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzCgoKICAgIHZhciBlczdfYXJyYXlfaW5jbHVkZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI2NzYyIik7IC8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMKCgogICAgdmFyIGVzNl9zdHJpbmdfaW5jbHVkZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCIyZmRiIik7IC8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzCgoKICAgIHZhciBlczZfZnVuY3Rpb25fbmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oIjdmN2YiKTsgLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQuanMKCgogICAgdmFyIGVzNl9hcnJheV9maW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNzUxNCIpOyAvLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qcwoKCiAgICB2YXIgZXM2X3JlZ2V4cF90b19zdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI2YjU0Iik7IC8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aEhvbGVzLmpzCgoKICAgIGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsKICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsKICAgIH0gLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5TGltaXQuanMKCgogICAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgewogICAgICB2YXIgX2FyciA9IFtdOwogICAgICB2YXIgX24gPSB0cnVlOwogICAgICB2YXIgX2QgPSBmYWxzZTsKICAgICAgdmFyIF9lID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7CiAgICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpOwoKICAgICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kID0gdHJ1ZTsKICAgICAgICBfZSA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfbiAmJiBfaVsicmV0dXJuIl0gIT0gbnVsbCkgX2lbInJldHVybiJdKCk7CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZCkgdGhyb3cgX2U7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gX2FycjsKICAgIH0gLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzCgoKICAgIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7CiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UiKTsKICAgIH0gLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcwoKCiAgICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsKICAgICAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsKICAgIH0gLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMKCgogICAgdmFyIGVzNl9hcnJheV9maW5kX2luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMjBkNiIpOyAvLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcwoKCiAgICB2YXIgcnVudGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oIjk2Y2YiKTsgLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvci5qcwoKCiAgICBmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7CiAgICAgIHRyeSB7CiAgICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOwogICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7CiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgcmVqZWN0KGVycm9yKTsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGlmIChpbmZvLmRvbmUpIHsKICAgICAgICByZXNvbHZlKHZhbHVlKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7CiAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgewogICAgICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgICAgIHZhciBzZWxmID0gdGhpcywKICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50czsKICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOwoKICAgICAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7CiAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgIm5leHQiLCB2YWx1ZSk7CiAgICAgICAgICB9CgogICAgICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikgewogICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csICJ0aHJvdyIsIGVycik7CiAgICAgICAgICB9CgogICAgICAgICAgX25leHQodW5kZWZpbmVkKTsKICAgICAgICB9KTsKICAgICAgfTsKICAgIH0gLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qcwoKCiAgICB2YXIgZXM2X3N0cmluZ19maXhlZCA9IF9fd2VicGFja19yZXF1aXJlX18oImQyNjMiKTsgLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanMKCgogICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgewogICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpOwogICAgICB9CiAgICB9IC8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzCgoKICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07CiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOwogICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsKICAgICAgICBpZiAoInZhbHVlIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7CiAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7CiAgICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOwogICAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7CiAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjsKICAgIH0gLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzCgoKICAgIGZ1bmN0aW9uIF90eXBlb2YyKG9iaikgewogICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gImZ1bmN0aW9uIiAmJiBfdHlwZW9mMyhTeW1ib2wuaXRlcmF0b3IpID09PSAic3ltYm9sIikgewogICAgICAgIF90eXBlb2YyID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7CiAgICAgICAgICByZXR1cm4gX3R5cGVvZjMob2JqKTsKICAgICAgICB9OwogICAgICB9IGVsc2UgewogICAgICAgIF90eXBlb2YyID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7CiAgICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09ICJmdW5jdGlvbiIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gInN5bWJvbCIgOiBfdHlwZW9mMyhvYmopOwogICAgICAgIH07CiAgICAgIH0KCiAgICAgIHJldHVybiBfdHlwZW9mMihvYmopOwogICAgfQoKICAgIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7CiAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAiZnVuY3Rpb24iICYmIF90eXBlb2YyKFN5bWJvbC5pdGVyYXRvcikgPT09ICJzeW1ib2wiKSB7CiAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7CiAgICAgICAgICByZXR1cm4gX3R5cGVvZjIob2JqKTsKICAgICAgICB9OwogICAgICB9IGVsc2UgewogICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgewogICAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSAiZnVuY3Rpb24iICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/ICJzeW1ib2wiIDogX3R5cGVvZjIob2JqKTsKICAgICAgICB9OwogICAgICB9CgogICAgICByZXR1cm4gX3R5cGVvZihvYmopOwogICAgfSAvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMKCgogICAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7CiAgICAgIGlmIChzZWxmID09PSB2b2lkIDApIHsKICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZCIpOwogICAgICB9CgogICAgICByZXR1cm4gc2VsZjsKICAgIH0gLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcwoKCiAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7CiAgICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSAib2JqZWN0IiB8fCB0eXBlb2YgY2FsbCA9PT0gImZ1bmN0aW9uIikpIHsKICAgICAgICByZXR1cm4gY2FsbDsKICAgICAgfQoKICAgICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7CiAgICB9IC8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mLmpzCgoKICAgIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7CiAgICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7CiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsKICAgICAgfTsKICAgICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsKICAgIH0gLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2V0UHJvdG90eXBlT2YuanMKCgogICAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsKICAgICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7CiAgICAgICAgby5fX3Byb3RvX18gPSBwOwogICAgICAgIHJldHVybiBvOwogICAgICB9OwoKICAgICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsKICAgIH0gLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMuanMKCgogICAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7CiAgICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gImZ1bmN0aW9uIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iKTsKICAgICAgfQoKICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7CiAgICAgICAgY29uc3RydWN0b3I6IHsKICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcywKICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgfQogICAgICB9KTsKICAgICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7CiAgICB9IC8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXRzeC1zdXBwb3J0L2xpYi9pbmRleC5qcwoKCiAgICB2YXIgbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNDhkMyIpOyAvLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1jbGFzcy1jb21wb25lbnQvZGlzdC92dWUtY2xhc3MtY29tcG9uZW50LmNvbW1vbi5qcwoKCiAgICB2YXIgdnVlX2NsYXNzX2NvbXBvbmVudF9jb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI2NWQ5Iik7CgogICAgdmFyIHZ1ZV9jbGFzc19jb21wb25lbnRfY29tbW9uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZ1ZV9jbGFzc19jb21wb25lbnRfY29tbW9uKTsgLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7ImNvbW1vbmpzIjoidnVlIiwiY29tbW9uanMyIjoidnVlIiwicm9vdCI6IlZ1ZSJ9CgoKICAgIHZhciBleHRlcm5hbF9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9yb290X1Z1ZV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCI4YmJmIik7CgogICAgdmFyIGV4dGVybmFsX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX3Jvb3RfVnVlX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGV4dGVybmFsX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX3Jvb3RfVnVlXyk7IC8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1wcm9wZXJ0eS1kZWNvcmF0b3IvbGliL3Z1ZS1wcm9wZXJ0eS1kZWNvcmF0b3IuanMKCiAgICAvKiogdnVlLXByb3BlcnR5LWRlY29yYXRvciB2ZXJzb24gNy4yLjAgTUlUIExJQ0VOU0UgY29weXJpZ2h0IDIwMTgga2FvcnVuMzQzICovCgogICAgLyoqCiAgICAgKiBkZWNvcmF0b3Igb2YgYW4gaW5qZWN0CiAgICAgKiBAcGFyYW0gZnJvbSBrZXkKICAgICAqIEByZXR1cm4gUHJvcGVydHlEZWNvcmF0b3IKICAgICAqLwoKCiAgICBmdW5jdGlvbiBJbmplY3Qob3B0aW9ucykgewogICAgICByZXR1cm4gT2JqZWN0KHZ1ZV9jbGFzc19jb21wb25lbnRfY29tbW9uWyJjcmVhdGVEZWNvcmF0b3IiXSkoZnVuY3Rpb24gKGNvbXBvbmVudE9wdGlvbnMsIGtleSkgewogICAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50T3B0aW9ucy5pbmplY3QgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICBjb21wb25lbnRPcHRpb25zLmluamVjdCA9IHt9OwogICAgICAgIH0KCiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbXBvbmVudE9wdGlvbnMuaW5qZWN0KSkgewogICAgICAgICAgY29tcG9uZW50T3B0aW9ucy5pbmplY3Rba2V5XSA9IG9wdGlvbnMgfHwga2V5OwogICAgICAgIH0KICAgICAgfSk7CiAgICB9CiAgICAvKioKICAgICAqIGRlY29yYXRvciBvZiBhIHByb3ZpZGUKICAgICAqIEBwYXJhbSBrZXkga2V5CiAgICAgKiBAcmV0dXJuIFByb3BlcnR5RGVjb3JhdG9yIHwgdm9pZAogICAgICovCgoKICAgIGZ1bmN0aW9uIFByb3ZpZGUoa2V5KSB7CiAgICAgIHJldHVybiBPYmplY3QodnVlX2NsYXNzX2NvbXBvbmVudF9jb21tb25bImNyZWF0ZURlY29yYXRvciJdKShmdW5jdGlvbiAoY29tcG9uZW50T3B0aW9ucywgaykgewogICAgICAgIHZhciBwcm92aWRlID0gY29tcG9uZW50T3B0aW9ucy5wcm92aWRlOwoKICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGUgIT09ICdmdW5jdGlvbicgfHwgIXByb3ZpZGUubWFuYWdlZCkgewogICAgICAgICAgdmFyIG9yaWdpbmFsXzEgPSBjb21wb25lbnRPcHRpb25zLnByb3ZpZGU7CgogICAgICAgICAgcHJvdmlkZSA9IGNvbXBvbmVudE9wdGlvbnMucHJvdmlkZSA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgdmFyIHJ2ID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIG9yaWdpbmFsXzEgPT09ICdmdW5jdGlvbicgPyBvcmlnaW5hbF8xLmNhbGwodGhpcykgOiBvcmlnaW5hbF8xKSB8fCBudWxsKTsKCiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gcHJvdmlkZS5tYW5hZ2VkKSB7CiAgICAgICAgICAgICAgcnZbcHJvdmlkZS5tYW5hZ2VkW2ldXSA9IHRoaXNbaV07CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHJldHVybiBydjsKICAgICAgICAgIH07CgogICAgICAgICAgcHJvdmlkZS5tYW5hZ2VkID0ge307CiAgICAgICAgfQoKICAgICAgICBwcm92aWRlLm1hbmFnZWRba10gPSBrZXkgfHwgazsKICAgICAgfSk7CiAgICB9CiAgICAvKioKICAgICAqIGRlY29yYXRvciBvZiBtb2RlbAogICAgICogQHBhcmFtICBldmVudCBldmVudCBuYW1lCiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zCiAgICAgKiBAcmV0dXJuIFByb3BlcnR5RGVjb3JhdG9yCiAgICAgKi8KCgogICAgZnVuY3Rpb24gTW9kZWwoZXZlbnQsIG9wdGlvbnMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgcmV0dXJuIE9iamVjdCh2dWVfY2xhc3NfY29tcG9uZW50X2NvbW1vblsiY3JlYXRlRGVjb3JhdG9yIl0pKGZ1bmN0aW9uIChjb21wb25lbnRPcHRpb25zLCBrKSB7CiAgICAgICAgKGNvbXBvbmVudE9wdGlvbnMucHJvcHMgfHwgKGNvbXBvbmVudE9wdGlvbnMucHJvcHMgPSB7fSkpW2tdID0gb3B0aW9uczsKICAgICAgICBjb21wb25lbnRPcHRpb25zLm1vZGVsID0gewogICAgICAgICAgcHJvcDogaywKICAgICAgICAgIGV2ZW50OiBldmVudCB8fCBrCiAgICAgICAgfTsKICAgICAgfSk7CiAgICB9CiAgICAvKioKICAgICAqIGRlY29yYXRvciBvZiBhIHByb3AKICAgICAqIEBwYXJhbSAgb3B0aW9ucyB0aGUgb3B0aW9ucyBmb3IgdGhlIHByb3AKICAgICAqIEByZXR1cm4gUHJvcGVydHlEZWNvcmF0b3IgfCB2b2lkCiAgICAgKi8KCgogICAgZnVuY3Rpb24gUHJvcChvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIHJldHVybiBPYmplY3QodnVlX2NsYXNzX2NvbXBvbmVudF9jb21tb25bImNyZWF0ZURlY29yYXRvciJdKShmdW5jdGlvbiAoY29tcG9uZW50T3B0aW9ucywgaykgewogICAgICAgIChjb21wb25lbnRPcHRpb25zLnByb3BzIHx8IChjb21wb25lbnRPcHRpb25zLnByb3BzID0ge30pKVtrXSA9IG9wdGlvbnM7CiAgICAgIH0pOwogICAgfQogICAgLyoqCiAgICAgKiBkZWNvcmF0b3Igb2YgYSB3YXRjaCBmdW5jdGlvbgogICAgICogQHBhcmFtICBwYXRoIHRoZSBwYXRoIG9yIHRoZSBleHByZXNzaW9uIHRvIG9ic2VydmUKICAgICAqIEBwYXJhbSAgV2F0Y2hPcHRpb24KICAgICAqIEByZXR1cm4gTWV0aG9kRGVjb3JhdG9yCiAgICAgKi8KCgogICAgZnVuY3Rpb24gV2F0Y2gocGF0aCwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICB2YXIgX2EgPSBvcHRpb25zLmRlZXAsCiAgICAgICAgICBkZWVwID0gX2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX2EsCiAgICAgICAgICBfYiA9IG9wdGlvbnMuaW1tZWRpYXRlLAogICAgICAgICAgaW1tZWRpYXRlID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7CiAgICAgIHJldHVybiBPYmplY3QodnVlX2NsYXNzX2NvbXBvbmVudF9jb21tb25bImNyZWF0ZURlY29yYXRvciJdKShmdW5jdGlvbiAoY29tcG9uZW50T3B0aW9ucywgaGFuZGxlcikgewogICAgICAgIGlmIChfdHlwZW9mMyhjb21wb25lbnRPcHRpb25zLndhdGNoKSAhPT0gJ29iamVjdCcpIHsKICAgICAgICAgIGNvbXBvbmVudE9wdGlvbnMud2F0Y2ggPSBPYmplY3QuY3JlYXRlKG51bGwpOwogICAgICAgIH0KCiAgICAgICAgY29tcG9uZW50T3B0aW9ucy53YXRjaFtwYXRoXSA9IHsKICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsCiAgICAgICAgICBkZWVwOiBkZWVwLAogICAgICAgICAgaW1tZWRpYXRlOiBpbW1lZGlhdGUKICAgICAgICB9OwogICAgICB9KTsKICAgIH0gLy8gQ29kZSBjb3BpZWQgZnJvbSBWdWUvc3JjL3NoYXJlZC91dGlsLmpzCgoKICAgIHZhciBoeXBoZW5hdGVSRSA9IC9cQihbQS1aXSkvZzsKCiAgICB2YXIgaHlwaGVuYXRlID0gZnVuY3Rpb24gaHlwaGVuYXRlKHN0cikgewogICAgICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpOwogICAgfTsKICAgIC8qKgogICAgICogZGVjb3JhdG9yIG9mIGFuIGV2ZW50LWVtaXR0ZXIgZnVuY3Rpb24KICAgICAqIEBwYXJhbSAgZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50CiAgICAgKiBAcmV0dXJuIE1ldGhvZERlY29yYXRvcgogICAgICovCgoKICAgIGZ1bmN0aW9uIEVtaXQoZXZlbnQpIHsKICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfdGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHsKICAgICAgICBrZXkgPSBoeXBoZW5hdGUoa2V5KTsKICAgICAgICB2YXIgb3JpZ2luYWwgPSBkZXNjcmlwdG9yLnZhbHVlOwoKICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gZW1pdHRlcigpIHsKICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7CgogICAgICAgICAgdmFyIGFyZ3MgPSBbXTsKCiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykgewogICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07CiAgICAgICAgICB9CgogICAgICAgICAgdmFyIGVtaXQgPSBmdW5jdGlvbiBlbWl0KHJldHVyblZhbHVlKSB7CiAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSAhPT0gdW5kZWZpbmVkKSBhcmdzLnVuc2hpZnQocmV0dXJuVmFsdWUpOwoKICAgICAgICAgICAgX3RoaXMuJGVtaXQuYXBwbHkoX3RoaXMsIFtldmVudCB8fCBrZXldLmNvbmNhdChhcmdzKSk7CiAgICAgICAgICB9OwoKICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpOwoKICAgICAgICAgIGlmIChpc1Byb21pc2UocmV0dXJuVmFsdWUpKSB7CiAgICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4oZnVuY3Rpb24gKHJldHVyblZhbHVlKSB7CiAgICAgICAgICAgICAgZW1pdChyZXR1cm5WYWx1ZSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZW1pdChyZXR1cm5WYWx1ZSk7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgfTsKICAgIH0KCiAgICBmdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7CiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBQcm9taXNlIHx8IG9iaiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbic7CiAgICB9IC8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcwoKCiAgICB2YXIgY2xhc3NuYW1lcyA9IF9fd2VicGFja19yZXF1aXJlX18oIjRkMjYiKTsKCiAgICB2YXIgY2xhc3NuYW1lc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjbGFzc25hbWVzKTsgLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzCgoKICAgIHZhciBlczZfYXJyYXlfaXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJjYWRmIik7IC8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcwoKCiAgICB2YXIgZXM2X29iamVjdF9rZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNDU2ZCIpOyAvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3V0aWxzL2luZGV4LnRzCgoKICAgIGZ1bmN0aW9uIHNsZWVwKCkgewogICAgICB2YXIgZGVsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7CiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgewogICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KTsKICAgICAgfSk7CiAgICB9CgogICAgZnVuY3Rpb24gZXZlbnRMb29wKHRhcmdldCkgewogICAgICB2YXIgdGltZW91dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMzAwMDsKICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsKICAgICAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7CiAgICAgICAgdmFyIHRpbWVySWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7CiAgICAgICAgICBpZiAoIXRhcmdldCgpKSB7CiAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gMCAmJiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZSA+IHRpbWVvdXQpIHsKICAgICAgICAgICAgICByZWplY3QoKTsKICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVySWQpOwogICAgICAgICAgICB9CgogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CgogICAgICAgICAgcmVzb2x2ZSgpOwogICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcklkKTsKICAgICAgICB9LCAxMDApOwogICAgICB9KTsKICAgIH0gLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9AbW9lZmUvdnVlLWF1ZGlvL2V2ZW50cy50cwoKICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8KCgogICAgdmFyIGV2ZW50cyA9IFsnYWJvcnQnLCAnY2FucGxheScsICdjYW5wbGF5dGhyb3VnaCcsICdkdXJhdGlvbmNoYW5nZScsICdlbXB0aWVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2xvYWRlZGRhdGEnLCAnbG9hZGVkbWV0YWRhdGEnLCAnbG9hZHN0YXJ0JywgJ3BhdXNlJywgJ3BsYXknLCAncGxheWluZycsICdwcm9ncmVzcycsICdyYXRlY2hhbmdlJywgJ3JlYWR5c3RhdGVjaGFuZ2UnLCAnc2Vla2VkJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdXNwZW5kJywgJ3RpbWV1cGRhdGUnLCAndm9sdW1lY2hhbmdlJywgJ3dhaXRpbmcnXTsgLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9AbW9lZmUvdnVlLWF1ZGlvL2luZGV4LnRzCgogICAgdmFyIF9fZGVjb3JhdGUgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7CiAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwKICAgICAgICAgIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLAogICAgICAgICAgZDsKICAgICAgaWYgKCh0eXBlb2YgUmVmbGVjdCA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2YoUmVmbGVjdCkpID09PSAib2JqZWN0IiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gImZ1bmN0aW9uIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO2Vsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByOwogICAgICB9CiAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7CiAgICB9OwoKICAgIHZhciBfX21ldGFkYXRhID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX21ldGFkYXRhIHx8IGZ1bmN0aW9uIChrLCB2KSB7CiAgICAgIGlmICgodHlwZW9mIFJlZmxlY3QgPT09ICJ1bmRlZmluZWQiID8gInVuZGVmaW5lZCIgOiBfdHlwZW9mKFJlZmxlY3QpKSA9PT0gIm9iamVjdCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09ICJmdW5jdGlvbiIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpOwogICAgfTsKCiAgICB2YXIgUmVhZHlTdGF0ZTsKCiAgICAoZnVuY3Rpb24gKFJlYWR5U3RhdGUpIHsKICAgICAgLyoqIOayoeacieWFs+S6jumfs+mikeaYr+WQpuWwsee7queahOS/oeaBryAqLwogICAgICBSZWFkeVN0YXRlW1JlYWR5U3RhdGVbIkhBVkVfTk9USElORyJdID0gMF0gPSAiSEFWRV9OT1RISU5HIjsKICAgICAgLyoqIOWFs+S6jumfs+mikeWwsee7queahOWFg+aVsOaNriAqLwoKICAgICAgUmVhZHlTdGF0ZVtSZWFkeVN0YXRlWyJIQVZFX01FVEFEQVRBIl0gPSAxXSA9ICJIQVZFX01FVEFEQVRBIjsKICAgICAgLyoqIOWFs+S6juW9k+WJjeaSreaUvuS9jee9rueahOaVsOaNruaYr+WPr+eUqOeahO+8jOS9huayoeaciei2s+Wkn+eahOaVsOaNruadpeaSreaUvuS4i+S4gOW4py/mr6vnp5IgKi8KCiAgICAgIFJlYWR5U3RhdGVbUmVhZHlTdGF0ZVsiSEFWRV9DVVJSRU5UX0RBVEEiXSA9IDJdID0gIkhBVkVfQ1VSUkVOVF9EQVRBIjsKICAgICAgLyoqIOW9k+WJjeWPiuiHs+WwkeS4i+S4gOW4p+eahOaVsOaNruaYr+WPr+eUqOeahCAqLwoKICAgICAgUmVhZHlTdGF0ZVtSZWFkeVN0YXRlWyJIQVZFX0ZVVFVSRV9EQVRBIl0gPSAzXSA9ICJIQVZFX0ZVVFVSRV9EQVRBIjsKICAgICAgLyoqIOWPr+eUqOaVsOaNrui2s+S7peW8gOWni+aSreaUviAqLwoKICAgICAgUmVhZHlTdGF0ZVtSZWFkeVN0YXRlWyJIQVZFX0VOT1VHSF9EQVRBIl0gPSA0XSA9ICJIQVZFX0VOT1VHSF9EQVRBIjsKICAgIH0pKFJlYWR5U3RhdGUgfHwgKFJlYWR5U3RhdGUgPSB7fSkpOwoKICAgIHZhciB2dWVfYXVkaW9fVnVlQXVkaW8gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9WdWUpIHsKICAgICAgX2luaGVyaXRzKFZ1ZUF1ZGlvLCBfVnVlKTsKCiAgICAgIGZ1bmN0aW9uIFZ1ZUF1ZGlvKCkgewogICAgICAgIHZhciBfdGhpczsKCiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZ1ZUF1ZGlvKTsKCiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoVnVlQXVkaW8pLmNhbGwodGhpcykpOwogICAgICAgIF90aGlzLmF1ZGlvID0gbmV3IEF1ZGlvKCk7CiAgICAgICAgX3RoaXMuYXVkaW9UcmFja3MgPSBfdGhpcy5hdWRpby5hdWRpb1RyYWNrczsKICAgICAgICBfdGhpcy5hdXRvcGxheSA9IF90aGlzLmF1ZGlvLmF1dG9wbGF5OwogICAgICAgIF90aGlzLmJ1ZmZlcmVkID0gX3RoaXMuYXVkaW8uYnVmZmVyZWQ7CiAgICAgICAgX3RoaXMuY29udHJvbHMgPSBfdGhpcy5hdWRpby5jb250cm9sczsKICAgICAgICBfdGhpcy5jcm9zc09yaWdpbiA9IF90aGlzLmF1ZGlvLmNyb3NzT3JpZ2luOwogICAgICAgIF90aGlzLmN1cnJlbnRTcmMgPSBfdGhpcy5hdWRpby5jdXJyZW50U3JjOwogICAgICAgIF90aGlzLmN1cnJlbnRUaW1lID0gX3RoaXMuYXVkaW8uY3VycmVudFRpbWU7CiAgICAgICAgX3RoaXMuZGVmYXVsdE11dGVkID0gX3RoaXMuYXVkaW8uZGVmYXVsdE11dGVkOwogICAgICAgIF90aGlzLmRlZmF1bHRQbGF5YmFja1JhdGUgPSBfdGhpcy5hdWRpby5kZWZhdWx0UGxheWJhY2tSYXRlOwogICAgICAgIF90aGlzLmR1cmF0aW9uID0gX3RoaXMuYXVkaW8uZHVyYXRpb247CiAgICAgICAgX3RoaXMuZW5kZWQgPSBfdGhpcy5hdWRpby5lbmRlZDsKICAgICAgICBfdGhpcy5lcnJvciA9IF90aGlzLmF1ZGlvLmVycm9yOwogICAgICAgIF90aGlzLmxvb3AgPSBfdGhpcy5hdWRpby5sb29wOwogICAgICAgIF90aGlzLm1lZGlhS2V5cyA9IF90aGlzLmF1ZGlvLm1lZGlhS2V5czsKICAgICAgICBfdGhpcy5tdXRlZCA9IF90aGlzLmF1ZGlvLm11dGVkOwogICAgICAgIF90aGlzLm5ldHdvcmtTdGF0ZSA9IF90aGlzLmF1ZGlvLm5ldHdvcmtTdGF0ZTsKICAgICAgICBfdGhpcy5wYXVzZWQgPSBfdGhpcy5hdWRpby5wYXVzZWQ7CiAgICAgICAgX3RoaXMucGxheWJhY2tSYXRlID0gX3RoaXMuYXVkaW8ucGxheWJhY2tSYXRlOwogICAgICAgIF90aGlzLnBsYXllZCA9IF90aGlzLmF1ZGlvLnBsYXllZDsKICAgICAgICBfdGhpcy5wcmVsb2FkID0gX3RoaXMuYXVkaW8ucHJlbG9hZDsKICAgICAgICBfdGhpcy5yZWFkeVN0YXRlID0gX3RoaXMuYXVkaW8ucmVhZHlTdGF0ZTsKICAgICAgICBfdGhpcy5zZWVrYWJsZSA9IF90aGlzLmF1ZGlvLnNlZWthYmxlOwogICAgICAgIF90aGlzLnNlZWtpbmcgPSBfdGhpcy5hdWRpby5zZWVraW5nOwogICAgICAgIF90aGlzLnNyYyA9IF90aGlzLmF1ZGlvLnNyYzsKICAgICAgICBfdGhpcy50ZXh0VHJhY2tzID0gX3RoaXMuYXVkaW8udGV4dFRyYWNrczsKICAgICAgICBfdGhpcy52b2x1bWUgPSBfdGhpcy5hdWRpby52b2x1bWU7CiAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7CiAgICAgICAgICBfdGhpcy5hdWRpby5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jdGlvbiAoZSkgewogICAgICAgICAgICBfdGhpcy5zeW5jKCk7CiAgICAgICAgICB9KTsKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gX3RoaXM7CiAgICAgIH0KCiAgICAgIF9jcmVhdGVDbGFzcyhWdWVBdWRpbywgW3sKICAgICAgICBrZXk6ICJzeW5jIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3luYygpIHsKICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzOwoKICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuJGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgewogICAgICAgICAgICBpZiAoa2V5ID09PSAnYXVkaW8nKSByZXR1cm47CiAgICAgICAgICAgIF90aGlzMltrZXldID0gX3RoaXMyLmF1ZGlvW2tleV07CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJsb2FkZWQiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkZWQoKSB7CiAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpczsKCiAgICAgICAgICByZXR1cm4gZXZlbnRMb29wKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5yZWFkeVN0YXRlID49IFJlYWR5U3RhdGUuSEFWRV9GVVRVUkVfREFUQTsKICAgICAgICAgIH0sIDApOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogInNyY0xvYWRlZCIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNyY0xvYWRlZCgpIHsKICAgICAgICAgIHZhciBfdGhpczQgPSB0aGlzOwoKICAgICAgICAgIHJldHVybiBldmVudExvb3AoZnVuY3Rpb24gKCkgewogICAgICAgICAgICByZXR1cm4gX3RoaXM0LnNyYzsKICAgICAgICAgIH0sIDApOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogInJlbmRlciIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHsKICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KICAgICAgfV0pOwoKICAgICAgcmV0dXJuIFZ1ZUF1ZGlvOwogICAgfShleHRlcm5hbF9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9yb290X1Z1ZV9kZWZhdWx0LmEpOwoKICAgIHZ1ZV9hdWRpb19WdWVBdWRpbyA9IF9fZGVjb3JhdGUoW3Z1ZV9jbGFzc19jb21wb25lbnRfY29tbW9uX2RlZmF1bHQuYSwgX19tZXRhZGF0YSgiZGVzaWduOnBhcmFtdHlwZXMiLCBbXSldLCB2dWVfYXVkaW9fVnVlQXVkaW8pOwogICAgLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLwoKICAgIHZhciB2dWVfYXVkaW8gPSB2dWVfYXVkaW9fVnVlQXVkaW87IC8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvQG1vZWZlL3Z1ZS1zdG9yZS9pbmRleC50cwoKICAgIHZhciB2dWVfc3RvcmVfZGVjb3JhdGUgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7CiAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwKICAgICAgICAgIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLAogICAgICAgICAgZDsKICAgICAgaWYgKCh0eXBlb2YgUmVmbGVjdCA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2YoUmVmbGVjdCkpID09PSAib2JqZWN0IiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gImZ1bmN0aW9uIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO2Vsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByOwogICAgICB9CiAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7CiAgICB9OwoKICAgIHZhciB2dWVfc3RvcmVfVnVlU3RvcmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9WdWUpIHsKICAgICAgX2luaGVyaXRzKFZ1ZVN0b3JlLCBfVnVlKTsKCiAgICAgIGZ1bmN0aW9uIFZ1ZVN0b3JlKCkgewogICAgICAgIHZhciBfdGhpczsKCiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZ1ZVN0b3JlKTsKCiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoVnVlU3RvcmUpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpOwogICAgICAgIF90aGlzLmtleSA9ICdhcGxheWVyLXNldHRpbmcnOwogICAgICAgIF90aGlzLnN0b3JlID0gX3RoaXMuZ2V0KF90aGlzLmtleSk7CiAgICAgICAgcmV0dXJuIF90aGlzOwogICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzCgoKICAgICAgX2NyZWF0ZUNsYXNzKFZ1ZVN0b3JlLCBbewogICAgICAgIGtleTogImdldCIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXkpIHsKICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSkgfHwgJ1tdJyk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAic2V0IiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KHZhbCkgewogICAgICAgICAgdGhpcy5zdG9yZSA9IHZhbDsKICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMua2V5LCBKU09OLnN0cmluZ2lmeSh2YWwpKTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJyZW5kZXIiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7CiAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9CiAgICAgIH1dKTsKCiAgICAgIHJldHVybiBWdWVTdG9yZTsKICAgIH0oZXh0ZXJuYWxfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfcm9vdF9WdWVfZGVmYXVsdC5hKTsKCiAgICB2dWVfc3RvcmVfVnVlU3RvcmUgPSB2dWVfc3RvcmVfZGVjb3JhdGUoW3Z1ZV9jbGFzc19jb21wb25lbnRfY29tbW9uX2RlZmF1bHQuYV0sIHZ1ZV9zdG9yZV9WdWVTdG9yZSk7CiAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovCgogICAgdmFyIHZ1ZV9zdG9yZSA9IHZ1ZV9zdG9yZV9WdWVTdG9yZTsgLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi91dGlscy9taXhpbi50cwoKICAgIHZhciBtaXhpbl9kZWNvcmF0ZSA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHsKICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLAogICAgICAgICAgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsCiAgICAgICAgICBkOwogICAgICBpZiAoKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogX3R5cGVvZihSZWZsZWN0KSkgPT09ICJvYmplY3QiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSAiZnVuY3Rpb24iKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7ZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7CiAgICAgIH0KICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjsKICAgIH07CgogICAgdmFyIG1peGluX01peGluID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVnVlKSB7CiAgICAgIF9pbmhlcml0cyhNaXhpbiwgX1Z1ZSk7CgogICAgICBmdW5jdGlvbiBNaXhpbigpIHsKICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWl4aW4pOwoKICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1peGluKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsKICAgICAgfQoKICAgICAgX2NyZWF0ZUNsYXNzKE1peGluLCBbewogICAgICAgIGtleTogImlzTW9iaWxlIiwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHZhciB1YSA9IHRoaXMuJHNzckNvbnRleHQgPyB0aGlzLiRzc3JDb250ZXh0LnVzZXJBZ2VudCA6IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50OwogICAgICAgICAgcmV0dXJuIC9tb2JpbGUvaS50ZXN0KHVhKTsKICAgICAgICB9CiAgICAgIH1dKTsKCiAgICAgIHJldHVybiBNaXhpbjsKICAgIH0oZXh0ZXJuYWxfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfcm9vdF9WdWVfZGVmYXVsdC5hKTsKCiAgICBtaXhpbl9NaXhpbiA9IG1peGluX2RlY29yYXRlKFt2dWVfY2xhc3NfY29tcG9uZW50X2NvbW1vbl9kZWZhdWx0LmFdLCBtaXhpbl9NaXhpbik7CiAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovCgogICAgdmFyIG1peGluID0gbWl4aW5fTWl4aW47IC8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvQG1vZWZlL3Z1ZS1hcGxheWVyL2NvbXBvbmVudHMvQ292ZXIudHN4CgogICAgdmFyIENvdmVyX2RlY29yYXRlID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykgewogICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsCiAgICAgICAgICByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywKICAgICAgICAgIGQ7CiAgICAgIGlmICgodHlwZW9mIFJlZmxlY3QgPT09ICJ1bmRlZmluZWQiID8gInVuZGVmaW5lZCIgOiBfdHlwZW9mKFJlZmxlY3QpKSA9PT0gIm9iamVjdCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09ICJmdW5jdGlvbiIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7CiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjsKICAgICAgfQogICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByOwogICAgfTsKCiAgICB2YXIgQ292ZXJfbWV0YWRhdGEgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fbWV0YWRhdGEgfHwgZnVuY3Rpb24gKGssIHYpIHsKICAgICAgaWYgKCh0eXBlb2YgUmVmbGVjdCA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2YoUmVmbGVjdCkpID09PSAib2JqZWN0IiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gImZ1bmN0aW9uIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7CiAgICB9OwoKICAgIHZhciBDb3Zlcl9hOwoKICAgIHZhciBDb3Zlcl9Db3ZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Z1ZSRDb21wb25lbnQpIHsKICAgICAgX2luaGVyaXRzKENvdmVyLCBfVnVlJENvbXBvbmVudCk7CgogICAgICBmdW5jdGlvbiBDb3ZlcigpIHsKICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ292ZXIpOwoKICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKENvdmVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsKICAgICAgfQoKICAgICAgX2NyZWF0ZUNsYXNzKENvdmVyLCBbewogICAgICAgIGtleTogImhhbmRsZUNsaWNrIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2xpY2soZSkgewogICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBlKTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJyZW5kZXIiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7CiAgICAgICAgICB2YXIgaCA9IGFyZ3VtZW50c1swXTsKICAgICAgICAgIHJldHVybiBoKCJkaXYiLCB7CiAgICAgICAgICAgICJjbGFzcyI6ICJhcGxheWVyLXBpYyIsCiAgICAgICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlLAogICAgICAgICAgICBvbjogewogICAgICAgICAgICAgICJjbGljayI6IHRoaXMuaGFuZGxlQ2xpY2sKICAgICAgICAgICAgfQogICAgICAgICAgfSwgW3RoaXMuJHNsb3RzWyJkZWZhdWx0Il1dKTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJzdHlsZSIsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICB2YXIgX3RoaXMkYXBsYXllciA9IHRoaXMuYXBsYXllciwKICAgICAgICAgICAgICBvcHRpb25zID0gX3RoaXMkYXBsYXllci5vcHRpb25zLAogICAgICAgICAgICAgIGN1cnJlbnRUaGVtZSA9IF90aGlzJGFwbGF5ZXIuY3VycmVudFRoZW1lLAogICAgICAgICAgICAgIGN1cnJlbnRNdXNpYyA9IF90aGlzJGFwbGF5ZXIuY3VycmVudE11c2ljOwogICAgICAgICAgdmFyIGNvdmVyID0gY3VycmVudE11c2ljLmNvdmVyIHx8IG9wdGlvbnMuZGVmYXVsdENvdmVyOwogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBjb3ZlciAmJiAidXJsKFwiIi5jb25jYXQoY292ZXIsICJcIikiKSwKICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjdXJyZW50VGhlbWUKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICB9XSk7CgogICAgICByZXR1cm4gQ292ZXI7CiAgICB9KGxpYlsiQ29tcG9uZW50Il0pOwoKICAgIENvdmVyX2RlY29yYXRlKFtJbmplY3QoKSwgQ292ZXJfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgT2JqZWN0KV0sIENvdmVyX0NvdmVyLnByb3RvdHlwZSwgImFwbGF5ZXIiLCB2b2lkIDApOwogICAgQ292ZXJfQ292ZXIgPSBDb3Zlcl9kZWNvcmF0ZShbdnVlX2NsYXNzX2NvbXBvbmVudF9jb21tb25fZGVmYXVsdC5hXSwgQ292ZXJfQ292ZXIpOwogICAgLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLwoKICAgIHZhciBjb21wb25lbnRzX0NvdmVyID0gQ292ZXJfQ292ZXI7IC8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvQG1vZWZlL3Z1ZS1hcGxheWVyL2NvbXBvbmVudHMvSWNvbi50c3gKCiAgICB2YXIgSWNvbl9kZWNvcmF0ZSA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHsKICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLAogICAgICAgICAgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsCiAgICAgICAgICBkOwogICAgICBpZiAoKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogX3R5cGVvZihSZWZsZWN0KSkgPT09ICJvYmplY3QiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSAiZnVuY3Rpb24iKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7ZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7CiAgICAgIH0KICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjsKICAgIH07CgogICAgdmFyIEljb25fbWV0YWRhdGEgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fbWV0YWRhdGEgfHwgZnVuY3Rpb24gKGssIHYpIHsKICAgICAgaWYgKCh0eXBlb2YgUmVmbGVjdCA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2YoUmVmbGVjdCkpID09PSAib2JqZWN0IiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gImZ1bmN0aW9uIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7CiAgICB9OwoKICAgIHZhciBpY29uID0gZnVuY3Rpb24gaWNvbih0eXBlKSB7CiAgICAgIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKCI1MmYwIikoIi4vIi5jb25jYXQodHlwZSwgIi5zdmciKSlbImRlZmF1bHQiXTsKICAgIH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUKCgogICAgdmFyIEljb25fSWNvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Z1ZSRDb21wb25lbnQpIHsKICAgICAgX2luaGVyaXRzKEljb24sIF9WdWUkQ29tcG9uZW50KTsKCiAgICAgIGZ1bmN0aW9uIEljb24oKSB7CiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEljb24pOwoKICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEljb24pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpOwogICAgICB9CgogICAgICBfY3JlYXRlQ2xhc3MoSWNvbiwgW3sKICAgICAgICBrZXk6ICJyZW5kZXIiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7CiAgICAgICAgICB2YXIgaCA9IGFyZ3VtZW50c1swXTsKICAgICAgICAgIHZhciBJID0gaWNvbih0aGlzLnR5cGUpOwogICAgICAgICAgcmV0dXJuIGgoSSk7CiAgICAgICAgfQogICAgICB9XSk7CgogICAgICByZXR1cm4gSWNvbjsKICAgIH0obGliWyJDb21wb25lbnQiXSk7CgogICAgSWNvbl9kZWNvcmF0ZShbUHJvcCh7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgcmVxdWlyZWQ6IHRydWUKICAgIH0pLCBJY29uX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIFN0cmluZyldLCBJY29uX0ljb24ucHJvdG90eXBlLCAidHlwZSIsIHZvaWQgMCk7CiAgICBJY29uX0ljb24gPSBJY29uX2RlY29yYXRlKFt2dWVfY2xhc3NfY29tcG9uZW50X2NvbW1vbl9kZWZhdWx0LmFdLCBJY29uX0ljb24pOwogICAgLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLwoKICAgIHZhciBjb21wb25lbnRzX0ljb24gPSBJY29uX0ljb247IC8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb3J0LmpzCgogICAgdmFyIGVzNl9hcnJheV9zb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNTVkZCIpOyAvLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0LmpzCgoKICAgIHZhciBlczZfcmVnZXhwX3NwbGl0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygiMjhhNSIpOyAvLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanMKCgogICAgdmFyIGVzNl9yZWdleHBfcmVwbGFjZSA9IF9fd2VicGFja19yZXF1aXJlX18oImE0ODEiKTsgLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qcwoKCiAgICB2YXIgZXM2X3JlZ2V4cF9tYXRjaCA9IF9fd2VicGFja19yZXF1aXJlX18oIjQ5MTciKTsgLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9AbW9lZmUvdnVlLWFwbGF5ZXIvdXRpbHMvaW5kZXgudHMKCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqLwoKCiAgICBmdW5jdGlvbiBzaHVmZmxlKGFycikgewogICAgICBmb3IgKHZhciBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7CiAgICAgICAgdmFyIHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7CiAgICAgICAgdmFyIGl0ZW1BdEluZGV4ID0gYXJyW3JhbmRvbUluZGV4XTsKICAgICAgICBhcnJbcmFuZG9tSW5kZXhdID0gYXJyW2ldOwogICAgICAgIGFycltpXSA9IGl0ZW1BdEluZGV4OwogICAgICB9CgogICAgICByZXR1cm4gYXJyOwogICAgfQoKICAgIHZhciB1dGlsc19IdHRwUmVxdWVzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7CiAgICAgIGZ1bmN0aW9uIEh0dHBSZXF1ZXN0KCkgewogICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIdHRwUmVxdWVzdCk7CgogICAgICAgIHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7CiAgICAgIH0KCiAgICAgIF9jcmVhdGVDbGFzcyhIdHRwUmVxdWVzdCwgW3sKICAgICAgICBrZXk6ICJkb3dubG9hZCIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRvd25sb2FkKHVybCkgewogICAgICAgICAgdmFyIF90aGlzID0gdGhpczsKCiAgICAgICAgICB2YXIgcmVzcG9uc2VUeXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJzsKICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgICAgICAgIF90aGlzLnhoci5vcGVuKCdnZXQnLCB1cmwpOwoKICAgICAgICAgICAgX3RoaXMueGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTsKCiAgICAgICAgICAgIF90aGlzLnhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IF90aGlzLnhoci5zdGF0dXM7CgogICAgICAgICAgICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNCkgewogICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy54aHIucmVzcG9uc2UpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfTsKCiAgICAgICAgICAgIF90aGlzLnhoci5vbmFib3J0ID0gcmVqZWN0OwogICAgICAgICAgICBfdGhpcy54aHIub25lcnJvciA9IHJlamVjdDsKICAgICAgICAgICAgX3RoaXMueGhyLm9udGltZW91dCA9IHJlamVjdDsKCiAgICAgICAgICAgIF90aGlzLnhoci5zZW5kKCk7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH1dKTsKCiAgICAgIHJldHVybiBIdHRwUmVxdWVzdDsKICAgIH0oKTsgLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9AbW9lZmUvdnVlLWFwbGF5ZXIvY29tcG9uZW50cy9MeXJpYy50c3gKCgogICAgdmFyIEx5cmljX2RlY29yYXRlID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykgewogICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsCiAgICAgICAgICByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywKICAgICAgICAgIGQ7CiAgICAgIGlmICgodHlwZW9mIFJlZmxlY3QgPT09ICJ1bmRlZmluZWQiID8gInVuZGVmaW5lZCIgOiBfdHlwZW9mKFJlZmxlY3QpKSA9PT0gIm9iamVjdCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09ICJmdW5jdGlvbiIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7CiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjsKICAgICAgfQogICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByOwogICAgfTsKCiAgICB2YXIgTHlyaWNfbWV0YWRhdGEgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fbWV0YWRhdGEgfHwgZnVuY3Rpb24gKGssIHYpIHsKICAgICAgaWYgKCh0eXBlb2YgUmVmbGVjdCA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2YoUmVmbGVjdCkpID09PSAib2JqZWN0IiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gImZ1bmN0aW9uIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7CiAgICB9OwoKICAgIHZhciBMeXJpY19hOwoKICAgIHZhciBMeXJpY19MeXJpYyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Z1ZSRDb21wb25lbnQpIHsKICAgICAgX2luaGVyaXRzKEx5cmljLCBfVnVlJENvbXBvbmVudCk7CgogICAgICBmdW5jdGlvbiBMeXJpYygpIHsKICAgICAgICB2YXIgX3RoaXM7CgogICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMeXJpYyk7CgogICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEx5cmljKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsKICAgICAgICBfdGhpcy5scmMgPSAnJzsKICAgICAgICBfdGhpcy54aHIgPSBuZXcgdXRpbHNfSHR0cFJlcXVlc3QoKTsKICAgICAgICBfdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTsKICAgICAgICByZXR1cm4gX3RoaXM7CiAgICAgIH0KCiAgICAgIF9jcmVhdGVDbGFzcyhMeXJpYywgW3sKICAgICAgICBrZXk6ICJnZXRMeXJpY0Zyb21DdXJyZW50TXVzaWMiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMeXJpY0Zyb21DdXJyZW50TXVzaWMoKSB7CiAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpczsKCiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgICB2YXIgX3RoaXMyJGFwbGF5ZXIgPSBfdGhpczIuYXBsYXllciwKICAgICAgICAgICAgICAgIGxyY1R5cGUgPSBfdGhpczIkYXBsYXllci5scmNUeXBlLAogICAgICAgICAgICAgICAgY3VycmVudE11c2ljID0gX3RoaXMyJGFwbGF5ZXIuY3VycmVudE11c2ljOwoKICAgICAgICAgICAgc3dpdGNoIChscmNUeXBlKSB7CiAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgcmVzb2x2ZSgnJyk7CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgcmVzb2x2ZShjdXJyZW50TXVzaWMubHJjKTsKICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICByZXNvbHZlKGN1cnJlbnRNdXNpYy5scmMgPyBfdGhpczIueGhyLmRvd25sb2FkKGN1cnJlbnRNdXNpYy5scmMpIDogJycpOwogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCJJbGxlZ2FsIGxyY1R5cGU6ICIuY29uY2F0KGxyY1R5cGUpKSk7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAicGFyc2VMUkMiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUxSQyhscmMpIHsKICAgICAgICAgIHZhciByZWcgPSAvXFsoXGQrKTooXGQrKVsufDpdKFxkKylcXSguKykvOwogICAgICAgICAgdmFyIHJlZ1RpbWUgPSAvXFsoXGQrKTooXGQrKVsufDpdKFxkKylcXS9nOwogICAgICAgICAgdmFyIHJlZ0NvbXBhdGlibGUgPSAvXFsoXGQrKTooXGQrKV0oKSguKykvOwogICAgICAgICAgdmFyIHJlZ1RpbWVDb21wYXRpYmxlID0gL1xbKFxkKyk6KFxkKyldL2c7CiAgICAgICAgICB2YXIgcmVnT2Zmc2V0ID0gL1xbb2Zmc2V0OlxzKigtP1xkKylcXS87CiAgICAgICAgICB2YXIgb2Zmc2V0TWF0Y2ggPSB0aGlzLmxyYy5tYXRjaChyZWdPZmZzZXQpOwogICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldE1hdGNoID8gTnVtYmVyKG9mZnNldE1hdGNoWzFdKSA6IDA7CiAgICAgICAgICB2YXIgcGFyc2VkID0gW107CgogICAgICAgICAgdmFyIG1hdGNoQWxsID0gZnVuY3Rpb24gbWF0Y2hBbGwobGluZSkgewogICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lLm1hdGNoKHJlZykgfHwgbGluZS5tYXRjaChyZWdDb21wYXRpYmxlKTsKICAgICAgICAgICAgaWYgKCFtYXRjaCB8fCBtYXRjaC5sZW5ndGggIT09IDUpIHJldHVybjsKICAgICAgICAgICAgdmFyIG1pbnV0ZXMgPSBOdW1iZXIobWF0Y2hbMV0pIHx8IDA7CiAgICAgICAgICAgIHZhciBzZWNvbmRzID0gTnVtYmVyKG1hdGNoWzJdKSB8fCAwOwogICAgICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gTnVtYmVyKG1hdGNoWzNdKSB8fCAwOwogICAgICAgICAgICB2YXIgdGltZSA9IG1pbnV0ZXMgKiA2MCAqIDEwMDAgKyBzZWNvbmRzICogMTAwMCArIG1pbGxpc2Vjb25kcyArIG9mZnNldDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1taXhlZC1vcGVyYXRvcnMKCiAgICAgICAgICAgIHZhciB0ZXh0ID0gbWF0Y2hbNF0ucmVwbGFjZShyZWdUaW1lLCAnJykucmVwbGFjZShyZWdUaW1lQ29tcGF0aWJsZSwgJycpOyAvLyDkvJjljJbvvJrkuI3opoHmmL7npLrnqbrooYwKCiAgICAgICAgICAgIGlmICghdGV4dCkgcmV0dXJuOwogICAgICAgICAgICBwYXJzZWQucHVzaCh7CiAgICAgICAgICAgICAgdGltZTogdGltZSwKICAgICAgICAgICAgICB0ZXh0OiB0ZXh0CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBtYXRjaEFsbChtYXRjaFs0XSk7IC8vIOmAkuW9kuWMuemFjeWkmuS4quaXtumXtOagh+etvgogICAgICAgICAgfTsKCiAgICAgICAgICBscmMucmVwbGFjZSgvXFxuL2csICdcbicpLnNwbGl0KCdcbicpLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHsKICAgICAgICAgICAgcmV0dXJuIG1hdGNoQWxsKGxpbmUpOwogICAgICAgICAgfSk7CgogICAgICAgICAgaWYgKHBhcnNlZC5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgIHBhcnNlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGEudGltZSAtIGIudGltZTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIHBhcnNlZDsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJoYW5kbGVDaGFuZ2UiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICB2YXIgX2hhbmRsZUNoYW5nZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHsKICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7CiAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwOwogICAgICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICB0aGlzLmxyYyA9ICcnOwogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1OwogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEx5cmljRnJvbUN1cnJlbnRNdXNpYygpOwoKICAgICAgICAgICAgICAgICAgY2FzZSA1OgogICAgICAgICAgICAgICAgICAgIHRoaXMubHJjID0gX2NvbnRleHQuc2VudDsKCiAgICAgICAgICAgICAgICAgIGNhc2UgNjoKICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNjsKICAgICAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goNik7CgogICAgICAgICAgICAgICAgICBjYXNlIDk6CiAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMCwsIDYsIDldXSk7CiAgICAgICAgICB9KSk7CgogICAgICAgICAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKCkgewogICAgICAgICAgICByZXR1cm4gX2hhbmRsZUNoYW5nZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiBoYW5kbGVDaGFuZ2U7CiAgICAgICAgfSgpCiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJyZW5kZXIiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7CiAgICAgICAgICB2YXIgaCA9IGFyZ3VtZW50c1swXTsKICAgICAgICAgIHZhciB2aXNpYmxlID0gdGhpcy52aXNpYmxlLAogICAgICAgICAgICAgIHN0eWxlID0gdGhpcy5zdHlsZSwKICAgICAgICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlZCwKICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5jdXJyZW50LAogICAgICAgICAgICAgIG5vTHlyaWMgPSB0aGlzLm5vTHlyaWM7CiAgICAgICAgICByZXR1cm4gaCgiZGl2IiwgewogICAgICAgICAgICAiY2xhc3MiOiBjbGFzc25hbWVzX2RlZmF1bHQoKSh7CiAgICAgICAgICAgICAgJ2FwbGF5ZXItbHJjJzogdHJ1ZSwKICAgICAgICAgICAgICAnYXBsYXllci1scmMtaGlkZSc6ICF2aXNpYmxlCiAgICAgICAgICAgIH0pCiAgICAgICAgICB9LCBbaCgiZGl2IiwgewogICAgICAgICAgICAiY2xhc3MiOiAiYXBsYXllci1scmMtY29udGVudHMiLAogICAgICAgICAgICBzdHlsZTogc3R5bGUKICAgICAgICAgIH0sIFtwYXJzZWQubGVuZ3RoID4gMCA/IHBhcnNlZC5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7CiAgICAgICAgICAgIHJldHVybiBoKCJwIiwgewogICAgICAgICAgICAgIGtleTogaXRlbS50aW1lLAogICAgICAgICAgICAgICJjbGFzcyI6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKHsKICAgICAgICAgICAgICAgICdhcGxheWVyLWxyYy1jdXJyZW50JzogY3VycmVudC50aW1lID09PSBpdGVtLnRpbWUKICAgICAgICAgICAgICB9KQogICAgICAgICAgICB9LCBbaXRlbS50ZXh0XSk7CiAgICAgICAgICB9KSA6IGgoInAiLCB7CiAgICAgICAgICAgICJjbGFzcyI6ICJhcGxheWVyLWxyYy1jdXJyZW50IgogICAgICAgICAgfSwgW25vTHlyaWNdKV0pXSk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAibm9MeXJpYyIsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXN0ZWQtdGVybmFyeSAqLwogICAgICAgICAgdmFyIGN1cnJlbnRNdXNpYyA9IHRoaXMuYXBsYXllci5jdXJyZW50TXVzaWM7CiAgICAgICAgICByZXR1cm4gIWN1cnJlbnRNdXNpYy5pZCA/ICco4LKXIOKAuCDgspcgKSDmnKrliqDovb3pn7PpopEnIDogdGhpcy5pc0xvYWRpbmcgPyAnKCrjgp3PieODuykg5bCR5aWz56WI56W35LitLi4nIDogdGhpcy5scmMgPyAnKOODu+KIgOODuyopIOaKseatie+8jOivpeatjOivjeagvOW8j+S4jeaUr+aMgScgOiAnKCws4oCizIEgLiDigKLMgCwsKSDmirHmrYnvvIzlvZPliY3mrYzmm7LmmoLml6DmrYzor40nOwogICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXN0ZWQtdGVybmFyeSAqLwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogInBhcnNlZCIsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxSQyh0aGlzLmxyYyk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiY3VycmVudCIsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICB2YXIgX3RoaXMkYXBsYXllciA9IHRoaXMuYXBsYXllciwKICAgICAgICAgICAgICBtZWRpYSA9IF90aGlzJGFwbGF5ZXIubWVkaWEsCiAgICAgICAgICAgICAgY3VycmVudFBsYXllZCA9IF90aGlzJGFwbGF5ZXIuY3VycmVudFBsYXllZDsKICAgICAgICAgIHZhciBtYXRjaCA9IHRoaXMucGFyc2VkLmZpbHRlcihmdW5jdGlvbiAoeCkgewogICAgICAgICAgICByZXR1cm4geC50aW1lIDwgY3VycmVudFBsYXllZCAqIG1lZGlhLmR1cmF0aW9uICogMTAwMDsKICAgICAgICAgIH0pOwogICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDApIHJldHVybiBtYXRjaFttYXRjaC5sZW5ndGggLSAxXTsKICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlZFswXTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJ0cmFuc2l0aW9uRHVyYXRpb24iLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkLmxlbmd0aCA+IDEgPyA1MDAgOiAwOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogInRyYW5zbGF0ZVkiLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQsCiAgICAgICAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZWQ7CiAgICAgICAgICBpZiAocGFyc2VkLmxlbmd0aCA8PSAwKSByZXR1cm4gMDsKICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlZC5pbmRleE9mKGN1cnJlbnQpOwogICAgICAgICAgdmFyIGlzTGFzdCA9IGluZGV4ID09PSBwYXJzZWQubGVuZ3RoIC0gMTsKICAgICAgICAgIHJldHVybiAoaXNMYXN0ID8gKGluZGV4IC0gMSkgKiAxNiA6IGluZGV4ICogMTYpICogLTE7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAic3R5bGUiLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAiIi5jb25jYXQodGhpcy50cmFuc2l0aW9uRHVyYXRpb24sICJtcyIpLAogICAgICAgICAgICB0cmFuc2Zvcm06ICJ0cmFuc2xhdGUzZCgwLCAiLmNvbmNhdCh0aGlzLnRyYW5zbGF0ZVksICJweCwgMCkiKQogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgIH1dKTsKCiAgICAgIHJldHVybiBMeXJpYzsKICAgIH0obGliWyJDb21wb25lbnQiXSk7CgogICAgTHlyaWNfZGVjb3JhdGUoW1Byb3AoewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICByZXF1aXJlZDogZmFsc2UsCiAgICAgICJkZWZhdWx0IjogdHJ1ZQogICAgfSksIEx5cmljX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIEJvb2xlYW4pXSwgTHlyaWNfTHlyaWMucHJvdG90eXBlLCAidmlzaWJsZSIsIHZvaWQgMCk7CiAgICBMeXJpY19kZWNvcmF0ZShbSW5qZWN0KCksIEx5cmljX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIE9iamVjdCldLCBMeXJpY19MeXJpYy5wcm90b3R5cGUsICJhcGxheWVyIiwgdm9pZCAwKTsKICAgIEx5cmljX2RlY29yYXRlKFtXYXRjaCgnYXBsYXllci5scmNUeXBlJywgewogICAgICBpbW1lZGlhdGU6IHRydWUKICAgIH0pLCBXYXRjaCgnYXBsYXllci5jdXJyZW50TXVzaWMubHJjJywgewogICAgICBpbW1lZGlhdGU6IHRydWUKICAgIH0pLCBMeXJpY19tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbiksIEx5cmljX21ldGFkYXRhKCJkZXNpZ246cGFyYW10eXBlcyIsIFtdKSwgTHlyaWNfbWV0YWRhdGEoImRlc2lnbjpyZXR1cm50eXBlIiwgUHJvbWlzZSldLCBMeXJpY19MeXJpYy5wcm90b3R5cGUsICJoYW5kbGVDaGFuZ2UiLCBudWxsKTsKICAgIEx5cmljX0x5cmljID0gTHlyaWNfZGVjb3JhdGUoW3Z1ZV9jbGFzc19jb21wb25lbnRfY29tbW9uX2RlZmF1bHQuYV0sIEx5cmljX0x5cmljKTsKICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8KCiAgICB2YXIgY29tcG9uZW50c19MeXJpYyA9IEx5cmljX0x5cmljOyAvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL0Btb2VmZS92dWUtYXBsYXllci9jb21wb25lbnRzL01haW4udHN4CgogICAgdmFyIE1haW5fZGVjb3JhdGUgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7CiAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwKICAgICAgICAgIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLAogICAgICAgICAgZDsKICAgICAgaWYgKCh0eXBlb2YgUmVmbGVjdCA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2YoUmVmbGVjdCkpID09PSAib2JqZWN0IiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gImZ1bmN0aW9uIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO2Vsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByOwogICAgICB9CiAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7CiAgICB9OwoKICAgIHZhciBNYWluX21ldGFkYXRhID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX21ldGFkYXRhIHx8IGZ1bmN0aW9uIChrLCB2KSB7CiAgICAgIGlmICgodHlwZW9mIFJlZmxlY3QgPT09ICJ1bmRlZmluZWQiID8gInVuZGVmaW5lZCIgOiBfdHlwZW9mKFJlZmxlY3QpKSA9PT0gIm9iamVjdCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09ICJmdW5jdGlvbiIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpOwogICAgfTsKCiAgICB2YXIgTWFpbl9hOwoKICAgIHZhciBNYWluX01haW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9WdWUkQ29tcG9uZW50KSB7CiAgICAgIF9pbmhlcml0cyhNYWluLCBfVnVlJENvbXBvbmVudCk7CgogICAgICBmdW5jdGlvbiBNYWluKCkgewogICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYWluKTsKCiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihNYWluKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsKICAgICAgfQoKICAgICAgX2NyZWF0ZUNsYXNzKE1haW4sIFt7CiAgICAgICAga2V5OiAicmVuZGVyIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkgewogICAgICAgICAgdmFyIGggPSBhcmd1bWVudHNbMF07CiAgICAgICAgICB2YXIgbXVzaWMgPSB0aGlzLm11c2ljOwogICAgICAgICAgdmFyIGZpeGVkID0gdGhpcy5hcGxheWVyLmZpeGVkOwogICAgICAgICAgcmV0dXJuIGgoImRpdiIsIHsKICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItaW5mbyIKICAgICAgICAgIH0sIFtoKCJkaXYiLCB7CiAgICAgICAgICAgICJjbGFzcyI6ICJhcGxheWVyLW11c2ljIgogICAgICAgICAgfSwgW2goInNwYW4iLCB7CiAgICAgICAgICAgICJjbGFzcyI6ICJhcGxheWVyLXRpdGxlIgogICAgICAgICAgfSwgW211c2ljLm5hbWVdKSwgaCgic3BhbiIsIHsKICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItYXV0aG9yIgogICAgICAgICAgfSwgW211c2ljLmFydGlzdF0pXSksICFmaXhlZCA/IGgoY29tcG9uZW50c19MeXJpYykgOiBudWxsLCB0aGlzLiRzbG90c1siZGVmYXVsdCJdXSk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAibXVzaWMiLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgdmFyIGN1cnJlbnRNdXNpYyA9IHRoaXMuYXBsYXllci5jdXJyZW50TXVzaWM7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBuYW1lOiBjdXJyZW50TXVzaWMubmFtZSwKICAgICAgICAgICAgYXJ0aXN0OiBjdXJyZW50TXVzaWMuYXJ0aXN0ID8gIiAtICIuY29uY2F0KGN1cnJlbnRNdXNpYy5hcnRpc3QpIDogJycKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICB9XSk7CgogICAgICByZXR1cm4gTWFpbjsKICAgIH0obGliWyJDb21wb25lbnQiXSk7CgogICAgTWFpbl9kZWNvcmF0ZShbSW5qZWN0KCksIE1haW5fbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgT2JqZWN0KV0sIE1haW5fTWFpbi5wcm90b3R5cGUsICJhcGxheWVyIiwgdm9pZCAwKTsKICAgIE1haW5fTWFpbiA9IE1haW5fZGVjb3JhdGUoW3Z1ZV9jbGFzc19jb21wb25lbnRfY29tbW9uX2RlZmF1bHQuYV0sIE1haW5fTWFpbik7CiAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovCgogICAgdmFyIGNvbXBvbmVudHNfTWFpbiA9IE1haW5fTWFpbjsgLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcwoKICAgIHZhciBlczZfc3RyaW5nX3N0YXJ0c193aXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygiZjU1OSIpOyAvLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcwoKCiAgICB2YXIgZXM3X3N0cmluZ19wYWRfc3RhcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCJmNTc2Iik7IC8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvQG1vZWZlL3Z1ZS10b3VjaC9pbmRleC50c3gKCgogICAgdmFyIHZ1ZV90b3VjaF9kZWNvcmF0ZSA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHsKICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLAogICAgICAgICAgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsCiAgICAgICAgICBkOwogICAgICBpZiAoKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogX3R5cGVvZihSZWZsZWN0KSkgPT09ICJvYmplY3QiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSAiZnVuY3Rpb24iKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7ZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7CiAgICAgIH0KICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjsKICAgIH07CgogICAgdmFyIHZ1ZV90b3VjaF9tZXRhZGF0YSA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19tZXRhZGF0YSB8fCBmdW5jdGlvbiAoaywgdikgewogICAgICBpZiAoKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogX3R5cGVvZihSZWZsZWN0KSkgPT09ICJvYmplY3QiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSAiZnVuY3Rpb24iKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTsKICAgIH07CgogICAgdmFyIHZ1ZV90b3VjaF9Ub3VjaCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Z1ZSRDb21wb25lbnQpIHsKICAgICAgX2luaGVyaXRzKFRvdWNoLCBfVnVlJENvbXBvbmVudCk7CgogICAgICBmdW5jdGlvbiBUb3VjaCgpIHsKICAgICAgICB2YXIgX3RoaXM7CgogICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb3VjaCk7CgogICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFRvdWNoKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsKICAgICAgICBfdGhpcy5pc0RyYWdNb3ZlID0gZmFsc2U7CiAgICAgICAgcmV0dXJuIF90aGlzOwogICAgICB9CgogICAgICBfY3JlYXRlQ2xhc3MoVG91Y2gsIFt7CiAgICAgICAga2V5OiAidGh1bWJNb3ZlIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdGh1bWJNb3ZlKGUpIHsKICAgICAgICAgIHRoaXMuaXNEcmFnTW92ZSA9IHRydWU7CiAgICAgICAgICB0aGlzLiRlbWl0KCdwYW5Nb3ZlJywgZSk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAidGh1bWJVcCIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRodW1iVXAoZSkgewogICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmRyYWdNb3ZlLCB0aGlzLnRodW1iTW92ZSk7CiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuZHJhZ0VuZCwgdGhpcy50aHVtYlVwKTsKICAgICAgICAgIHRoaXMuaXNEcmFnTW92ZSA9IGZhbHNlOwogICAgICAgICAgdGhpcy4kZW1pdCgncGFuRW5kJywgZSk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAibW91bnRlZCIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7CiAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpczsKCiAgICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKHRoaXMuZHJhZ1N0YXJ0LCBmdW5jdGlvbiAoZSkgewogICAgICAgICAgICBfdGhpczIuJGVtaXQoJ3BhblN0YXJ0JywgZSk7CgogICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKF90aGlzMi5kcmFnTW92ZSwgX3RoaXMyLnRodW1iTW92ZSk7CiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoX3RoaXMyLmRyYWdFbmQsIF90aGlzMi50aHVtYlVwKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogInJlbmRlciIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHsKICAgICAgICAgIHZhciBoID0gYXJndW1lbnRzWzBdOwogICAgICAgICAgcmV0dXJuIGgoImRpdiIsIHsKICAgICAgICAgICAgImNsYXNzIjogdGhpcy5jbGFzc05hbWVzLAogICAgICAgICAgICBzdHlsZTogewogICAgICAgICAgICAgIHRvdWNoQWN0aW9uOiAnbm9uZScsCiAgICAgICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLAogICAgICAgICAgICAgIHdlYmtpdFVzZXJEcmFnOiAnbm9uZScsCiAgICAgICAgICAgICAgd2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsIDAsIDAsIDApJwogICAgICAgICAgICB9CiAgICAgICAgICB9LCBbdGhpcy4kc2xvdHNbImRlZmF1bHQiXV0pOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogImNsYXNzTmFtZXMiLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgdmFyIHBhbk1vdmVDbGFzcyA9IHRoaXMucGFuTW92ZUNsYXNzLAogICAgICAgICAgICAgIGlzRHJhZ01vdmUgPSB0aGlzLmlzRHJhZ01vdmU7CiAgICAgICAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBwYW5Nb3ZlQ2xhc3MsIGlzRHJhZ01vdmUpOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogImRyYWdTdGFydCIsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5pc01vYmlsZSA/ICd0b3VjaHN0YXJ0JyA6ICdtb3VzZWRvd24nOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogImRyYWdNb3ZlIiwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmlzTW9iaWxlID8gJ3RvdWNobW92ZScgOiAnbW91c2Vtb3ZlJzsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJkcmFnRW5kIiwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmlzTW9iaWxlID8gJ3RvdWNoZW5kJyA6ICdtb3VzZXVwJzsKICAgICAgICB9CiAgICAgIH1dKTsKCiAgICAgIHJldHVybiBUb3VjaDsKICAgIH0obGliWyJDb21wb25lbnQiXSk7CgogICAgdnVlX3RvdWNoX2RlY29yYXRlKFtQcm9wKHsKICAgICAgdHlwZTogU3RyaW5nLAogICAgICByZXF1aXJlZDogZmFsc2UKICAgIH0pLCB2dWVfdG91Y2hfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgU3RyaW5nKV0sIHZ1ZV90b3VjaF9Ub3VjaC5wcm90b3R5cGUsICJwYW5Nb3ZlQ2xhc3MiLCB2b2lkIDApOwogICAgdnVlX3RvdWNoX1RvdWNoID0gdnVlX3RvdWNoX2RlY29yYXRlKFt2dWVfY2xhc3NfY29tcG9uZW50X2NvbW1vbl9kZWZhdWx0KCkoewogICAgICBtaXhpbnM6IFttaXhpbl0KICAgIH0pXSwgdnVlX3RvdWNoX1RvdWNoKTsKICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8KCiAgICB2YXIgdnVlX3RvdWNoID0gdnVlX3RvdWNoX1RvdWNoOyAvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL0Btb2VmZS92dWUtYXBsYXllci9jb21wb25lbnRzL0J1dHRvbi50c3gKCiAgICB2YXIgQnV0dG9uX2RlY29yYXRlID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykgewogICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsCiAgICAgICAgICByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywKICAgICAgICAgIGQ7CiAgICAgIGlmICgodHlwZW9mIFJlZmxlY3QgPT09ICJ1bmRlZmluZWQiID8gInVuZGVmaW5lZCIgOiBfdHlwZW9mKFJlZmxlY3QpKSA9PT0gIm9iamVjdCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09ICJmdW5jdGlvbiIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7CiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjsKICAgICAgfQogICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByOwogICAgfTsKCiAgICB2YXIgQnV0dG9uX21ldGFkYXRhID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX21ldGFkYXRhIHx8IGZ1bmN0aW9uIChrLCB2KSB7CiAgICAgIGlmICgodHlwZW9mIFJlZmxlY3QgPT09ICJ1bmRlZmluZWQiID8gInVuZGVmaW5lZCIgOiBfdHlwZW9mKFJlZmxlY3QpKSA9PT0gIm9iamVjdCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09ICJmdW5jdGlvbiIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpOwogICAgfTsKCiAgICB2YXIgQnV0dG9uX0J1dHRvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Z1ZSRDb21wb25lbnQpIHsKICAgICAgX2luaGVyaXRzKEJ1dHRvbiwgX1Z1ZSRDb21wb25lbnQpOwoKICAgICAgZnVuY3Rpb24gQnV0dG9uKCkgewogICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdXR0b24pOwoKICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEJ1dHRvbikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7CiAgICAgIH0KCiAgICAgIF9jcmVhdGVDbGFzcyhCdXR0b24sIFt7CiAgICAgICAga2V5OiAiaGFuZGxlQ2xpY2siLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDbGljaygpIHsKICAgICAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrJyk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAicmVuZGVyIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkgewogICAgICAgICAgdmFyIGggPSBhcmd1bWVudHNbMF07CiAgICAgICAgICByZXR1cm4gaCgiYnV0dG9uIiwgewogICAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAgIHR5cGU6ICJidXR0b24iCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgICJjbGFzcyI6ICJhcGxheWVyLWljb24gYXBsYXllci1pY29uLSIuY29uY2F0KHRoaXMudHlwZSksCiAgICAgICAgICAgIG9uOiB7CiAgICAgICAgICAgICAgImNsaWNrIjogdGhpcy5oYW5kbGVDbGljawogICAgICAgICAgICB9CiAgICAgICAgICB9LCBbaChjb21wb25lbnRzX0ljb24sIHsKICAgICAgICAgICAgYXR0cnM6IHsKICAgICAgICAgICAgICB0eXBlOiB0aGlzLmljb24KICAgICAgICAgICAgfQogICAgICAgICAgfSldKTsKICAgICAgICB9CiAgICAgIH1dKTsKCiAgICAgIHJldHVybiBCdXR0b247CiAgICB9KGxpYlsiQ29tcG9uZW50Il0pOwoKICAgIEJ1dHRvbl9kZWNvcmF0ZShbUHJvcCh7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgcmVxdWlyZWQ6IHRydWUKICAgIH0pLCBCdXR0b25fbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgU3RyaW5nKV0sIEJ1dHRvbl9CdXR0b24ucHJvdG90eXBlLCAidHlwZSIsIHZvaWQgMCk7CiAgICBCdXR0b25fZGVjb3JhdGUoW1Byb3AoewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIHJlcXVpcmVkOiB0cnVlCiAgICB9KSwgQnV0dG9uX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIFN0cmluZyldLCBCdXR0b25fQnV0dG9uLnByb3RvdHlwZSwgImljb24iLCB2b2lkIDApOwogICAgQnV0dG9uX0J1dHRvbiA9IEJ1dHRvbl9kZWNvcmF0ZShbdnVlX2NsYXNzX2NvbXBvbmVudF9jb21tb25fZGVmYXVsdC5hXSwgQnV0dG9uX0J1dHRvbik7CiAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovCgogICAgdmFyIGNvbXBvbmVudHNfQnV0dG9uID0gQnV0dG9uX0J1dHRvbjsgLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9AbW9lZmUvdnVlLWFwbGF5ZXIvY29tcG9uZW50cy9Qcm9ncmVzcy50c3gKCiAgICB2YXIgUHJvZ3Jlc3NfZGVjb3JhdGUgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7CiAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwKICAgICAgICAgIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLAogICAgICAgICAgZDsKICAgICAgaWYgKCh0eXBlb2YgUmVmbGVjdCA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2YoUmVmbGVjdCkpID09PSAib2JqZWN0IiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gImZ1bmN0aW9uIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO2Vsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByOwogICAgICB9CiAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7CiAgICB9OwoKICAgIHZhciBQcm9ncmVzc19tZXRhZGF0YSA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19tZXRhZGF0YSB8fCBmdW5jdGlvbiAoaywgdikgewogICAgICBpZiAoKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogX3R5cGVvZihSZWZsZWN0KSkgPT09ICJvYmplY3QiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSAiZnVuY3Rpb24iKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTsKICAgIH07CgogICAgdmFyIFByb2dyZXNzX2E7CgogICAgdmFyIFByb2dyZXNzX1Byb2dyZXNzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVnVlJENvbXBvbmVudCkgewogICAgICBfaW5oZXJpdHMoUHJvZ3Jlc3MsIF9WdWUkQ29tcG9uZW50KTsKCiAgICAgIGZ1bmN0aW9uIFByb2dyZXNzKCkgewogICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9ncmVzcyk7CgogICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUHJvZ3Jlc3MpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpOwogICAgICB9CgogICAgICBfY3JlYXRlQ2xhc3MoUHJvZ3Jlc3MsIFt7CiAgICAgICAga2V5OiAiaGFuZGxlQ2hhbmdlIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGUpIHsKICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLiRyZWZzLnByb2dyZXNzQmFyOwogICAgICAgICAgdmFyIHRhcmdldExlZnQgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDsKICAgICAgICAgIHZhciBjbGllbnRYID0gIWUudHlwZS5zdGFydHNXaXRoKCd0b3VjaCcpID8gZS5jbGllbnRYIDogZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYOwogICAgICAgICAgdmFyIG9mZnNldExlZnQgPSBjbGllbnRYIC0gdGFyZ2V0TGVmdDsKICAgICAgICAgIHZhciBwZXJjZW50ID0gb2Zmc2V0TGVmdCAvIHRhcmdldC5vZmZzZXRXaWR0aDsKICAgICAgICAgIHBlcmNlbnQgPSBNYXRoLm1pbihwZXJjZW50LCAxKTsKICAgICAgICAgIHBlcmNlbnQgPSBNYXRoLm1heChwZXJjZW50LCAwKTsKICAgICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlUHJvZ3Jlc3MoZSwgcGVyY2VudCk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAicmVuZGVyIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkgewogICAgICAgICAgdmFyIGggPSBhcmd1bWVudHNbMF07CiAgICAgICAgICB2YXIgX3RoaXMkYXBsYXllciA9IHRoaXMuYXBsYXllciwKICAgICAgICAgICAgICBjdXJyZW50VGhlbWUgPSBfdGhpcyRhcGxheWVyLmN1cnJlbnRUaGVtZSwKICAgICAgICAgICAgICBjdXJyZW50TG9hZGVkID0gX3RoaXMkYXBsYXllci5jdXJyZW50TG9hZGVkLAogICAgICAgICAgICAgIGN1cnJlbnRQbGF5ZWQgPSBfdGhpcyRhcGxheWVyLmN1cnJlbnRQbGF5ZWQ7CiAgICAgICAgICByZXR1cm4gaCh2dWVfdG91Y2gsIHsKICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItYmFyLXdyYXAiLAogICAgICAgICAgICBvbjogewogICAgICAgICAgICAgICJwYW5Nb3ZlIjogdGhpcy5oYW5kbGVDaGFuZ2UsCiAgICAgICAgICAgICAgInBhbkVuZCI6IHRoaXMuaGFuZGxlQ2hhbmdlCiAgICAgICAgICAgIH0KICAgICAgICAgIH0sIFtoKCJkaXYiLCB7CiAgICAgICAgICAgIHJlZjogInByb2dyZXNzQmFyIiwKICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItYmFyIgogICAgICAgICAgfSwgW2goImRpdiIsIHsKICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItbG9hZGVkIiwKICAgICAgICAgICAgc3R5bGU6IHsKICAgICAgICAgICAgICB3aWR0aDogIiIuY29uY2F0KGN1cnJlbnRMb2FkZWQgKiAxMDAsICIlIikKICAgICAgICAgICAgfQogICAgICAgICAgfSksIGgoImRpdiIsIHsKICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItcGxheWVkIiwKICAgICAgICAgICAgc3R5bGU6IHsKICAgICAgICAgICAgICB3aWR0aDogIiIuY29uY2F0KGN1cnJlbnRQbGF5ZWQgKiAxMDAsICIlIiksCiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjdXJyZW50VGhlbWUKICAgICAgICAgICAgfQogICAgICAgICAgfSwgW2goInNwYW4iLCB7CiAgICAgICAgICAgICJjbGFzcyI6ICJhcGxheWVyLXRodW1iIiwKICAgICAgICAgICAgc3R5bGU6IHsKICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGN1cnJlbnRUaGVtZQogICAgICAgICAgICB9CiAgICAgICAgICB9LCBbaCgic3BhbiIsIHsKICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItbG9hZGluZy1pY29uIgogICAgICAgICAgfSwgW2goY29tcG9uZW50c19JY29uLCB7CiAgICAgICAgICAgIGF0dHJzOiB7CiAgICAgICAgICAgICAgdHlwZTogImxvYWRpbmciCiAgICAgICAgICAgIH0KICAgICAgICAgIH0pXSldKV0pXSldKTsKICAgICAgICB9CiAgICAgIH1dKTsKCiAgICAgIHJldHVybiBQcm9ncmVzczsKICAgIH0obGliWyJDb21wb25lbnQiXSk7CgogICAgUHJvZ3Jlc3NfZGVjb3JhdGUoW0luamVjdCgpLCBQcm9ncmVzc19tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBPYmplY3QpXSwgUHJvZ3Jlc3NfUHJvZ3Jlc3MucHJvdG90eXBlLCAiYXBsYXllciIsIHZvaWQgMCk7CiAgICBQcm9ncmVzc19kZWNvcmF0ZShbSW5qZWN0KCksIFByb2dyZXNzX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIEZ1bmN0aW9uKV0sIFByb2dyZXNzX1Byb2dyZXNzLnByb3RvdHlwZSwgImhhbmRsZUNoYW5nZVByb2dyZXNzIiwgdm9pZCAwKTsKICAgIFByb2dyZXNzX1Byb2dyZXNzID0gUHJvZ3Jlc3NfZGVjb3JhdGUoW3Z1ZV9jbGFzc19jb21wb25lbnRfY29tbW9uX2RlZmF1bHQuYV0sIFByb2dyZXNzX1Byb2dyZXNzKTsKICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8KCiAgICB2YXIgY29tcG9uZW50c19Qcm9ncmVzcyA9IFByb2dyZXNzX1Byb2dyZXNzOyAvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL0Btb2VmZS92dWUtYXBsYXllci9jb21wb25lbnRzL0NvbnRyb2xsZXIudHN4CgogICAgdmFyIENvbnRyb2xsZXJfZGVjb3JhdGUgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7CiAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwKICAgICAgICAgIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLAogICAgICAgICAgZDsKICAgICAgaWYgKCh0eXBlb2YgUmVmbGVjdCA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2YoUmVmbGVjdCkpID09PSAib2JqZWN0IiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gImZ1bmN0aW9uIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO2Vsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByOwogICAgICB9CiAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7CiAgICB9OwoKICAgIHZhciBDb250cm9sbGVyX21ldGFkYXRhID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX21ldGFkYXRhIHx8IGZ1bmN0aW9uIChrLCB2KSB7CiAgICAgIGlmICgodHlwZW9mIFJlZmxlY3QgPT09ICJ1bmRlZmluZWQiID8gInVuZGVmaW5lZCIgOiBfdHlwZW9mKFJlZmxlY3QpKSA9PT0gIm9iamVjdCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09ICJmdW5jdGlvbiIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpOwogICAgfTsKCiAgICB2YXIgQ29udHJvbGxlcl9hOwoKICAgIHZhciBDb250cm9sbGVyX0NvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9WdWUkQ29tcG9uZW50KSB7CiAgICAgIF9pbmhlcml0cyhDb250cm9sbGVyLCBfVnVlJENvbXBvbmVudCk7CgogICAgICBmdW5jdGlvbiBDb250cm9sbGVyKCkgewogICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250cm9sbGVyKTsKCiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihDb250cm9sbGVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsKICAgICAgfQoKICAgICAgX2NyZWF0ZUNsYXNzKENvbnRyb2xsZXIsIFt7CiAgICAgICAga2V5OiAidGltZVNlY29uZHNGb3JtYXQiLAogICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVTZWNvbmRzRm9ybWF0KCkgewogICAgICAgICAgdmFyIHRpbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7CiAgICAgICAgICB2YXIgbWludXRlcyA9IE1hdGguZmxvb3IodGltZSAvIDYwKSB8fCAwOwogICAgICAgICAgdmFyIHNlY29uZHMgPSBNYXRoLmZsb29yKHRpbWUgJSA2MCkgfHwgMDsKICAgICAgICAgIHJldHVybiAiIi5jb25jYXQobWludXRlcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyksICI6IikuY29uY2F0KHNlY29uZHMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpKTsgLy8gcHJldHRpZXItaWdub3JlCiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlVG9nZ2xlVm9sdW1lIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVG9nZ2xlVm9sdW1lKCkgewogICAgICAgICAgdmFyIF90aGlzJGFwbGF5ZXIgPSB0aGlzLmFwbGF5ZXIsCiAgICAgICAgICAgICAgY3VycmVudFZvbHVtZSA9IF90aGlzJGFwbGF5ZXIuY3VycmVudFZvbHVtZSwKICAgICAgICAgICAgICBjdXJyZW50U2V0dGluZ3MgPSBfdGhpcyRhcGxheWVyLmN1cnJlbnRTZXR0aW5nczsKICAgICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlVm9sdW1lKGN1cnJlbnRWb2x1bWUgPiAwID8gMCA6IGN1cnJlbnRTZXR0aW5ncy52b2x1bWUpOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogImhhbmRsZUNsaWNrVm9sdW1lQmFyIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2xpY2tWb2x1bWVCYXIoZSkgewogICAgICAgICAgdGhpcy5oYW5kbGVQYW5Nb3ZlKGUpOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogImhhbmRsZVBhbk1vdmUiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVQYW5Nb3ZlKGUpIHsKICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLiRyZWZzLnZvbHVtZUJhcjsKICAgICAgICAgIHZhciB0YXJnZXRUb3AgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tOwogICAgICAgICAgaWYgKHRhcmdldFRvcCA8PSAwKSByZXR1cm47IC8vIOmfs+mHj+aOp+WItumdouadv+W3sumakOiXjwoKICAgICAgICAgIHZhciBjbGllbnRZID0gIWUudHlwZS5zdGFydHNXaXRoKCd0b3VjaCcpID8gZS5jbGllbnRZIDogZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZOwogICAgICAgICAgdmFyIG9mZnNldFRvcCA9IE1hdGgucm91bmQodGFyZ2V0VG9wIC0gY2xpZW50WSk7CiAgICAgICAgICB2YXIgdm9sdW1lID0gb2Zmc2V0VG9wIC8gdGFyZ2V0Lm9mZnNldEhlaWdodDsKICAgICAgICAgIHZvbHVtZSA9IE1hdGgubWluKHZvbHVtZSwgMSk7CiAgICAgICAgICB2b2x1bWUgPSBNYXRoLm1heCh2b2x1bWUsIDApOwogICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2VWb2x1bWUodm9sdW1lKTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJyZW5kZXIiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7CiAgICAgICAgICB2YXIgaCA9IGFyZ3VtZW50c1swXTsKICAgICAgICAgIHZhciBwdGltZSA9IHRoaXMucHRpbWUsCiAgICAgICAgICAgICAgZHRpbWUgPSB0aGlzLmR0aW1lLAogICAgICAgICAgICAgIHZvbHVtZUljb24gPSB0aGlzLnZvbHVtZUljb247CiAgICAgICAgICB2YXIgX3RoaXMkYXBsYXllcjIgPSB0aGlzLmFwbGF5ZXIsCiAgICAgICAgICAgICAgbHJjVHlwZSA9IF90aGlzJGFwbGF5ZXIyLmxyY1R5cGUsCiAgICAgICAgICAgICAgY3VycmVudFRoZW1lID0gX3RoaXMkYXBsYXllcjIuY3VycmVudFRoZW1lLAogICAgICAgICAgICAgIGN1cnJlbnRWb2x1bWUgPSBfdGhpcyRhcGxheWVyMi5jdXJyZW50Vm9sdW1lLAogICAgICAgICAgICAgIGN1cnJlbnRPcmRlciA9IF90aGlzJGFwbGF5ZXIyLmN1cnJlbnRPcmRlciwKICAgICAgICAgICAgICBjdXJyZW50TG9vcCA9IF90aGlzJGFwbGF5ZXIyLmN1cnJlbnRMb29wOwogICAgICAgICAgcmV0dXJuIGgoImRpdiIsIHsKICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItY29udHJvbGxlciIKICAgICAgICAgIH0sIFtoKGNvbXBvbmVudHNfUHJvZ3Jlc3MpLCBoKCJkaXYiLCB7CiAgICAgICAgICAgICJjbGFzcyI6ICJhcGxheWVyLXRpbWUiCiAgICAgICAgICB9LCBbaCgic3BhbiIsIHsKICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItdGltZS1pbm5lciIKICAgICAgICAgIH0sIFtoKCJzcGFuIiwgewogICAgICAgICAgICAiY2xhc3MiOiAiYXBsYXllci1wdGltZSIKICAgICAgICAgIH0sIFtwdGltZV0pLCAiIC8iLCAnICcsIGgoInNwYW4iLCB7CiAgICAgICAgICAgICJjbGFzcyI6ICJhcGxheWVyLWR0aW1lIgogICAgICAgICAgfSwgW2R0aW1lXSksICcgJ10pLCBoKCJzcGFuIiwgewogICAgICAgICAgICAiY2xhc3MiOiAiYXBsYXllci1pY29uIGFwbGF5ZXItaWNvbi1iYWNrIiwKICAgICAgICAgICAgb246IHsKICAgICAgICAgICAgICAiY2xpY2siOiB0aGlzLmhhbmRsZVNraXBCYWNrCiAgICAgICAgICAgIH0KICAgICAgICAgIH0sIFtoKGNvbXBvbmVudHNfSWNvbiwgewogICAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAgIHR5cGU6ICJza2lwIgogICAgICAgICAgICB9CiAgICAgICAgICB9KV0pLCBoKCJzcGFuIiwgewogICAgICAgICAgICAiY2xhc3MiOiAiYXBsYXllci1pY29uIGFwbGF5ZXItaWNvbi1wbGF5IiwKICAgICAgICAgICAgb246IHsKICAgICAgICAgICAgICAiY2xpY2siOiB0aGlzLmhhbmRsZVRvZ2dsZVBsYXkKICAgICAgICAgICAgfQogICAgICAgICAgfSwgW2goY29tcG9uZW50c19JY29uLCB7CiAgICAgICAgICAgIGF0dHJzOiB7CiAgICAgICAgICAgICAgdHlwZTogdGhpcy5wbGF5SWNvbgogICAgICAgICAgICB9CiAgICAgICAgICB9KV0pLCBoKCJzcGFuIiwgewogICAgICAgICAgICAiY2xhc3MiOiAiYXBsYXllci1pY29uIGFwbGF5ZXItaWNvbi1mb3J3YXJkIiwKICAgICAgICAgICAgb246IHsKICAgICAgICAgICAgICAiY2xpY2siOiB0aGlzLmhhbmRsZVNraXBGb3J3YXJkCiAgICAgICAgICAgIH0KICAgICAgICAgIH0sIFtoKGNvbXBvbmVudHNfSWNvbiwgewogICAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAgIHR5cGU6ICJza2lwIgogICAgICAgICAgICB9CiAgICAgICAgICB9KV0pLCBoKCJkaXYiLCB7CiAgICAgICAgICAgICJjbGFzcyI6ICJhcGxheWVyLXZvbHVtZS13cmFwIgogICAgICAgICAgfSwgW2goY29tcG9uZW50c19CdXR0b24sIHsKICAgICAgICAgICAgYXR0cnM6IHsKICAgICAgICAgICAgICB0eXBlOiAidm9sdW1lLSIuY29uY2F0KHZvbHVtZUljb24pLAogICAgICAgICAgICAgIGljb246ICJ2b2x1bWUtIi5jb25jYXQodm9sdW1lSWNvbikKICAgICAgICAgICAgfSwKICAgICAgICAgICAgb246IHsKICAgICAgICAgICAgICAiY2xpY2siOiB0aGlzLmhhbmRsZVRvZ2dsZVZvbHVtZQogICAgICAgICAgICB9CiAgICAgICAgICB9KSwgaCh2dWVfdG91Y2gsIHsKICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItdm9sdW1lLWJhci13cmFwIiwKICAgICAgICAgICAgYXR0cnM6IHsKICAgICAgICAgICAgICBwYW5Nb3ZlQ2xhc3M6ICJhcGxheWVyLXZvbHVtZS1iYXItd3JhcC1hY3RpdmUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG9uOiB7CiAgICAgICAgICAgICAgInBhbk1vdmUiOiB0aGlzLmhhbmRsZVBhbk1vdmUKICAgICAgICAgICAgfQogICAgICAgICAgfSwgW2goImRpdiIsIHsKICAgICAgICAgICAgcmVmOiAidm9sdW1lQmFyIiwKICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItdm9sdW1lLWJhciIsCiAgICAgICAgICAgIG9uOiB7CiAgICAgICAgICAgICAgImNsaWNrIjogdGhpcy5oYW5kbGVDbGlja1ZvbHVtZUJhcgogICAgICAgICAgICB9CiAgICAgICAgICB9LCBbaCgiZGl2IiwgewogICAgICAgICAgICAiY2xhc3MiOiAiYXBsYXllci12b2x1bWUiLAogICAgICAgICAgICBzdHlsZTogewogICAgICAgICAgICAgIGhlaWdodDogIiIuY29uY2F0KGN1cnJlbnRWb2x1bWUgKiAxMDAsICIlIiksCiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjdXJyZW50VGhlbWUKICAgICAgICAgICAgfQogICAgICAgICAgfSldKV0pXSksICcgJywgaChjb21wb25lbnRzX0J1dHRvbiwgewogICAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAgIHR5cGU6ICJvcmRlciIsCiAgICAgICAgICAgICAgaWNvbjogIm9yZGVyLSIuY29uY2F0KGN1cnJlbnRPcmRlcikKICAgICAgICAgICAgfSwKICAgICAgICAgICAgb246IHsKICAgICAgICAgICAgICAiY2xpY2siOiB0aGlzLmhhbmRsZVRvZ2dsZU9yZGVyTW9kZQogICAgICAgICAgICB9CiAgICAgICAgICB9KSwgJyAnLCBoKGNvbXBvbmVudHNfQnV0dG9uLCB7CiAgICAgICAgICAgIGF0dHJzOiB7CiAgICAgICAgICAgICAgdHlwZTogImxvb3AiLAogICAgICAgICAgICAgIGljb246ICJsb29wLSIuY29uY2F0KGN1cnJlbnRMb29wKQogICAgICAgICAgICB9LAogICAgICAgICAgICBvbjogewogICAgICAgICAgICAgICJjbGljayI6IHRoaXMuaGFuZGxlVG9nZ2xlTG9vcE1vZGUKICAgICAgICAgICAgfQogICAgICAgICAgfSksICcgJywgaChjb21wb25lbnRzX0J1dHRvbiwgewogICAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAgIHR5cGU6ICJtZW51IiwKICAgICAgICAgICAgICBpY29uOiAibWVudSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgb246IHsKICAgICAgICAgICAgICAiY2xpY2siOiB0aGlzLmhhbmRsZVRvZ2dsZVBsYXlsaXN0CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pLCBscmNUeXBlICE9PSAwID8gaChjb21wb25lbnRzX0J1dHRvbiwgewogICAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAgIHR5cGU6ICJscmMiLAogICAgICAgICAgICAgIGljb246ICJscmMiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG9uOiB7CiAgICAgICAgICAgICAgImNsaWNrIjogdGhpcy5oYW5kbGVUb2dnbGVMeXJpYwogICAgICAgICAgICB9CiAgICAgICAgICB9KSA6IG51bGxdKV0pOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogInBsYXlJY29uIiwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmFwbGF5ZXIubWVkaWEucGF1c2VkID8gJ3BsYXknIDogJ3BhdXNlJzsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJ2b2x1bWVJY29uIiwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHZhciBjdXJyZW50Vm9sdW1lID0gdGhpcy5hcGxheWVyLmN1cnJlbnRWb2x1bWU7CiAgICAgICAgICByZXR1cm4gY3VycmVudFZvbHVtZSA8PSAwID8gJ29mZicgOiBjdXJyZW50Vm9sdW1lID49IDAuOTUgPyAndXAnIDogJ2Rvd24nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAicHRpbWUiLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgdmFyIF90aGlzJGFwbGF5ZXIzID0gdGhpcy5hcGxheWVyLAogICAgICAgICAgICAgIG1lZGlhID0gX3RoaXMkYXBsYXllcjMubWVkaWEsCiAgICAgICAgICAgICAgY3VycmVudFBsYXllZCA9IF90aGlzJGFwbGF5ZXIzLmN1cnJlbnRQbGF5ZWQ7CiAgICAgICAgICByZXR1cm4gdGhpcy50aW1lU2Vjb25kc0Zvcm1hdChjdXJyZW50UGxheWVkICogbWVkaWEuZHVyYXRpb24pOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogImR0aW1lIiwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLnRpbWVTZWNvbmRzRm9ybWF0KHRoaXMuYXBsYXllci5tZWRpYS5kdXJhdGlvbik7CiAgICAgICAgfQogICAgICB9XSk7CgogICAgICByZXR1cm4gQ29udHJvbGxlcjsKICAgIH0obGliWyJDb21wb25lbnQiXSk7CgogICAgQ29udHJvbGxlcl9kZWNvcmF0ZShbSW5qZWN0KCksIENvbnRyb2xsZXJfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgT2JqZWN0KV0sIENvbnRyb2xsZXJfQ29udHJvbGxlci5wcm90b3R5cGUsICJhcGxheWVyIiwgdm9pZCAwKTsKICAgIENvbnRyb2xsZXJfZGVjb3JhdGUoW0luamVjdCgpLCBDb250cm9sbGVyX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIEZ1bmN0aW9uKV0sIENvbnRyb2xsZXJfQ29udHJvbGxlci5wcm90b3R5cGUsICJoYW5kbGVTa2lwQmFjayIsIHZvaWQgMCk7CiAgICBDb250cm9sbGVyX2RlY29yYXRlKFtJbmplY3QoKSwgQ29udHJvbGxlcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbildLCBDb250cm9sbGVyX0NvbnRyb2xsZXIucHJvdG90eXBlLCAiaGFuZGxlU2tpcEZvcndhcmQiLCB2b2lkIDApOwogICAgQ29udHJvbGxlcl9kZWNvcmF0ZShbSW5qZWN0KCksIENvbnRyb2xsZXJfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgRnVuY3Rpb24pXSwgQ29udHJvbGxlcl9Db250cm9sbGVyLnByb3RvdHlwZSwgImhhbmRsZVRvZ2dsZVBsYXkiLCB2b2lkIDApOwogICAgQ29udHJvbGxlcl9kZWNvcmF0ZShbSW5qZWN0KCksIENvbnRyb2xsZXJfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgRnVuY3Rpb24pXSwgQ29udHJvbGxlcl9Db250cm9sbGVyLnByb3RvdHlwZSwgImhhbmRsZVRvZ2dsZU9yZGVyTW9kZSIsIHZvaWQgMCk7CiAgICBDb250cm9sbGVyX2RlY29yYXRlKFtJbmplY3QoKSwgQ29udHJvbGxlcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbildLCBDb250cm9sbGVyX0NvbnRyb2xsZXIucHJvdG90eXBlLCAiaGFuZGxlVG9nZ2xlTG9vcE1vZGUiLCB2b2lkIDApOwogICAgQ29udHJvbGxlcl9kZWNvcmF0ZShbSW5qZWN0KCksIENvbnRyb2xsZXJfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgRnVuY3Rpb24pXSwgQ29udHJvbGxlcl9Db250cm9sbGVyLnByb3RvdHlwZSwgImhhbmRsZVRvZ2dsZVBsYXlsaXN0Iiwgdm9pZCAwKTsKICAgIENvbnRyb2xsZXJfZGVjb3JhdGUoW0luamVjdCgpLCBDb250cm9sbGVyX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIEZ1bmN0aW9uKV0sIENvbnRyb2xsZXJfQ29udHJvbGxlci5wcm90b3R5cGUsICJoYW5kbGVUb2dnbGVMeXJpYyIsIHZvaWQgMCk7CiAgICBDb250cm9sbGVyX2RlY29yYXRlKFtJbmplY3QoKSwgQ29udHJvbGxlcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbildLCBDb250cm9sbGVyX0NvbnRyb2xsZXIucHJvdG90eXBlLCAiaGFuZGxlQ2hhbmdlVm9sdW1lIiwgdm9pZCAwKTsKICAgIENvbnRyb2xsZXJfQ29udHJvbGxlciA9IENvbnRyb2xsZXJfZGVjb3JhdGUoW3Z1ZV9jbGFzc19jb21wb25lbnRfY29tbW9uX2RlZmF1bHQuYV0sIENvbnRyb2xsZXJfQ29udHJvbGxlcik7CiAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovCgogICAgdmFyIGNvbXBvbmVudHNfQ29udHJvbGxlciA9IENvbnRyb2xsZXJfQ29udHJvbGxlcjsgLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9AbW9lZmUvdnVlLWFwbGF5ZXIvY29tcG9uZW50cy9QbGF5ZXIudHN4CgogICAgdmFyIFBsYXllcl9kZWNvcmF0ZSA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHsKICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLAogICAgICAgICAgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsCiAgICAgICAgICBkOwogICAgICBpZiAoKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogX3R5cGVvZihSZWZsZWN0KSkgPT09ICJvYmplY3QiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSAiZnVuY3Rpb24iKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7ZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7CiAgICAgIH0KICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjsKICAgIH07CgogICAgdmFyIFBsYXllcl9tZXRhZGF0YSA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19tZXRhZGF0YSB8fCBmdW5jdGlvbiAoaywgdikgewogICAgICBpZiAoKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogX3R5cGVvZihSZWZsZWN0KSkgPT09ICJvYmplY3QiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSAiZnVuY3Rpb24iKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTsKICAgIH07CgogICAgdmFyIFBsYXllcl9hLCBQbGF5ZXJfYjsKCiAgICB2YXIgUGxheWVyX1BsYXllciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Z1ZSRDb21wb25lbnQpIHsKICAgICAgX2luaGVyaXRzKFBsYXllciwgX1Z1ZSRDb21wb25lbnQpOwoKICAgICAgZnVuY3Rpb24gUGxheWVyKCkgewogICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5ZXIpOwoKICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFBsYXllcikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7CiAgICAgIH0KCiAgICAgIF9jcmVhdGVDbGFzcyhQbGF5ZXIsIFt7CiAgICAgICAga2V5OiAiaGFuZGxlVG9nZ2xlUGxheSIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVRvZ2dsZVBsYXkoKSB7CiAgICAgICAgICB0aGlzLiRlbWl0KCd0b2dnbGVQbGF5Jyk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlU2tpcEJhY2siLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVTa2lwQmFjaygpIHsKICAgICAgICAgIHRoaXMuJGVtaXQoJ3NraXBCYWNrJyk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlU2tpcEZvcndhcmQiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVTa2lwRm9yd2FyZCgpIHsKICAgICAgICAgIHRoaXMuJGVtaXQoJ3NraXBGb3J3YXJkJyk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlVG9nZ2xlT3JkZXJNb2RlIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVG9nZ2xlT3JkZXJNb2RlKCkgewogICAgICAgICAgdGhpcy4kZW1pdCgndG9nZ2xlT3JkZXJNb2RlJyk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlVG9nZ2xlTG9vcE1vZGUiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUb2dnbGVMb29wTW9kZSgpIHsKICAgICAgICAgIHRoaXMuJGVtaXQoJ3RvZ2dsZUxvb3BNb2RlJyk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlVG9nZ2xlUGxheWxpc3QiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUb2dnbGVQbGF5bGlzdCgpIHsKICAgICAgICAgIHRoaXMuJGVtaXQoJ3RvZ2dsZVBsYXlsaXN0Jyk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlVG9nZ2xlTHlyaWMiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUb2dnbGVMeXJpYygpIHsKICAgICAgICAgIHRoaXMuJGVtaXQoJ3RvZ2dsZUx5cmljJyk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlQ2hhbmdlVm9sdW1lIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hhbmdlVm9sdW1lKHZvbHVtZSkgewogICAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlVm9sdW1lJywgdm9sdW1lKTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJoYW5kbGVDaGFuZ2VQcm9ncmVzcyIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZVByb2dyZXNzKGUsIHBlcmNlbnQpIHsKICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZVByb2dyZXNzJywgZSwgcGVyY2VudCk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlTWluaVN3aXRjaGVyIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTWluaVN3aXRjaGVyKCkgewogICAgICAgICAgdGhpcy4kZW1pdCgnbWluaVN3aXRjaGVyJyk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAicmVuZGVyIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkgewogICAgICAgICAgdmFyIGggPSBhcmd1bWVudHNbMF07CiAgICAgICAgICB2YXIgcGxheUljb24gPSB0aGlzLnBsYXlJY29uLAogICAgICAgICAgICAgIG5vdGljZSA9IHRoaXMubm90aWNlOwogICAgICAgICAgcmV0dXJuIGgoImRpdiIsIHsKICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItYm9keSIKICAgICAgICAgIH0sIFtoKGNvbXBvbmVudHNfQ292ZXIsIHsKICAgICAgICAgICAgb246IHsKICAgICAgICAgICAgICAiY2xpY2siOiB0aGlzLmhhbmRsZVRvZ2dsZVBsYXkKICAgICAgICAgICAgfQogICAgICAgICAgfSwgW2goImRpdiIsIHsKICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItYnV0dG9uIGFwbGF5ZXItIi5jb25jYXQocGxheUljb24pCiAgICAgICAgICB9LCBbaChjb21wb25lbnRzX0ljb24sIHsKICAgICAgICAgICAgYXR0cnM6IHsKICAgICAgICAgICAgICB0eXBlOiBwbGF5SWNvbgogICAgICAgICAgICB9CiAgICAgICAgICB9KV0pXSksIGgoY29tcG9uZW50c19NYWluLCBbaChjb21wb25lbnRzX0NvbnRyb2xsZXIsIHsKICAgICAgICAgICAgb246IHsKICAgICAgICAgICAgICAic2tpcEJhY2siOiB0aGlzLmhhbmRsZVNraXBCYWNrLAogICAgICAgICAgICAgICJza2lwRm9yd2FyZCI6IHRoaXMuaGFuZGxlU2tpcEZvcndhcmQsCiAgICAgICAgICAgICAgInRvZ2dsZVBsYXkiOiB0aGlzLmhhbmRsZVRvZ2dsZVBsYXksCiAgICAgICAgICAgICAgInRvZ2dsZU9yZGVyTW9kZSI6IHRoaXMuaGFuZGxlVG9nZ2xlT3JkZXJNb2RlLAogICAgICAgICAgICAgICJ0b2dnbGVMb29wTW9kZSI6IHRoaXMuaGFuZGxlVG9nZ2xlTG9vcE1vZGUsCiAgICAgICAgICAgICAgInRvZ2dsZVBsYXlsaXN0IjogdGhpcy5oYW5kbGVUb2dnbGVQbGF5bGlzdCwKICAgICAgICAgICAgICAidG9nZ2xlTHlyaWMiOiB0aGlzLmhhbmRsZVRvZ2dsZUx5cmljLAogICAgICAgICAgICAgICJjaGFuZ2VWb2x1bWUiOiB0aGlzLmhhbmRsZUNoYW5nZVZvbHVtZSwKICAgICAgICAgICAgICAiY2hhbmdlUHJvZ3Jlc3MiOiB0aGlzLmhhbmRsZUNoYW5nZVByb2dyZXNzCiAgICAgICAgICAgIH0KICAgICAgICAgIH0pXSksIGgoImRpdiIsIHsKICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItbm90aWNlIiwKICAgICAgICAgICAgc3R5bGU6IHsKICAgICAgICAgICAgICBvcGFjaXR5OiBub3RpY2Uub3BhY2l0eQogICAgICAgICAgICB9CiAgICAgICAgICB9LCBbbm90aWNlLnRleHRdKSwgaCgiZGl2IiwgewogICAgICAgICAgICAiY2xhc3MiOiAiYXBsYXllci1taW5pc3dpdGNoZXIiLAogICAgICAgICAgICBvbjogewogICAgICAgICAgICAgICJjbGljayI6IHRoaXMuaGFuZGxlTWluaVN3aXRjaGVyCiAgICAgICAgICAgIH0KICAgICAgICAgIH0sIFtoKGNvbXBvbmVudHNfQnV0dG9uLCB7CiAgICAgICAgICAgIGF0dHJzOiB7CiAgICAgICAgICAgICAgdHlwZTogIm1pbmlzd2l0Y2hlciIsCiAgICAgICAgICAgICAgaWNvbjogInJpZ2h0IgogICAgICAgICAgICB9CiAgICAgICAgICB9KV0pXSk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAicGxheUljb24iLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuYXBsYXllci5tZWRpYS5wYXVzZWQgPyAncGxheScgOiAncGF1c2UnOwogICAgICAgIH0KICAgICAgfV0pOwoKICAgICAgcmV0dXJuIFBsYXllcjsKICAgIH0obGliWyJDb21wb25lbnQiXSk7CgogICAgUGxheWVyX2RlY29yYXRlKFtQcm9wKHsKICAgICAgdHlwZTogT2JqZWN0LAogICAgICByZXF1aXJlZDogdHJ1ZQogICAgfSksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBPYmplY3QpXSwgUGxheWVyX1BsYXllci5wcm90b3R5cGUsICJub3RpY2UiLCB2b2lkIDApOwogICAgUGxheWVyX2RlY29yYXRlKFtJbmplY3QoKSwgUGxheWVyX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIE9iamVjdCldLCBQbGF5ZXJfUGxheWVyLnByb3RvdHlwZSwgImFwbGF5ZXIiLCB2b2lkIDApOwogICAgUGxheWVyX2RlY29yYXRlKFtQcm92aWRlKCksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbiksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnBhcmFtdHlwZXMiLCBbXSksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnJldHVybnR5cGUiLCB2b2lkIDApXSwgUGxheWVyX1BsYXllci5wcm90b3R5cGUsICJoYW5kbGVUb2dnbGVQbGF5IiwgbnVsbCk7CiAgICBQbGF5ZXJfZGVjb3JhdGUoW1Byb3ZpZGUoKSwgUGxheWVyX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIEZ1bmN0aW9uKSwgUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cGFyYW10eXBlcyIsIFtdKSwgUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cmV0dXJudHlwZSIsIHZvaWQgMCldLCBQbGF5ZXJfUGxheWVyLnByb3RvdHlwZSwgImhhbmRsZVNraXBCYWNrIiwgbnVsbCk7CiAgICBQbGF5ZXJfZGVjb3JhdGUoW1Byb3ZpZGUoKSwgUGxheWVyX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIEZ1bmN0aW9uKSwgUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cGFyYW10eXBlcyIsIFtdKSwgUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cmV0dXJudHlwZSIsIHZvaWQgMCldLCBQbGF5ZXJfUGxheWVyLnByb3RvdHlwZSwgImhhbmRsZVNraXBGb3J3YXJkIiwgbnVsbCk7CiAgICBQbGF5ZXJfZGVjb3JhdGUoW1Byb3ZpZGUoKSwgUGxheWVyX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIEZ1bmN0aW9uKSwgUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cGFyYW10eXBlcyIsIFtdKSwgUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cmV0dXJudHlwZSIsIHZvaWQgMCldLCBQbGF5ZXJfUGxheWVyLnByb3RvdHlwZSwgImhhbmRsZVRvZ2dsZU9yZGVyTW9kZSIsIG51bGwpOwogICAgUGxheWVyX2RlY29yYXRlKFtQcm92aWRlKCksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbiksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnBhcmFtdHlwZXMiLCBbXSksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnJldHVybnR5cGUiLCB2b2lkIDApXSwgUGxheWVyX1BsYXllci5wcm90b3R5cGUsICJoYW5kbGVUb2dnbGVMb29wTW9kZSIsIG51bGwpOwogICAgUGxheWVyX2RlY29yYXRlKFtQcm92aWRlKCksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbiksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnBhcmFtdHlwZXMiLCBbXSksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnJldHVybnR5cGUiLCB2b2lkIDApXSwgUGxheWVyX1BsYXllci5wcm90b3R5cGUsICJoYW5kbGVUb2dnbGVQbGF5bGlzdCIsIG51bGwpOwogICAgUGxheWVyX2RlY29yYXRlKFtQcm92aWRlKCksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbiksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnBhcmFtdHlwZXMiLCBbXSksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnJldHVybnR5cGUiLCB2b2lkIDApXSwgUGxheWVyX1BsYXllci5wcm90b3R5cGUsICJoYW5kbGVUb2dnbGVMeXJpYyIsIG51bGwpOwogICAgUGxheWVyX2RlY29yYXRlKFtQcm92aWRlKCksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbiksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnBhcmFtdHlwZXMiLCBbTnVtYmVyXSksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnJldHVybnR5cGUiLCB2b2lkIDApXSwgUGxheWVyX1BsYXllci5wcm90b3R5cGUsICJoYW5kbGVDaGFuZ2VWb2x1bWUiLCBudWxsKTsKICAgIFBsYXllcl9kZWNvcmF0ZShbUHJvdmlkZSgpLCBQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgRnVuY3Rpb24pLCBQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjpwYXJhbXR5cGVzIiwgW09iamVjdCwgTnVtYmVyXSksIFBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnJldHVybnR5cGUiLCB2b2lkIDApXSwgUGxheWVyX1BsYXllci5wcm90b3R5cGUsICJoYW5kbGVDaGFuZ2VQcm9ncmVzcyIsIG51bGwpOwogICAgUGxheWVyX1BsYXllciA9IFBsYXllcl9kZWNvcmF0ZShbdnVlX2NsYXNzX2NvbXBvbmVudF9jb21tb25fZGVmYXVsdC5hXSwgUGxheWVyX1BsYXllcik7CiAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovCgogICAgdmFyIGNvbXBvbmVudHNfUGxheWVyID0gUGxheWVyX1BsYXllcjsgLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9AbW9lZmUvdnVlLWFwbGF5ZXIvY29tcG9uZW50cy9QbGF5TGlzdC50c3gKCiAgICB2YXIgUGxheUxpc3RfZGVjb3JhdGUgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7CiAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwKICAgICAgICAgIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLAogICAgICAgICAgZDsKICAgICAgaWYgKCh0eXBlb2YgUmVmbGVjdCA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2YoUmVmbGVjdCkpID09PSAib2JqZWN0IiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gImZ1bmN0aW9uIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO2Vsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByOwogICAgICB9CiAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7CiAgICB9OwoKICAgIHZhciBQbGF5TGlzdF9tZXRhZGF0YSA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19tZXRhZGF0YSB8fCBmdW5jdGlvbiAoaywgdikgewogICAgICBpZiAoKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogX3R5cGVvZihSZWZsZWN0KSkgPT09ICJvYmplY3QiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSAiZnVuY3Rpb24iKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTsKICAgIH07CgogICAgdmFyIFBsYXlMaXN0X2EsIFBsYXlMaXN0X2IsIF9jOwoKICAgIHZhciBQbGF5TGlzdF9QbGF5TGlzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Z1ZSRDb21wb25lbnQpIHsKICAgICAgX2luaGVyaXRzKFBsYXlMaXN0LCBfVnVlJENvbXBvbmVudCk7CgogICAgICBmdW5jdGlvbiBQbGF5TGlzdCgpIHsKICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxheUxpc3QpOwoKICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFBsYXlMaXN0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsKICAgICAgfQoKICAgICAgX2NyZWF0ZUNsYXNzKFBsYXlMaXN0LCBbewogICAgICAgIGtleTogImhhbmRsZUNoYW5nZVNjcm9sbFRvcCIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHZhciBfaGFuZGxlQ2hhbmdlU2Nyb2xsVG9wID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkgewogICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHsKICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkgewogICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG5leHRUaWNrKCk7CgogICAgICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkgewogICAgICAgICAgICAgICAgICAgICAgdGhpcy4kcmVmcy5saXN0LnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsVG9wOwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7CiAgICAgICAgICB9KSk7CgogICAgICAgICAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlU2Nyb2xsVG9wKCkgewogICAgICAgICAgICByZXR1cm4gX2hhbmRsZUNoYW5nZVNjcm9sbFRvcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiBoYW5kbGVDaGFuZ2VTY3JvbGxUb3A7CiAgICAgICAgfSgpCiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJyZW5kZXIiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7CiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzOwoKICAgICAgICAgIHZhciBoID0gYXJndW1lbnRzWzBdOwogICAgICAgICAgdmFyIGxpc3RIZWlnaHQgPSB0aGlzLmxpc3RIZWlnaHQsCiAgICAgICAgICAgICAgZGF0YVNvdXJjZSA9IHRoaXMuZGF0YVNvdXJjZSwKICAgICAgICAgICAgICBjdXJyZW50TXVzaWMgPSB0aGlzLmN1cnJlbnRNdXNpYzsKICAgICAgICAgIHZhciBjdXJyZW50VGhlbWUgPSB0aGlzLmFwbGF5ZXIuY3VycmVudFRoZW1lOwogICAgICAgICAgcmV0dXJuIGgoIm9sIiwgewogICAgICAgICAgICByZWY6ICJsaXN0IiwKICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItbGlzdCIsCiAgICAgICAgICAgIHN0eWxlOiB7CiAgICAgICAgICAgICAgaGVpZ2h0OiAiIi5jb25jYXQobGlzdEhlaWdodCwgInB4IikKICAgICAgICAgICAgfQogICAgICAgICAgfSwgW2RhdGFTb3VyY2UubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkgewogICAgICAgICAgICByZXR1cm4gaCgibGkiLCB7CiAgICAgICAgICAgICAga2V5OiBpdGVtLmlkLAogICAgICAgICAgICAgICJjbGFzcyI6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKHsKICAgICAgICAgICAgICAgICdhcGxheWVyLWxpc3QtbGlnaHQnOiBpdGVtLmlkID09PSBjdXJyZW50TXVzaWMuaWQKICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgICBvbjogewogICAgICAgICAgICAgICAgImNsaWNrIjogZnVuY3Rpb24gY2xpY2soKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kZW1pdCgnY2hhbmdlJywgaXRlbSwgaW5kZXgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwgW2goInNwYW4iLCB7CiAgICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItbGlzdC1jdXIiLAogICAgICAgICAgICAgIHN0eWxlOiB7CiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGN1cnJlbnRUaGVtZQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSksIGgoInNwYW4iLCB7CiAgICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItbGlzdC1pbmRleCIKICAgICAgICAgICAgfSwgW2luZGV4ICsgMV0pLCAnICcsIGgoInNwYW4iLCB7CiAgICAgICAgICAgICAgImNsYXNzIjogImFwbGF5ZXItbGlzdC10aXRsZSIKICAgICAgICAgICAgfSwgW2l0ZW0ubmFtZV0pLCBoKCJzcGFuIiwgewogICAgICAgICAgICAgICJjbGFzcyI6ICJhcGxheWVyLWxpc3QtYXV0aG9yIgogICAgICAgICAgICB9LCBbaXRlbS5hcnRpc3RdKV0pOwogICAgICAgICAgfSldKTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJsaXN0SGVpZ2h0IiwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHZhciB2aXNpYmxlID0gdGhpcy52aXNpYmxlLAogICAgICAgICAgICAgIGRhdGFTb3VyY2UgPSB0aGlzLmRhdGFTb3VyY2U7CiAgICAgICAgICByZXR1cm4gdmlzaWJsZSA/IE1hdGgubWluKGRhdGFTb3VyY2UubGVuZ3RoICogMzMsIE51bWJlcih0aGlzLmFwbGF5ZXIubGlzdE1heEhlaWdodCkpIDogMDsKICAgICAgICB9CiAgICAgIH1dKTsKCiAgICAgIHJldHVybiBQbGF5TGlzdDsKICAgIH0obGliWyJDb21wb25lbnQiXSk7CgogICAgUGxheUxpc3RfZGVjb3JhdGUoW1Byb3AoewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICByZXF1aXJlZDogZmFsc2UsCiAgICAgICJkZWZhdWx0IjogdHJ1ZQogICAgfSksIFBsYXlMaXN0X21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIEJvb2xlYW4pXSwgUGxheUxpc3RfUGxheUxpc3QucHJvdG90eXBlLCAidmlzaWJsZSIsIHZvaWQgMCk7CiAgICBQbGF5TGlzdF9kZWNvcmF0ZShbUHJvcCh7CiAgICAgIHR5cGU6IE9iamVjdCwKICAgICAgcmVxdWlyZWQ6IHRydWUKICAgIH0pLCBQbGF5TGlzdF9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCB0eXBlb2YgKFBsYXlMaXN0X2EgPSB0eXBlb2YgQVBsYXllciAhPT0gInVuZGVmaW5lZCIgJiYgQVBsYXllci5BdWRpbykgPT09ICJmdW5jdGlvbiIgPyBQbGF5TGlzdF9hIDogT2JqZWN0KV0sIFBsYXlMaXN0X1BsYXlMaXN0LnByb3RvdHlwZSwgImN1cnJlbnRNdXNpYyIsIHZvaWQgMCk7CiAgICBQbGF5TGlzdF9kZWNvcmF0ZShbUHJvcCh7CiAgICAgIHR5cGU6IEFycmF5LAogICAgICByZXF1aXJlZDogdHJ1ZQogICAgfSksIFBsYXlMaXN0X21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIHR5cGVvZiAoUGxheUxpc3RfYiA9IHR5cGVvZiBBcnJheSAhPT0gInVuZGVmaW5lZCIgJiYgQXJyYXkpID09PSAiZnVuY3Rpb24iID8gUGxheUxpc3RfYiA6IE9iamVjdCldLCBQbGF5TGlzdF9QbGF5TGlzdC5wcm90b3R5cGUsICJkYXRhU291cmNlIiwgdm9pZCAwKTsKICAgIFBsYXlMaXN0X2RlY29yYXRlKFtQcm9wKHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICByZXF1aXJlZDogdHJ1ZQogICAgfSksIFBsYXlMaXN0X21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIE51bWJlcildLCBQbGF5TGlzdF9QbGF5TGlzdC5wcm90b3R5cGUsICJzY3JvbGxUb3AiLCB2b2lkIDApOwogICAgUGxheUxpc3RfZGVjb3JhdGUoW0luamVjdCgpLCBQbGF5TGlzdF9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBPYmplY3QpXSwgUGxheUxpc3RfUGxheUxpc3QucHJvdG90eXBlLCAiYXBsYXllciIsIHZvaWQgMCk7CiAgICBQbGF5TGlzdF9kZWNvcmF0ZShbV2F0Y2goJ3Njcm9sbFRvcCcsIHsKICAgICAgaW1tZWRpYXRlOiB0cnVlCiAgICB9KSwgV2F0Y2goJ2RhdGFTb3VyY2UnLCB7CiAgICAgIGltbWVkaWF0ZTogdHJ1ZSwKICAgICAgZGVlcDogdHJ1ZQogICAgfSksIFdhdGNoKCd2aXNpYmxlJyksIFBsYXlMaXN0X21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIEZ1bmN0aW9uKSwgUGxheUxpc3RfbWV0YWRhdGEoImRlc2lnbjpwYXJhbXR5cGVzIiwgW10pLCBQbGF5TGlzdF9tZXRhZGF0YSgiZGVzaWduOnJldHVybnR5cGUiLCBQcm9taXNlKV0sIFBsYXlMaXN0X1BsYXlMaXN0LnByb3RvdHlwZSwgImhhbmRsZUNoYW5nZVNjcm9sbFRvcCIsIG51bGwpOwogICAgUGxheUxpc3RfUGxheUxpc3QgPSBQbGF5TGlzdF9kZWNvcmF0ZShbdnVlX2NsYXNzX2NvbXBvbmVudF9jb21tb25fZGVmYXVsdC5hXSwgUGxheUxpc3RfUGxheUxpc3QpOwogICAgLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLwoKICAgIHZhciBjb21wb25lbnRzX1BsYXlMaXN0ID0gUGxheUxpc3RfUGxheUxpc3Q7IC8vIEVYVEVSTkFMIE1PRFVMRTogLi9wYWNrYWdlcy9AbW9lZmUvdnVlLWFwbGF5ZXIvYXNzZXRzL3N0eWxlL2FwbGF5ZXIuc2NzcwoKICAgIHZhciBhcGxheWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygiNjEwYSIpOyAvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL0Btb2VmZS92dWUtYXBsYXllci9jb21wb25lbnRzL0FQbGF5ZXIudHN4CgoKICAgIHZhciBBUGxheWVyX2RlY29yYXRlID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykgewogICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsCiAgICAgICAgICByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywKICAgICAgICAgIGQ7CiAgICAgIGlmICgodHlwZW9mIFJlZmxlY3QgPT09ICJ1bmRlZmluZWQiID8gInVuZGVmaW5lZCIgOiBfdHlwZW9mKFJlZmxlY3QpKSA9PT0gIm9iamVjdCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09ICJmdW5jdGlvbiIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7CiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjsKICAgICAgfQogICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByOwogICAgfTsKCiAgICB2YXIgQVBsYXllcl9tZXRhZGF0YSA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19tZXRhZGF0YSB8fCBmdW5jdGlvbiAoaywgdikgewogICAgICBpZiAoKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogX3R5cGVvZihSZWZsZWN0KSkgPT09ICJvYmplY3QiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSAiZnVuY3Rpb24iKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTsKICAgIH07CgogICAgdmFyIEFQbGF5ZXJfYSwgQVBsYXllcl9iLCBBUGxheWVyX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDsKCiAgICB2YXIgaW5zdGFuY2VzID0gW107CiAgICB2YXIgc3RvcmUgPSBuZXcgdnVlX3N0b3JlKCk7CiAgICB2YXIgY2hhbm5lbCA9IG51bGw7CgogICAgaWYgKHR5cGVvZiBCcm9hZGNhc3RDaGFubmVsICE9PSAndW5kZWZpbmVkJykgewogICAgICBjaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoJ2FwbGF5ZXInKTsKICAgIH0KCiAgICB2YXIgQVBsYXllcl9BUGxheWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVnVlJENvbXBvbmVudCkgewogICAgICBfaW5oZXJpdHMoQVBsYXllciwgX1Z1ZSRDb21wb25lbnQpOwoKICAgICAgZnVuY3Rpb24gQVBsYXllcigpIHsKICAgICAgICB2YXIgX3RoaXM7CgogICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBUGxheWVyKTsKCiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQVBsYXllcikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7IC8vIOaYr+WQpuato+WcqOaLluWKqOi/m+W6puadoe+8iOmYsuatouaKluWKqO+8iQoKICAgICAgICBfdGhpcy5pc0RyYWdnaW5nUHJvZ3Jlc3NCYXIgPSBmYWxzZTsgLy8g5piv5ZCm5q2j5Zyo562J5b6F6L+b5bqm5p2h5pu05paw77yI6Ziy5q2i5oqW5Yqo77yJCgogICAgICAgIF90aGlzLmlzQXdhaXRDaGFuZ2VQcm9ncmVzc0JhciA9IGZhbHNlOyAvLyDmmK/lkKbmmK/ov7fkvaDmqKHlvI8KCiAgICAgICAgX3RoaXMuaXNNaW5pID0gX3RoaXMubWluaSAhPT0gbnVsbCA/IF90aGlzLm1pbmkgOiBfdGhpcy5maXhlZDsgLy8g5piv5ZCm5pivIGFycm93IOaooeW8jwoKICAgICAgICBfdGhpcy5pc0Fycm93ID0gZmFsc2U7IC8vIOW9kyBjdXJyZW50TXVzaWMg5pS55Y+Y5pe25piv5ZCm5YWB6K645pKt5pS+CgogICAgICAgIF90aGlzLmNhblBsYXkgPSAhX3RoaXMuaXNNb2JpbGUgJiYgX3RoaXMuYXV0b3BsYXk7IC8vIOaSreaUvuWIl+ihqOaYr+WQpuWPr+ingQoKICAgICAgICBfdGhpcy5saXN0VmlzaWJsZSA9ICFfdGhpcy5saXN0Rm9sZGVkOyAvLyDmjqfliLbov7fkvaDmqKHlvI/kuIvnmoTmrYzor43mmK/lkKblj6/op4EKCiAgICAgICAgX3RoaXMubHlyaWNWaXNpYmxlID0gdHJ1ZTsgLy8g5bCB6Z2i5Zu+54mH5a+56LGhCgogICAgICAgIF90aGlzLmltZyA9IG5ldyBJbWFnZSgpOyAvLyDlsIHpnaLkuIvovb3lr7nosaEKCiAgICAgICAgX3RoaXMueGhyID0gbmV3IHV0aWxzX0h0dHBSZXF1ZXN0KCk7IC8vIOWTjeW6lOW8j+WqkuS9k+WvueixoQoKICAgICAgICBfdGhpcy5tZWRpYSA9IG5ldyB2dWVfYXVkaW8oKTsgLy8g5qC45b+D6Z+z6aKR5a+56LGhCgogICAgICAgIF90aGlzLnBsYXllciA9IF90aGlzLm1lZGlhLmF1ZGlvOyAvLyDmkq3mlL7lmajorr7nva7lrZjlgqjlr7nosaEKCiAgICAgICAgX3RoaXMuc3RvcmUgPSBzdG9yZTsgLy8g5b2T5YmN5pKt5pS+55qE6Z+z5LmQCgogICAgICAgIF90aGlzLmN1cnJlbnRNdXNpYyA9IHsKICAgICAgICAgIGlkOiBOYU4sCiAgICAgICAgICBuYW1lOiAn5pyq5Yqg6L296Z+z6aKRJywKICAgICAgICAgIGFydGlzdDogJyjgspcg4oC4IOCylyApJywKICAgICAgICAgIHVybDogJycKICAgICAgICB9OyAvLyDlvZPliY3lt7Lmkq3mlL7mr5TkvosKCiAgICAgICAgX3RoaXMuY3VycmVudFBsYXllZCA9IDA7IC8vIOW9k+WJjemfs+mHjwoKICAgICAgICBfdGhpcy5jdXJyZW50Vm9sdW1lID0gX3RoaXMudm9sdW1lOyAvLyDlvZPliY3lvqrnjq/mqKHlvI8KCiAgICAgICAgX3RoaXMuY3VycmVudExvb3AgPSBfdGhpcy5sb29wOyAvLyDlvZPliY3pobrluo/mqKHlvI8KCiAgICAgICAgX3RoaXMuY3VycmVudE9yZGVyID0gX3RoaXMub3JkZXI7IC8vIOW9k+WJjeS4u+mimO+8jOmAmui/h+WwgemdouiHqumAguW6lOS4u+mimCA+IOW9k+WJjeaSreaUvueahOmfs+S5kOaMh+WumueahOS4u+mimCA+IOS4u+mimOmAiemhuQoKICAgICAgICBfdGhpcy5jdXJyZW50VGhlbWUgPSBfdGhpcy5jdXJyZW50TXVzaWMudGhlbWUgfHwgX3RoaXMudGhlbWU7IC8vIOmAmuefpeWvueixoQoKICAgICAgICBfdGhpcy5ub3RpY2UgPSB7CiAgICAgICAgICB0ZXh0OiAnJywKICAgICAgICAgIHRpbWU6IDIwMDAsCiAgICAgICAgICBvcGFjaXR5OiAwCiAgICAgICAgfTsKICAgICAgICByZXR1cm4gX3RoaXM7CiAgICAgIH0gLy8gI2VuZHJlZ2lvbgogICAgICAvLyDmj5DkvpvlvZPliY3lrp7kvovnmoTlvJXnlKjvvIzorqnlrZDnu4Tku7bojrflj5bor6Xlrp7kvovnmoTlj6/lk43lupTmlbDmja4KCgogICAgICBfY3JlYXRlQ2xhc3MoQVBsYXllciwgW3sKICAgICAgICBrZXk6ICJoYW5kbGVDaGFuZ2VQbGF5TGlzdCIsCiAgICAgICAgLy8gI3JlZ2lvbiDnm5HlkKzlsZ7mgKcKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgdmFyIF9oYW5kbGVDaGFuZ2VQbGF5TGlzdCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShuZXdMaXN0LCBvbGRMaXN0KSB7CiAgICAgICAgICAgIHZhciBuZXdMZW5ndGgsIG9sZExlbmd0aCwgX3RoaXMkY3VycmVudE11c2ljLCBpZCwgdXJsLCBvbGRJbmRleCwgX3RoaXMkY3VycmVudExpc3QsIG11c2ljOwoKICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7CiAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIGlmIChvbGRMaXN0KSB7CiAgICAgICAgICAgICAgICAgICAgICBuZXdMZW5ndGggPSBuZXdMaXN0Lmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICAgIG9sZExlbmd0aCA9IG9sZExpc3QubGVuZ3RoOwoKICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdMZW5ndGggIT09IG9sZExlbmd0aCkgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3TGVuZ3RoIDw9IDApIHRoaXMuJGVtaXQoJ2xpc3RDbGVhcicpO2Vsc2UgaWYgKG5ld0xlbmd0aCA+IG9sZExlbmd0aCkgdGhpcy4kZW1pdCgnbGlzdEFkZCcpO2Vsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRPcmRlckluZGV4IDwgMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMkY3VycmVudE11c2ljID0gdGhpcy5jdXJyZW50TXVzaWMsIGlkID0gX3RoaXMkY3VycmVudE11c2ljLmlkLCB1cmwgPSBfdGhpcyRjdXJyZW50TXVzaWMudXJsOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkSW5kZXggPSBvbGRMaXN0LmZpbmRJbmRleChmdW5jdGlvbiAoaXRlbSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5pZCA9PT0gaWQgfHwgaXRlbS51cmwgPT09IHVybDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmN1cnJlbnRNdXNpYywgb2xkTGlzdFtvbGRJbmRleCAtIDFdKTsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuUGxheSA9ICF0aGlzLnBsYXllci5wYXVzZWQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnbGlzdFJlbW92ZScpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSAvLyDmkq3mlL7liJfooajliJ3lp4vljJYKCgogICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMub3JkZXJMaXN0Lmxlbmd0aCA+IDApKSB7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRNdXNpYy5pZCkgewogICAgICAgICAgICAgICAgICAgICAgX3RoaXMkY3VycmVudExpc3QgPSBfc2xpY2VkVG9BcnJheSh0aGlzLmN1cnJlbnRMaXN0LCAxKTsKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE11c2ljID0gX3RoaXMkY3VycmVudExpc3RbMF07CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuUGxheSA9ICF0aGlzLnBsYXllci5wYXVzZWQ7CiAgICAgICAgICAgICAgICAgICAgICBtdXNpYyA9IHRoaXMub3JkZXJMaXN0W3RoaXMuY3VycmVudE9yZGVySW5kZXhdIHx8IHRoaXMub3JkZXJMaXN0WzBdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW4KCiAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY3VycmVudE11c2ljLCBtdXNpYyk7CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbmV4dFRpY2soKTsKCiAgICAgICAgICAgICAgICAgIGNhc2UgNToKICAgICAgICAgICAgICAgICAgICB0aGlzLmNhblBsYXkgPSB0cnVlOwoKICAgICAgICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTsKICAgICAgICAgIH0pKTsKCiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2VQbGF5TGlzdChfeCwgX3gyKSB7CiAgICAgICAgICAgIHJldHVybiBfaGFuZGxlQ2hhbmdlUGxheUxpc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgIH0KCiAgICAgICAgICByZXR1cm4gaGFuZGxlQ2hhbmdlUGxheUxpc3Q7CiAgICAgICAgfSgpCiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJoYW5kbGVDaGFuZ2VDdXJyZW50TXVzaWMiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICB2YXIgX2hhbmRsZUNoYW5nZUN1cnJlbnRNdXNpYyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMobmV3TXVzaWMsIG9sZE11c2ljKSB7CiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzOwoKICAgICAgICAgICAgdmFyIGNvdmVyLCBzcmM7CiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7CiAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkgewogICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld011c2ljLnRoZW1lKSB7CiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRUaGVtZSA9IG5ld011c2ljLnRoZW1lOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBjb3ZlciA9IG5ld011c2ljLmNvdmVyIHx8IHRoaXMub3B0aW9ucy5kZWZhdWx0Q292ZXI7CgogICAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIC8qI19fUFVSRV9fKi9fYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLmdldFRoZW1lQ29sb3JGcm9tQ292ZXIoY292ZXIpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczIuY3VycmVudFRoZW1lID0gX2NvbnRleHQyLnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA2OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyWyJjYXRjaCJdKDApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMyLmN1cnJlbnRUaGVtZSA9IG5ld011c2ljLnRoZW1lIHx8IF90aGlzMi50aGVtZTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzLCBbWzAsIDZdXSk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSk7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld011c2ljLnVybCkgewogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNTsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgaWYgKCEoKG9sZE11c2ljICE9PSB1bmRlZmluZWQgJiYgb2xkTXVzaWMudXJsKSAhPT0gbmV3TXVzaWMudXJsIHx8IHRoaXMucGxheWVyLnNyYyAhPT0gbmV3TXVzaWMudXJsKSkgewogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGxheWVkID0gMDsKCiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE11c2ljICYmIG9sZE11c2ljLmlkKSB7CiAgICAgICAgICAgICAgICAgICAgICAvLyDpppbmrKHliJ3lp4vljJbml7bkuI3opoHop6blj5Hkuovku7YKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlU2V0dGluZ3MoKTsKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2xpc3RTd2l0Y2gnLCBuZXdNdXNpYyk7CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDc7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXVkaW9VcmwobmV3TXVzaWMpOwoKICAgICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICAgIHNyYyA9IF9jb250ZXh0My5zZW50OwogICAgICAgICAgICAgICAgICAgIGlmIChzcmMpIHRoaXMucGxheWVyLnNyYyA9IHNyYzsKICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXllci5wbGF5YmFja1JhdGUgPSBuZXdNdXNpYy5zcGVlZCB8fCAxOwogICAgICAgICAgICAgICAgICAgIHRoaXMucGxheWVyLnByZWxvYWQgPSB0aGlzLnByZWxvYWQ7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5ZXIudm9sdW1lID0gdGhpcy5jdXJyZW50Vm9sdW1lOwogICAgICAgICAgICAgICAgICAgIHRoaXMucGxheWVyLmN1cnJlbnRUaW1lID0gMDsKCiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5ZXIub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICAgICAgICAgICAgICBfdGhpczIuc2hvd05vdGljZShlLnRvU3RyaW5nKCkpOwogICAgICAgICAgICAgICAgICAgIH07CgogICAgICAgICAgICAgICAgICBjYXNlIDE0OgogICAgICAgICAgICAgICAgICAgIC8vICoq6K+35Yu/56e75Yqo5q2k6KGMKirvvIzlkKbliJnlvZPmrYzmm7Lnu5PmnZ/mkq3mlL7ml7blpoLmnpzmrYzljZXkuK3lj6rmnInkuIDpppbmrYzmm7LlsIbml6Dms5Xph43lpI3mkq3mlL4KICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5QbGF5KSB0aGlzLnBsYXkoKTsKCiAgICAgICAgICAgICAgICAgIGNhc2UgMTU6CiAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LCBfY2FsbGVlMywgdGhpcyk7CiAgICAgICAgICB9KSk7CgogICAgICAgICAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlQ3VycmVudE11c2ljKF94MywgX3g0KSB7CiAgICAgICAgICAgIHJldHVybiBfaGFuZGxlQ2hhbmdlQ3VycmVudE11c2ljLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIGhhbmRsZUNoYW5nZUN1cnJlbnRNdXNpYzsKICAgICAgICB9KCkKICAgICAgfSwgewogICAgICAgIGtleTogImhhbmRsZUNoYW5nZVZvbHVtZSIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZVZvbHVtZSh2b2x1bWUpIHsKICAgICAgICAgIHRoaXMuY3VycmVudFZvbHVtZSA9IHZvbHVtZTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJoYW5kbGVDaGFuZ2VDdXJyZW50Vm9sdW1lIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hhbmdlQ3VycmVudFZvbHVtZSgpIHsKICAgICAgICAgIHRoaXMucGxheWVyLnZvbHVtZSA9IHRoaXMuY3VycmVudFZvbHVtZTsKICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTp2b2x1bWUnLCB0aGlzLmN1cnJlbnRWb2x1bWUpOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogImhhbmRsZUNoYW5nZUN1cnJlbnRUaW1lIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hhbmdlQ3VycmVudFRpbWUoKSB7CiAgICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZ1Byb2dyZXNzQmFyICYmICF0aGlzLmlzQXdhaXRDaGFuZ2VQcm9ncmVzc0JhcikgewogICAgICAgICAgICB0aGlzLmN1cnJlbnRQbGF5ZWQgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lIC8gdGhpcy5tZWRpYS5kdXJhdGlvbiB8fCAwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogImhhbmRsZUNoYW5nZVNldHRpbmdzIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hhbmdlU2V0dGluZ3MoKSB7CiAgICAgICAgICB2YXIgc2V0dGluZ3MgPSB7CiAgICAgICAgICAgIGN1cnJlbnRUaW1lOiB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lLAogICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5tZWRpYS5kdXJhdGlvbiwKICAgICAgICAgICAgcGF1c2VkOiB0aGlzLm1lZGlhLnBhdXNlZCwKICAgICAgICAgICAgbWluaTogdGhpcy5pc01pbmksCiAgICAgICAgICAgIGxyYzogdGhpcy5seXJpY1Zpc2libGUsCiAgICAgICAgICAgIGxpc3Q6IHRoaXMubGlzdFZpc2libGUsCiAgICAgICAgICAgIHZvbHVtZTogdGhpcy5jdXJyZW50Vm9sdW1lLAogICAgICAgICAgICBsb29wOiB0aGlzLmN1cnJlbnRMb29wLAogICAgICAgICAgICBvcmRlcjogdGhpcy5jdXJyZW50T3JkZXIsCiAgICAgICAgICAgIG11c2ljOiB0aGlzLmN1cnJlbnRNdXNpYwogICAgICAgICAgfTsKCiAgICAgICAgICBpZiAoc2V0dGluZ3Mudm9sdW1lIDw9IDApIHsKICAgICAgICAgICAgc2V0dGluZ3Mudm9sdW1lID0gdGhpcy5jdXJyZW50U2V0dGluZ3Mudm9sdW1lOwogICAgICAgICAgfQoKICAgICAgICAgIHRoaXMuc2F2ZVNldHRpbmdzKHNldHRpbmdzKTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJoYW5kbGVDaGFuZ2VFbmRlZCIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZUVuZGVkKCkgewogICAgICAgICAgaWYgKCF0aGlzLm1lZGlhLmVuZGVkKSByZXR1cm47CiAgICAgICAgICB0aGlzLmN1cnJlbnRQbGF5ZWQgPSAwOwoKICAgICAgICAgIHN3aXRjaCAodGhpcy5jdXJyZW50TG9vcCkgewogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICBjYXNlICdhbGwnOgogICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2tpcEZvcndhcmQoKTsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgJ29uZSc6CiAgICAgICAgICAgICAgdGhpcy5wbGF5KCk7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlICdub25lJzoKICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50SW5kZXggPT09IHRoaXMuY3VycmVudExpc3QubGVuZ3RoIC0gMSkgewogICAgICAgICAgICAgICAgdmFyIF90aGlzJGN1cnJlbnRMaXN0MiA9IF9zbGljZWRUb0FycmF5KHRoaXMuY3VycmVudExpc3QsIDEpOwoKICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE11c2ljID0gX3RoaXMkY3VycmVudExpc3QyWzBdOwogICAgICAgICAgICAgICAgdGhpcy5wYXVzZSgpOwogICAgICAgICAgICAgICAgdGhpcy5jYW5QbGF5ID0gZmFsc2U7CiAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuaGFuZGxlU2tpcEZvcndhcmQoKTsKCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlQ2hhbmdlTWluaSIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZU1pbmkoKSB7CiAgICAgICAgICB0aGlzLmlzTWluaSA9IHRoaXMubWluaTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJoYW5kbGVDaGFuZ2VDdXJyZW50TWluaSIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHZhciBfaGFuZGxlQ2hhbmdlQ3VycmVudE1pbmkgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KG5ld1ZhbCwgb2xkVmFsKSB7CiAgICAgICAgICAgIHZhciBjb250YWluZXI7CiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7CiAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkgewogICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyOwogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRuZXh0VGljaygpOwoKICAgICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuJHJlZnMuY29udGFpbmVyOwogICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBcnJvdyA9IGNvbnRhaW5lciAmJiBjb250YWluZXIub2Zmc2V0V2lkdGggPD0gMzAwOwoKICAgICAgICAgICAgICAgICAgICBpZiAob2xkVmFsICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTptaW5pJywgdGhpcy5pc01pbmkpOwogICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2VTZXR0aW5ncygpOwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGNhc2UgNToKICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sIF9jYWxsZWU0LCB0aGlzKTsKICAgICAgICAgIH0pKTsKCiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2VDdXJyZW50TWluaShfeDUsIF94NikgewogICAgICAgICAgICByZXR1cm4gX2hhbmRsZUNoYW5nZUN1cnJlbnRNaW5pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIGhhbmRsZUNoYW5nZUN1cnJlbnRNaW5pOwogICAgICAgIH0oKQogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlQ2hhbmdlTG9vcCIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZUxvb3AoKSB7CiAgICAgICAgICB0aGlzLmN1cnJlbnRMb29wID0gdGhpcy5sb29wOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogImhhbmRsZUNoYW5nZUN1cnJlbnRMb29wIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hhbmdlQ3VycmVudExvb3AoKSB7CiAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6bG9vcCcsIHRoaXMuY3VycmVudExvb3ApOwogICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2VTZXR0aW5ncygpOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogImhhbmRsZUNoYW5nZU9yZGVyIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hhbmdlT3JkZXIoKSB7CiAgICAgICAgICB0aGlzLmN1cnJlbnRPcmRlciA9IHRoaXMub3JkZXI7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlQ2hhbmdlQ3VycmVudE9yZGVyIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hhbmdlQ3VycmVudE9yZGVyKCkgewogICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOm9yZGVyJywgdGhpcy5jdXJyZW50T3JkZXIpOwogICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2VTZXR0aW5ncygpOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogImhhbmRsZUNoYW5nZUxpc3RWaXNpYmxlIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hhbmdlTGlzdFZpc2libGUoKSB7CiAgICAgICAgICB0aGlzLiRlbWl0KHRoaXMubGlzdFZpc2libGUgPyAnbGlzdFNob3cnIDogJ2xpc3RIaWRlJyk7CiAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6bGlzdEZvbGRlZCcsIHRoaXMubGlzdFZpc2libGUpOwogICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2VTZXR0aW5ncygpOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogImhhbmRsZUNoYW5nZUx5cmljVmlzaWJsZSIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZUx5cmljVmlzaWJsZSgpIHsKICAgICAgICAgIHRoaXMuJGVtaXQodGhpcy5seXJpY1Zpc2libGUgPyAnbHJjU2hvdycgOiAnbHJjSGlkZScpOwogICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2VTZXR0aW5ncygpOwogICAgICAgIH0gLy8gI2VuZHJlZ2lvbgogICAgICAgIC8vICNyZWdpb24g5YWs5byAIEFQSQoKICAgICAgfSwgewogICAgICAgIGtleTogInBsYXkiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICB2YXIgX3BsYXkgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KCkgewogICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkgewogICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMDsKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tdXRleCkgdGhpcy5wYXVzZU90aGVySW5zdGFuY2VzKCk7CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0OwogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBsYXllci5wbGF5KCk7CgogICAgICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgICAgIGNhc2UgNjoKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDY7CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnQwID0gX2NvbnRleHQ1WyJjYXRjaCJdKDApOwogICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd05vdGljZShfY29udGV4dDUudDAubWVzc2FnZSk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5ZXIucGF1c2UoKTsKCiAgICAgICAgICAgICAgICAgIGNhc2UgMTA6CiAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcywgW1swLCA2XV0pOwogICAgICAgICAgfSkpOwoKICAgICAgICAgIGZ1bmN0aW9uIHBsYXkoKSB7CiAgICAgICAgICAgIHJldHVybiBfcGxheS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiBwbGF5OwogICAgICAgIH0oKQogICAgICB9LCB7CiAgICAgICAga2V5OiAicGF1c2UiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXVzZSgpIHsKICAgICAgICAgIHRoaXMucGxheWVyLnBhdXNlKCk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAidG9nZ2xlIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCkgewogICAgICAgICAgaWYgKHRoaXMubWVkaWEucGF1c2VkKSB0aGlzLnBsYXkoKTtlbHNlIHRoaXMucGF1c2UoKTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJzZWVraW5nIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgdmFyIF9zZWVraW5nID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNihwZXJjZW50KSB7CiAgICAgICAgICAgIHZhciBwYXVzZWQsCiAgICAgICAgICAgICAgICBvbGRQYXVzZWQsCiAgICAgICAgICAgICAgICBfYXJnczYgPSBhcmd1bWVudHM7CiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7CiAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkgewogICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgcGF1c2VkID0gX2FyZ3M2Lmxlbmd0aCA+IDEgJiYgX2FyZ3M2WzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczZbMV0gOiB0cnVlOwogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMTsKICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQXdhaXRDaGFuZ2VQcm9ncmVzc0JhciA9IHRydWU7CgogICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMucHJlbG9hZCA9PT0gJ25vbmUnKSkgewogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxMTsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGxheWVyLnNyYykgewogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA3OwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDc7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVkaWEuc3JjTG9hZGVkKCk7CgogICAgICAgICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgICAgICAgb2xkUGF1c2VkID0gdGhpcy5wbGF5ZXIucGF1c2VkOwogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTA7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGxheSgpOwoKICAgICAgICAgICAgICAgICAgY2FzZSAxMDoKICAgICAgICAgICAgICAgICAgICAvLyBwcmVsb2FkIOS4uiBub25lIOeahOaDheWGteS4i+W/hemhu+WFiCBwbGF5CiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdXNlZCAmJiBvbGRQYXVzZWQpIHRoaXMucGF1c2UoKTsKCiAgICAgICAgICAgICAgICAgIGNhc2UgMTE6CiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdXNlZCkgdGhpcy5wYXVzZSgpOwogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTQ7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVkaWEubG9hZGVkKCk7CgogICAgICAgICAgICAgICAgICBjYXNlIDE0OgogICAgICAgICAgICAgICAgICAgIHRoaXMucGxheWVyLmN1cnJlbnRUaW1lID0gcGVyY2VudCAqIHRoaXMubWVkaWEuZHVyYXRpb247CgogICAgICAgICAgICAgICAgICAgIGlmICghcGF1c2VkKSB7CiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXkoKTsKCiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbCAmJiB0aGlzLm11dGV4KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwucG9zdE1lc3NhZ2UoJ211dGV4Jyk7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDIxOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICAgICAgY2FzZSAxODoKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDE4OwogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni50MCA9IF9jb250ZXh0NlsiY2F0Y2giXSgxKTsKICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dOb3RpY2UoX2NvbnRleHQ2LnQwLm1lc3NhZ2UpOwoKICAgICAgICAgICAgICAgICAgY2FzZSAyMToKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDIxOwogICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBd2FpdENoYW5nZVByb2dyZXNzQmFyID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5maW5pc2goMjEpOwoKICAgICAgICAgICAgICAgICAgY2FzZSAyNDoKICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sIF9jYWxsZWU2LCB0aGlzLCBbWzEsIDE4LCAyMSwgMjRdXSk7CiAgICAgICAgICB9KSk7CgogICAgICAgICAgZnVuY3Rpb24gc2Vla2luZyhfeDcpIHsKICAgICAgICAgICAgcmV0dXJuIF9zZWVraW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIHNlZWtpbmc7CiAgICAgICAgfSgpCiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJzZWVrIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2Vlayh0aW1lKSB7CiAgICAgICAgICB0aGlzLnNlZWtpbmcodGltZSAvIHRoaXMubWVkaWEuZHVyYXRpb24sIHRoaXMubWVkaWEucGF1c2VkKTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJzd2l0Y2giLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc3dpdGNoKGF1ZGlvKSB7CiAgICAgICAgICBzd2l0Y2ggKF90eXBlb2YoYXVkaW8pKSB7CiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6CiAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TXVzaWMgPSB0aGlzLm9yZGVyTGlzdFtNYXRoLm1pbihNYXRoLm1heCgwLCBhdWRpbyksIHRoaXMub3JkZXJMaXN0Lmxlbmd0aCAtIDEpXTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNhc2UtZGVjbGFyYXRpb25zCgogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIHZhciBtdXNpYyA9IHRoaXMub3JkZXJMaXN0LmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHsKICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgaXRlbS5uYW1lID09PSAnc3RyaW5nJyAmJiBpdGVtLm5hbWUuaW5jbHVkZXMoYXVkaW8pOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGlmIChtdXNpYykgdGhpcy5jdXJyZW50TXVzaWMgPSBtdXNpYzsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJza2lwQmFjayIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNraXBCYWNrKCkgewogICAgICAgICAgdmFyIHBsYXlJbmRleCA9IHRoaXMuZ2V0UGxheUluZGV4QnlNb2RlKCdza2lwQmFjaycpOwogICAgICAgICAgdGhpcy5jdXJyZW50TXVzaWMgPSBfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmN1cnJlbnRMaXN0W3BsYXlJbmRleF0pOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogInNraXBGb3J3YXJkIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2tpcEZvcndhcmQoKSB7CiAgICAgICAgICB2YXIgcGxheUluZGV4ID0gdGhpcy5nZXRQbGF5SW5kZXhCeU1vZGUoJ3NraXBGb3J3YXJkJyk7CiAgICAgICAgICB0aGlzLmN1cnJlbnRNdXNpYyA9IF9vYmplY3RTcHJlYWQoe30sIHRoaXMuY3VycmVudExpc3RbcGxheUluZGV4XSk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAic2hvd0xyYyIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dMcmMoKSB7CiAgICAgICAgICB0aGlzLmx5cmljVmlzaWJsZSA9IHRydWU7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGlkZUxyYyIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGVMcmMoKSB7CiAgICAgICAgICB0aGlzLmx5cmljVmlzaWJsZSA9IGZhbHNlOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogInRvZ2dsZUxyYyIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZUxyYygpIHsKICAgICAgICAgIHRoaXMubHlyaWNWaXNpYmxlID0gIXRoaXMubHlyaWNWaXNpYmxlOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogInNob3dMaXN0IiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd0xpc3QoKSB7CiAgICAgICAgICB0aGlzLmxpc3RWaXNpYmxlID0gdHJ1ZTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJoaWRlTGlzdCIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGVMaXN0KCkgewogICAgICAgICAgdGhpcy5saXN0VmlzaWJsZSA9IGZhbHNlOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogInRvZ2dsZUxpc3QiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVMaXN0KCkgewogICAgICAgICAgdGhpcy5saXN0VmlzaWJsZSA9ICF0aGlzLmxpc3RWaXNpYmxlOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogInNob3dOb3RpY2UiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93Tm90aWNlKHRleHQpIHsKICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzOwoKICAgICAgICAgIHZhciB0aW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAyMDAwOwogICAgICAgICAgdmFyIG9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDAuODsKICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgewogICAgICAgICAgICBpZiAoX3RoaXMzLmlzTWluaSkgewogICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlCiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdhcGxheWVyIG5vdGljZTonLCB0ZXh0KTsKICAgICAgICAgICAgICByZXNvbHZlKCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgX3RoaXMzLm5vdGljZSA9IHsKICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsCiAgICAgICAgICAgICAgICB0aW1lOiB0aW1lLAogICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eQogICAgICAgICAgICAgIH07CgogICAgICAgICAgICAgIF90aGlzMy4kZW1pdCgnbm90aWNlU2hvdycpOwoKICAgICAgICAgICAgICBpZiAodGltZSA+IDApIHsKICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICBfdGhpczMubm90aWNlLm9wYWNpdHkgPSAwOwoKICAgICAgICAgICAgICAgICAgX3RoaXMzLiRlbWl0KCdub3RpY2VIaWRlJyk7CgogICAgICAgICAgICAgICAgICByZXNvbHZlKCk7CiAgICAgICAgICAgICAgICB9LCB0aW1lKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgIH0gLy8gI2VuZHJlZ2lvbgogICAgICAgIC8vICNyZWdpb24g56eB5pyJIEFQSQogICAgICAgIC8vIOS7juWwgemdouS4reiOt+WPluS4u+mimOminOiJsgoKICAgICAgfSwgewogICAgICAgIGtleTogImdldFRoZW1lQ29sb3JGcm9tQ292ZXIiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaGVtZUNvbG9yRnJvbUNvdmVyKHVybCkgewogICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7CgogICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogICAgICAgICAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgICAgIHZhciBpbWFnZSwgcmVhZGVyOwogICAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDA7CgogICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIENvbG9yVGhpZWYgIT09ICd1bmRlZmluZWQnKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDEyOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDQ7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0Lnhoci5kb3dubG9hZCh1cmwsICdibG9iJyk7CgogICAgICAgICAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICAgICAgICAgIGltYWdlID0gX2NvbnRleHQ3LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpOwoKICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzNC5pbWcuc3JjID0gcmVhZGVyLnJlc3VsdDsKCiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzNC5pbWcub25sb2FkID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZ2V0Q29sb3IgPSBuZXcgQ29sb3JUaGllZigpLmdldENvbG9yKF90aGlzNC5pbWcpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZ2V0Q29sb3IyID0gX3NsaWNlZFRvQXJyYXkoX2dldENvbG9yLCAzKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IF9nZXRDb2xvcjJbMF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBfZ2V0Q29sb3IyWzFdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gX2dldENvbG9yMlsyXTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoZW1lID0gInJnYigiLmNvbmNhdChyLCAiLCAiKS5jb25jYXQoZywgIiwgIikuY29uY2F0KGIsICIpIik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGVtZSB8fCBfdGhpczQuY3VycmVudE11c2ljLnRoZW1lIHx8IF90aGlzNC50aGVtZSk7CiAgICAgICAgICAgICAgICAgICAgICAgIH07CgogICAgICAgICAgICAgICAgICAgICAgICBfdGhpczQuaW1nLm9uYWJvcnQgPSByZWplY3Q7CiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzNC5pbWcub25lcnJvciA9IHJlamVjdDsKICAgICAgICAgICAgICAgICAgICAgIH07CgogICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9uYWJvcnQgPSByZWplY3Q7CiAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDsKICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGltYWdlKTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTM7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjoKICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXM0LmN1cnJlbnRNdXNpYy50aGVtZSB8fCBfdGhpczQudGhlbWUpOwoKICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOgogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxODsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OgogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAxNTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny50MCA9IF9jb250ZXh0N1siY2F0Y2giXSgwKTsKICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXM0LmN1cnJlbnRNdXNpYy50aGVtZSB8fCBfdGhpczQudGhlbWUpOwoKICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWU3LCB0aGlzLCBbWzAsIDE1XV0pOwogICAgICAgICAgICB9KSk7CgogICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94OCwgX3g5KSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH07CiAgICAgICAgICB9KCkpOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogImdldEF1ZGlvVXJsIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXVkaW9VcmwobXVzaWMpIHsKICAgICAgICAgIHZhciBfdGhpczUgPSB0aGlzOwoKICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgICAgICAgIHZhciB0eXBlID0gbXVzaWMudHlwZTsKCiAgICAgICAgICAgIGlmICh0eXBlICYmIF90aGlzNS5jdXN0b21BdWRpb1R5cGUgJiYgX3RoaXM1LmN1c3RvbUF1ZGlvVHlwZVt0eXBlXSkgewogICAgICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXM1LmN1c3RvbUF1ZGlvVHlwZVt0eXBlXSA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICAgICAgX3RoaXM1LmN1c3RvbUF1ZGlvVHlwZVt0eXBlXShfdGhpczUucGxheWVyLCBtdXNpYywgX3RoaXM1KTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGUKICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIklsbGVnYWwgY3VzdG9tVHlwZTogIi5jb25jYXQodHlwZSkpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgcmVzb2x2ZSgpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAnYXV0bycpIHsKICAgICAgICAgICAgICAgIHR5cGUgPSAvbTN1OCgjfFw/fCQpL2kudGVzdChtdXNpYy51cmwpID8gJ2hscycgOiAnbm9ybWFsJzsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGlmICh0eXBlID09PSAnaGxzJykgewogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgaWYgKEhscy5pc1N1cHBvcnRlZCgpKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIGhscyA9IG5ldyBIbHMoKTsKICAgICAgICAgICAgICAgICAgICBobHMubG9hZFNvdXJjZShtdXNpYy51cmwpOwogICAgICAgICAgICAgICAgICAgIGhscy5hdHRhY2hNZWRpYShfdGhpczUucGxheWVyKTsKICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXM1LnBsYXllci5jYW5QbGF5VHlwZSgnYXBwbGljYXRpb24veC1tcGVnVVJMJykgfHwgX3RoaXM1LnBsYXllci5jYW5QbGF5VHlwZSgnYXBwbGljYXRpb24vdm5kLmFwcGxlLm1wZWdVUkwnKSkgewogICAgICAgICAgICAgICAgICAgIHJlc29sdmUobXVzaWMudXJsKTsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdITFMgaXMgbm90IHN1cHBvcnRlZC4nKSk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignSExTIGlzIG5vdCBzdXBwb3J0ZWQuJykpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICByZXNvbHZlKG11c2ljLnVybCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJnZXRQbGF5SW5kZXhCeU1vZGUiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQbGF5SW5kZXhCeU1vZGUodHlwZSkgewogICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuY3VycmVudExpc3QubGVuZ3RoOwogICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jdXJyZW50SW5kZXg7CiAgICAgICAgICByZXR1cm4gKHR5cGUgPT09ICdza2lwQmFjaycgPyBsZW5ndGggKyAoaW5kZXggLSAxKSA6IGluZGV4ICsgMSkgJSBsZW5ndGg7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAicGF1c2VPdGhlckluc3RhbmNlcyIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhdXNlT3RoZXJJbnN0YW5jZXMoKSB7CiAgICAgICAgICB2YXIgX3RoaXM2ID0gdGhpczsKCiAgICAgICAgICBpbnN0YW5jZXMuZmlsdGVyKGZ1bmN0aW9uIChpbnN0KSB7CiAgICAgICAgICAgIHJldHVybiBpbnN0ICE9PSBfdGhpczY7CiAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0KSB7CiAgICAgICAgICAgIHJldHVybiBpbnN0LnBhdXNlKCk7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJzYXZlU2V0dGluZ3MiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlU2V0dGluZ3Moc2V0dGluZ3MpIHsKICAgICAgICAgIHZhciBpbnN0YW5jZUluZGV4ID0gaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7CiAgICAgICAgICBpZiAoc2V0dGluZ3MgPT09IG51bGwpIGRlbGV0ZSBpbnN0YW5jZXNbaW5zdGFuY2VJbmRleF07CiAgICAgICAgICB0aGlzLnN0b3JlLnNldCh0aGlzLnNldHRpbmdzW2luc3RhbmNlSW5kZXhdICE9PSB1bmRlZmluZWQgPyB0aGlzLnNldHRpbmdzLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHsKICAgICAgICAgICAgcmV0dXJuIGluZGV4ID09PSBpbnN0YW5jZUluZGV4ID8gc2V0dGluZ3MgOiBpdGVtOwogICAgICAgICAgfSkgOiBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5zZXR0aW5ncykuY29uY2F0KFtzZXR0aW5nc10pKTsKICAgICAgICB9IC8vICNlbmRyZWdpb24KICAgICAgICAvLyAjcmVnaW9uIOS6i+S7tuWkhOeQhgogICAgICAgIC8vIOWIh+aNouS4iuS4gOabsgoKICAgICAgfSwgewogICAgICAgIGtleTogImhhbmRsZVNraXBCYWNrIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlU2tpcEJhY2soKSB7CiAgICAgICAgICB0aGlzLnNraXBCYWNrKCk7CiAgICAgICAgfSAvLyDliIfmjaLkuIvkuIDmm7IKCiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJoYW5kbGVTa2lwRm9yd2FyZCIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVNraXBGb3J3YXJkKCkgewogICAgICAgICAgdGhpcy5za2lwRm9yd2FyZCgpOwogICAgICAgIH0gLy8g5YiH5o2i5pKt5pS+CgogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlVG9nZ2xlUGxheSIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVRvZ2dsZVBsYXkoKSB7CiAgICAgICAgICB0aGlzLnRvZ2dsZSgpOwogICAgICAgIH0gLy8g5aSE55CG5YiH5o2i6aG65bqP5qih5byPCgogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlVG9nZ2xlT3JkZXJNb2RlIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVG9nZ2xlT3JkZXJNb2RlKCkgewogICAgICAgICAgdGhpcy5jdXJyZW50T3JkZXIgPSB0aGlzLmN1cnJlbnRPcmRlciA9PT0gJ2xpc3QnID8gJ3JhbmRvbScgOiAnbGlzdCc7CiAgICAgICAgfSAvLyDlpITnkIbliIfmjaLlvqrnjq/mqKHlvI8KCiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJoYW5kbGVUb2dnbGVMb29wTW9kZSIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVRvZ2dsZUxvb3BNb2RlKCkgewogICAgICAgICAgdGhpcy5jdXJyZW50TG9vcCA9IHRoaXMuY3VycmVudExvb3AgPT09ICdhbGwnID8gJ29uZScgOiB0aGlzLmN1cnJlbnRMb29wID09PSAnb25lJyA/ICdub25lJyA6ICdhbGwnOwogICAgICAgIH0gLy8g5aSE55CG5YiH5o2i5pKt5pS+L+aaguWBnOS6i+S7tgoKICAgICAgfSwgewogICAgICAgIGtleTogImhhbmRsZVRvZ2dsZVBsYXlsaXN0IiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVG9nZ2xlUGxheWxpc3QoKSB7CiAgICAgICAgICB0aGlzLnRvZ2dsZUxpc3QoKTsKICAgICAgICB9IC8vIOWkhOeQhuWIh+aNouatjOivjeaYvumakOS6i+S7tgoKICAgICAgfSwgewogICAgICAgIGtleTogImhhbmRsZVRvZ2dsZUx5cmljIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVG9nZ2xlTHlyaWMoKSB7CiAgICAgICAgICB0aGlzLnRvZ2dsZUxyYygpOwogICAgICAgIH0gLy8g5aSE55CG6L+b5bqm5p2h5pS55Y+Y5LqL5Lu2CgogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlQ2hhbmdlUHJvZ3Jlc3MiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDaGFuZ2VQcm9ncmVzcyhlLCBwZXJjZW50KSB7CiAgICAgICAgICB0aGlzLmN1cnJlbnRQbGF5ZWQgPSBwZXJjZW50OwogICAgICAgICAgdGhpcy5pc0RyYWdnaW5nUHJvZ3Jlc3NCYXIgPSBlLnR5cGUuaW5jbHVkZXMoJ21vdmUnKTsKCiAgICAgICAgICBpZiAoWyd0b3VjaGVuZCcsICdtb3VzZXVwJ10uaW5jbHVkZXMoZS50eXBlKSkgewogICAgICAgICAgICB0aGlzLnNlZWtpbmcocGVyY2VudCwgdGhpcy5tZWRpYS5wYXVzZWQpOyAvLyBwcmVsb2FkIOS4uiBub25lIOeahOaDheWGteS4i+aXoOazleiOt+WPluWIsCBkdXJhdGlvbgogICAgICAgICAgfQogICAgICAgIH0gLy8g5aSE55CG5YiH5o2i6L+35L2g5qih5byP5LqL5Lu2CgogICAgICB9LCB7CiAgICAgICAga2V5OiAiaGFuZGxlTWluaVN3aXRjaGVyIiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTWluaVN3aXRjaGVyKCkgewogICAgICAgICAgdGhpcy5pc01pbmkgPSAhdGhpcy5pc01pbmk7CiAgICAgICAgfSAvLyDlpITnkIbmkq3mlL7mm7Lnm67mlLnlj5jkuovku7YKCiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJoYW5kbGVDaGFuZ2VQbGF5bGlzdCIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZVBsYXlsaXN0KG11c2ljLCBpbmRleCkgewogICAgICAgICAgaWYgKG11c2ljLmlkID09PSB0aGlzLmN1cnJlbnRNdXNpYy5pZCkgdGhpcy5oYW5kbGVUb2dnbGVQbGF5KCk7ZWxzZSB0aGlzLmN1cnJlbnRNdXNpYyA9IHRoaXMub3JkZXJMaXN0W2luZGV4XTsKICAgICAgICB9IC8vICNlbmRyZWdpb24KCiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJiZWZvcmVNb3VudCIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZU1vdW50KCkgewogICAgICAgICAgdmFyIF90aGlzNyA9IHRoaXM7CgogICAgICAgICAgdGhpcy5zdG9yZS5rZXkgPSB0aGlzLnN0b3JhZ2VOYW1lOwogICAgICAgICAgdmFyIGVtcHR5SW5kZXggPSBpbnN0YW5jZXMuZmluZEluZGV4KGZ1bmN0aW9uICh4KSB7CiAgICAgICAgICAgIHJldHVybiAheDsKICAgICAgICAgIH0pOwogICAgICAgICAgaWYgKGVtcHR5SW5kZXggPiAtMSkgaW5zdGFuY2VzW2VtcHR5SW5kZXhdID0gdGhpcztlbHNlIGluc3RhbmNlcy5wdXNoKHRoaXMpOwoKICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTZXR0aW5ncykgewogICAgICAgICAgICB2YXIgX3RoaXMkY3VycmVudFNldHRpbmdzID0gdGhpcy5jdXJyZW50U2V0dGluZ3MsCiAgICAgICAgICAgICAgICBtaW5pID0gX3RoaXMkY3VycmVudFNldHRpbmdzLm1pbmksCiAgICAgICAgICAgICAgICBscmMgPSBfdGhpcyRjdXJyZW50U2V0dGluZ3MubHJjLAogICAgICAgICAgICAgICAgbGlzdCA9IF90aGlzJGN1cnJlbnRTZXR0aW5ncy5saXN0LAogICAgICAgICAgICAgICAgdm9sdW1lID0gX3RoaXMkY3VycmVudFNldHRpbmdzLnZvbHVtZSwKICAgICAgICAgICAgICAgIGxvb3AgPSBfdGhpcyRjdXJyZW50U2V0dGluZ3MubG9vcCwKICAgICAgICAgICAgICAgIG9yZGVyID0gX3RoaXMkY3VycmVudFNldHRpbmdzLm9yZGVyLAogICAgICAgICAgICAgICAgbXVzaWMgPSBfdGhpcyRjdXJyZW50U2V0dGluZ3MubXVzaWMsCiAgICAgICAgICAgICAgICBjdXJyZW50VGltZSA9IF90aGlzJGN1cnJlbnRTZXR0aW5ncy5jdXJyZW50VGltZSwKICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gX3RoaXMkY3VycmVudFNldHRpbmdzLmR1cmF0aW9uLAogICAgICAgICAgICAgICAgcGF1c2VkID0gX3RoaXMkY3VycmVudFNldHRpbmdzLnBhdXNlZDsKICAgICAgICAgICAgdGhpcy5pc01pbmkgPSBtaW5pOwogICAgICAgICAgICB0aGlzLmx5cmljVmlzaWJsZSA9IGxyYzsKICAgICAgICAgICAgdGhpcy5saXN0VmlzaWJsZSA9IGxpc3Q7CiAgICAgICAgICAgIHRoaXMuY3VycmVudFZvbHVtZSA9IHZvbHVtZTsKICAgICAgICAgICAgdGhpcy5jdXJyZW50TG9vcCA9IGxvb3A7CiAgICAgICAgICAgIHRoaXMuY3VycmVudE9yZGVyID0gb3JkZXI7CgogICAgICAgICAgICBpZiAobXVzaWMpIHsKICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNdXNpYyA9IG11c2ljOwoKICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNNb2JpbGUgJiYgZHVyYXRpb24pIHsKICAgICAgICAgICAgICAgIHRoaXMuc2Vla2luZyhjdXJyZW50VGltZSAvIGR1cmF0aW9uLCBwYXVzZWQpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSAvLyDlpITnkIblpJrpobXpnaLkupLmlqUKCgogICAgICAgICAgaWYgKGNoYW5uZWwpIHsKICAgICAgICAgICAgaWYgKHRoaXMubXV0ZXgpIHsKICAgICAgICAgICAgICBjaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoX3JlZjMpIHsKICAgICAgICAgICAgICAgIHZhciBkYXRhID0gX3JlZjMuZGF0YTsKICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSAnbXV0ZXgnKSBfdGhpczcucGF1c2UoKTsKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsvLyDkuI3mlK/mjIEgQnJvYWRjYXN0Q2hhbm5lbO+8jOaaguS4jeWkhOeQhgogICAgICAgICAgfQoKICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkgewogICAgICAgICAgICBfdGhpczcucGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNy4kZW1pdChldmVudCwgZSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiYmVmb3JlRGVzdHJveSIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7CiAgICAgICAgICB0aGlzLnBhdXNlKCk7CiAgICAgICAgICB0aGlzLnNhdmVTZXR0aW5ncyhudWxsKTsKICAgICAgICAgIHRoaXMuJGVtaXQoJ2Rlc3Ryb3knKTsKICAgICAgICAgIHRoaXMuJGVsLnJlbW92ZSgpOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIGtleTogInJlbmRlciIsCiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHsKICAgICAgICAgIHZhciBoID0gYXJndW1lbnRzWzBdOwogICAgICAgICAgdmFyIGRhdGFTb3VyY2UgPSB0aGlzLmRhdGFTb3VyY2UsCiAgICAgICAgICAgICAgZml4ZWQgPSB0aGlzLmZpeGVkLAogICAgICAgICAgICAgIGxyY1R5cGUgPSB0aGlzLmxyY1R5cGUsCiAgICAgICAgICAgICAgaXNNaW5pID0gdGhpcy5pc01pbmksCiAgICAgICAgICAgICAgaXNNb2JpbGUgPSB0aGlzLmlzTW9iaWxlLAogICAgICAgICAgICAgIGlzQXJyb3cgPSB0aGlzLmlzQXJyb3csCiAgICAgICAgICAgICAgaXNMb2FkaW5nID0gdGhpcy5pc0xvYWRpbmcsCiAgICAgICAgICAgICAgbm90aWNlID0gdGhpcy5ub3RpY2UsCiAgICAgICAgICAgICAgbGlzdFZpc2libGUgPSB0aGlzLmxpc3RWaXNpYmxlLAogICAgICAgICAgICAgIGxpc3RTY3JvbGxUb3AgPSB0aGlzLmxpc3RTY3JvbGxUb3AsCiAgICAgICAgICAgICAgY3VycmVudE11c2ljID0gdGhpcy5jdXJyZW50TXVzaWMsCiAgICAgICAgICAgICAgbHlyaWNWaXNpYmxlID0gdGhpcy5seXJpY1Zpc2libGU7CiAgICAgICAgICByZXR1cm4gaCgiZGl2IiwgewogICAgICAgICAgICByZWY6ICJjb250YWluZXIiLAogICAgICAgICAgICAiY2xhc3MiOiBjbGFzc25hbWVzX2RlZmF1bHQoKSh7CiAgICAgICAgICAgICAgYXBsYXllcjogdHJ1ZSwKICAgICAgICAgICAgICAnYXBsYXllci13aXRobGlzdCc6IGRhdGFTb3VyY2UubGVuZ3RoID4gMSwKICAgICAgICAgICAgICAnYXBsYXllci13aXRobHJjJzogIWZpeGVkICYmIGxyY1R5cGUgIT09IDAgJiYgbHlyaWNWaXNpYmxlLAogICAgICAgICAgICAgICdhcGxheWVyLW5hcnJvdyc6IGlzTWluaSwKICAgICAgICAgICAgICAnYXBsYXllci1maXhlZCc6IGZpeGVkLAogICAgICAgICAgICAgICdhcGxheWVyLW1vYmlsZSc6IGlzTW9iaWxlLAogICAgICAgICAgICAgICdhcGxheWVyLWFycm93JzogaXNBcnJvdywKICAgICAgICAgICAgICAnYXBsYXllci1sb2FkaW5nJzogaXNMb2FkaW5nCiAgICAgICAgICAgIH0pCiAgICAgICAgICB9LCBbaChjb21wb25lbnRzX1BsYXllciwgewogICAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAgIG5vdGljZTogbm90aWNlCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG9uOiB7CiAgICAgICAgICAgICAgInNraXBCYWNrIjogdGhpcy5oYW5kbGVTa2lwQmFjaywKICAgICAgICAgICAgICAic2tpcEZvcndhcmQiOiB0aGlzLmhhbmRsZVNraXBGb3J3YXJkLAogICAgICAgICAgICAgICJ0b2dnbGVQbGF5IjogdGhpcy5oYW5kbGVUb2dnbGVQbGF5LAogICAgICAgICAgICAgICJ0b2dnbGVPcmRlck1vZGUiOiB0aGlzLmhhbmRsZVRvZ2dsZU9yZGVyTW9kZSwKICAgICAgICAgICAgICAidG9nZ2xlTG9vcE1vZGUiOiB0aGlzLmhhbmRsZVRvZ2dsZUxvb3BNb2RlLAogICAgICAgICAgICAgICJ0b2dnbGVQbGF5bGlzdCI6IHRoaXMuaGFuZGxlVG9nZ2xlUGxheWxpc3QsCiAgICAgICAgICAgICAgInRvZ2dsZUx5cmljIjogdGhpcy5oYW5kbGVUb2dnbGVMeXJpYywKICAgICAgICAgICAgICAiY2hhbmdlVm9sdW1lIjogdGhpcy5oYW5kbGVDaGFuZ2VWb2x1bWUsCiAgICAgICAgICAgICAgImNoYW5nZVByb2dyZXNzIjogdGhpcy5oYW5kbGVDaGFuZ2VQcm9ncmVzcywKICAgICAgICAgICAgICAibWluaVN3aXRjaGVyIjogdGhpcy5oYW5kbGVNaW5pU3dpdGNoZXIKICAgICAgICAgICAgfQogICAgICAgICAgfSksIGgoY29tcG9uZW50c19QbGF5TGlzdCwgewogICAgICAgICAgICBhdHRyczogewogICAgICAgICAgICAgIHZpc2libGU6IGxpc3RWaXNpYmxlLAogICAgICAgICAgICAgIHNjcm9sbFRvcDogbGlzdFNjcm9sbFRvcCwKICAgICAgICAgICAgICBjdXJyZW50TXVzaWM6IGN1cnJlbnRNdXNpYywKICAgICAgICAgICAgICBkYXRhU291cmNlOiBkYXRhU291cmNlCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG9uOiB7CiAgICAgICAgICAgICAgImNoYW5nZSI6IHRoaXMuaGFuZGxlQ2hhbmdlUGxheWxpc3QKICAgICAgICAgICAgfQogICAgICAgICAgfSksIGZpeGVkICYmIGxyY1R5cGUgIT09IDAgPyBoKGNvbXBvbmVudHNfTHlyaWMsIHsKICAgICAgICAgICAgYXR0cnM6IHsKICAgICAgICAgICAgICB2aXNpYmxlOiBseXJpY1Zpc2libGUKICAgICAgICAgICAgfQogICAgICAgICAgfSkgOiBudWxsXSk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiYXBsYXllciIsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJzZXR0aW5ncyIsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5zdG9yZTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJjdXJyZW50U2V0dGluZ3MiLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NbaW5zdGFuY2VzLmluZGV4T2YodGhpcyldOwogICAgICAgIH0gLy8g5b2T5YmN5pKt5pS+5qih5byP5a+55bqU55qE5pKt5pS+5YiX6KGoCgogICAgICB9LCB7CiAgICAgICAga2V5OiAiY3VycmVudExpc3QiLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudE9yZGVyID09PSAnbGlzdCcgPyB0aGlzLm9yZGVyTGlzdCA6IHRoaXMucmFuZG9tTGlzdDsKICAgICAgICB9IC8vIOaVsOaNrua6kO+8jOiHquWKqOeUn+aIkCBJRCDkvZzkuLrmkq3mlL7liJfooajpobnnmoQga2V5CgogICAgICB9LCB7CiAgICAgICAga2V5OiAiZGF0YVNvdXJjZSIsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodGhpcy5hdWRpbykgPyB0aGlzLmF1ZGlvIDogW3RoaXMuYXVkaW9dKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsKICAgICAgICAgICAgcmV0dXJuIHg7CiAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7CiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHsKICAgICAgICAgICAgICBpZDogaW5kZXggKyAxCiAgICAgICAgICAgIH0sIGl0ZW0pOwogICAgICAgICAgfSk7CiAgICAgICAgfSAvLyDmoLnmja7mlbDmja7mupDnlJ/miJDpobrluo/mkq3mlL7liJfooajvvIjlpITnkIYgVk5vZGXvvIkKCiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJvcmRlckxpc3QiLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgdmFyIHRleHQgPSBmdW5jdGlvbiB0ZXh0KHZub2RlLCBrZXkpIHsKICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2bm9kZSA9PT0gJ3N0cmluZycgPyB2bm9kZSA6IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzWyJkYXRhLSIuY29uY2F0KGtleSldOwogICAgICAgICAgfTsKCiAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLm1hcChmdW5jdGlvbiAoX3JlZjQpIHsKICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmNC5uYW1lLAogICAgICAgICAgICAgICAgYXJ0aXN0ID0gX3JlZjQuYXJ0aXN0LAogICAgICAgICAgICAgICAgaXRlbSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNCwgWyJuYW1lIiwgImFydGlzdCJdKTsKCiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBpdGVtLCB7CiAgICAgICAgICAgICAgbmFtZTogdGV4dChuYW1lLCAnbmFtZScpLAogICAgICAgICAgICAgIGFydGlzdDogdGV4dChhcnRpc3QsICdhcnRpc3QnKQogICAgICAgICAgICB9KTsKICAgICAgICAgIH0pOwogICAgICAgIH0gLy8g5qC55o2u6aG65bqP5pKt5pS+5YiX6KGo55Sf5oiQ6ZqP5py65pKt5pS+5YiX6KGoCgogICAgICB9LCB7CiAgICAgICAga2V5OiAicmFuZG9tTGlzdCIsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gc2h1ZmZsZShfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5vcmRlckxpc3QpKTsKICAgICAgICB9IC8vIOaYr+WQpuato+WcqOe8k+WGsgoKICAgICAgfSwgewogICAgICAgIGtleTogImlzTG9hZGluZyIsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICB2YXIgcHJlbG9hZCA9IHRoaXMucHJlbG9hZCwKICAgICAgICAgICAgICBjdXJyZW50UGxheWVkID0gdGhpcy5jdXJyZW50UGxheWVkLAogICAgICAgICAgICAgIGN1cnJlbnRMb2FkZWQgPSB0aGlzLmN1cnJlbnRMb2FkZWQ7CiAgICAgICAgICB2YXIgX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhLAogICAgICAgICAgICAgIHNyYyA9IF90aGlzJG1lZGlhLnNyYywKICAgICAgICAgICAgICBwYXVzZWQgPSBfdGhpcyRtZWRpYS5wYXVzZWQsCiAgICAgICAgICAgICAgZHVyYXRpb24gPSBfdGhpcyRtZWRpYS5kdXJhdGlvbjsKICAgICAgICAgIHZhciBsb2FkaW5nID0gISFzcmMgJiYgKGN1cnJlbnRQbGF5ZWQgPiBjdXJyZW50TG9hZGVkIHx8ICFkdXJhdGlvbik7CiAgICAgICAgICByZXR1cm4gcHJlbG9hZCA9PT0gJ25vbmUnID8gIXBhdXNlZCAmJiBsb2FkaW5nIDogbG9hZGluZzsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJsaXN0U2Nyb2xsVG9wIiwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRPcmRlckluZGV4ICogMzM7CiAgICAgICAgfSAvLyDlvZPliY3mkq3mlL7nmoTpn7PkuZDntKLlvJUKCiAgICAgIH0sIHsKICAgICAgICBrZXk6ICJjdXJyZW50SW5kZXgiLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudE9yZGVyID09PSAnbGlzdCcgPyB0aGlzLmN1cnJlbnRPcmRlckluZGV4IDogdGhpcy5jdXJyZW50UmFuZG9tSW5kZXg7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiY3VycmVudE9yZGVySW5kZXgiLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgdmFyIF90aGlzJGN1cnJlbnRNdXNpYzIgPSB0aGlzLmN1cnJlbnRNdXNpYywKICAgICAgICAgICAgICBpZCA9IF90aGlzJGN1cnJlbnRNdXNpYzIuaWQsCiAgICAgICAgICAgICAgdXJsID0gX3RoaXMkY3VycmVudE11c2ljMi51cmw7CiAgICAgICAgICByZXR1cm4gdGhpcy5vcmRlckxpc3QuZmluZEluZGV4KGZ1bmN0aW9uIChpdGVtKSB7CiAgICAgICAgICAgIHJldHVybiBpdGVtLmlkID09PSBpZCB8fCBpdGVtLnVybCA9PT0gdXJsOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAga2V5OiAiY3VycmVudFJhbmRvbUluZGV4IiwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHZhciBfdGhpcyRjdXJyZW50TXVzaWMzID0gdGhpcy5jdXJyZW50TXVzaWMsCiAgICAgICAgICAgICAgaWQgPSBfdGhpcyRjdXJyZW50TXVzaWMzLmlkLAogICAgICAgICAgICAgIHVybCA9IF90aGlzJGN1cnJlbnRNdXNpYzMudXJsOwogICAgICAgICAgcmV0dXJuIHRoaXMucmFuZG9tTGlzdC5maW5kSW5kZXgoZnVuY3Rpb24gKGl0ZW0pIHsKICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaWQgPT09IGlkIHx8IGl0ZW0udXJsID09PSB1cmw7CiAgICAgICAgICB9KTsKICAgICAgICB9IC8vIOW9k+WJjeW3sue8k+WGsuavlOS+iwoKICAgICAgfSwgewogICAgICAgIGtleTogImN1cnJlbnRMb2FkZWQiLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgaWYgKHRoaXMubWVkaWEucmVhZHlTdGF0ZSA8IFJlYWR5U3RhdGUuSEFWRV9GVVRVUkVfREFUQSkgcmV0dXJuIDA7CiAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5tZWRpYS5idWZmZXJlZC5sZW5ndGg7CiAgICAgICAgICByZXR1cm4gbGVuZ3RoID4gMCA/IHRoaXMubWVkaWEuYnVmZmVyZWQuZW5kKGxlbmd0aCAtIDEpIC8gdGhpcy5tZWRpYS5kdXJhdGlvbiA6IDE7CiAgICAgICAgfQogICAgICB9XSk7CgogICAgICByZXR1cm4gQVBsYXllcjsKICAgIH0obGliWyJDb21wb25lbnQiXSk7CgogICAgQVBsYXllcl9BUGxheWVyLnZlcnNpb24gPSAiMi4wLjAtYmV0YS41IjsKICAgIEFQbGF5ZXJfZGVjb3JhdGUoW1Byb3AoewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICByZXF1aXJlZDogZmFsc2UsCiAgICAgICJkZWZhdWx0IjogZmFsc2UKICAgIH0pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIEJvb2xlYW4pXSwgQVBsYXllcl9BUGxheWVyLnByb3RvdHlwZSwgImZpeGVkIiwgdm9pZCAwKTsKICAgIEFQbGF5ZXJfZGVjb3JhdGUoW1Byb3AoewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICByZXF1aXJlZDogZmFsc2UsCiAgICAgICJkZWZhdWx0IjogbnVsbAogICAgfSksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgQm9vbGVhbildLCBBUGxheWVyX0FQbGF5ZXIucHJvdG90eXBlLCAibWluaSIsIHZvaWQgMCk7CiAgICBBUGxheWVyX2RlY29yYXRlKFtQcm9wKHsKICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgcmVxdWlyZWQ6IGZhbHNlLAogICAgICAiZGVmYXVsdCI6IGZhbHNlCiAgICB9KSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBCb29sZWFuKV0sIEFQbGF5ZXJfQVBsYXllci5wcm90b3R5cGUsICJhdXRvcGxheSIsIHZvaWQgMCk7CiAgICBBUGxheWVyX2RlY29yYXRlKFtQcm9wKHsKICAgICAgdHlwZTogU3RyaW5nLAogICAgICByZXF1aXJlZDogZmFsc2UsCiAgICAgICJkZWZhdWx0IjogJyNiN2RhZmYnCiAgICB9KSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBTdHJpbmcpXSwgQVBsYXllcl9BUGxheWVyLnByb3RvdHlwZSwgInRoZW1lIiwgdm9pZCAwKTsKICAgIEFQbGF5ZXJfZGVjb3JhdGUoW1Byb3AoewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwKICAgICAgImRlZmF1bHQiOiAnYWxsJwogICAgfSksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgdHlwZW9mIChBUGxheWVyX2EgPSB0eXBlb2YgQVBsYXllcl9BUGxheWVyICE9PSAidW5kZWZpbmVkIiAmJiBBUGxheWVyX0FQbGF5ZXIuTG9vcE1vZGUpID09PSAiZnVuY3Rpb24iID8gQVBsYXllcl9hIDogT2JqZWN0KV0sIEFQbGF5ZXJfQVBsYXllci5wcm90b3R5cGUsICJsb29wIiwgdm9pZCAwKTsKICAgIEFQbGF5ZXJfZGVjb3JhdGUoW1Byb3AoewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwKICAgICAgImRlZmF1bHQiOiAnbGlzdCcKICAgIH0pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIHR5cGVvZiAoQVBsYXllcl9iID0gdHlwZW9mIEFQbGF5ZXJfQVBsYXllciAhPT0gInVuZGVmaW5lZCIgJiYgQVBsYXllcl9BUGxheWVyLk9yZGVyTW9kZSkgPT09ICJmdW5jdGlvbiIgPyBBUGxheWVyX2IgOiBPYmplY3QpXSwgQVBsYXllcl9BUGxheWVyLnByb3RvdHlwZSwgIm9yZGVyIiwgdm9pZCAwKTsKICAgIEFQbGF5ZXJfZGVjb3JhdGUoW1Byb3AoewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwKICAgICAgImRlZmF1bHQiOiAnYXV0bycKICAgIH0pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIHR5cGVvZiAoQVBsYXllcl9jID0gdHlwZW9mIEFQbGF5ZXJfQVBsYXllciAhPT0gInVuZGVmaW5lZCIgJiYgQVBsYXllcl9BUGxheWVyLlByZWxvYWQpID09PSAiZnVuY3Rpb24iID8gQVBsYXllcl9jIDogT2JqZWN0KV0sIEFQbGF5ZXJfQVBsYXllci5wcm90b3R5cGUsICJwcmVsb2FkIiwgdm9pZCAwKTsKICAgIEFQbGF5ZXJfZGVjb3JhdGUoW1Byb3AoewogICAgICB0eXBlOiBOdW1iZXIsCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwKICAgICAgImRlZmF1bHQiOiAwLjcKICAgIH0pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIE51bWJlcildLCBBUGxheWVyX0FQbGF5ZXIucHJvdG90eXBlLCAidm9sdW1lIiwgdm9pZCAwKTsKICAgIEFQbGF5ZXJfZGVjb3JhdGUoW1Byb3AoewogICAgICB0eXBlOiBbT2JqZWN0LCBBcnJheV0sCiAgICAgIHJlcXVpcmVkOiB0cnVlCiAgICB9KSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBPYmplY3QpXSwgQVBsYXllcl9BUGxheWVyLnByb3RvdHlwZSwgImF1ZGlvIiwgdm9pZCAwKTsKICAgIEFQbGF5ZXJfZGVjb3JhdGUoW1Byb3AoewogICAgICB0eXBlOiBPYmplY3QsCiAgICAgIHJlcXVpcmVkOiBmYWxzZQogICAgfSksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgT2JqZWN0KV0sIEFQbGF5ZXJfQVBsYXllci5wcm90b3R5cGUsICJjdXN0b21BdWRpb1R5cGUiLCB2b2lkIDApOwogICAgQVBsYXllcl9kZWNvcmF0ZShbUHJvcCh7CiAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwKICAgICAgImRlZmF1bHQiOiB0cnVlCiAgICB9KSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBCb29sZWFuKV0sIEFQbGF5ZXJfQVBsYXllci5wcm90b3R5cGUsICJtdXRleCIsIHZvaWQgMCk7CiAgICBBUGxheWVyX2RlY29yYXRlKFtQcm9wKHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICByZXF1aXJlZDogZmFsc2UsCiAgICAgICJkZWZhdWx0IjogMAogICAgfSksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgdHlwZW9mIChfZiA9IHR5cGVvZiBBUGxheWVyX0FQbGF5ZXIgIT09ICJ1bmRlZmluZWQiICYmIEFQbGF5ZXJfQVBsYXllci5McmNUeXBlKSA9PT0gImZ1bmN0aW9uIiA/IF9mIDogT2JqZWN0KV0sIEFQbGF5ZXJfQVBsYXllci5wcm90b3R5cGUsICJscmNUeXBlIiwgdm9pZCAwKTsKICAgIEFQbGF5ZXJfZGVjb3JhdGUoW1Byb3AoewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICByZXF1aXJlZDogZmFsc2UsCiAgICAgICJkZWZhdWx0IjogZmFsc2UKICAgIH0pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIEJvb2xlYW4pXSwgQVBsYXllcl9BUGxheWVyLnByb3RvdHlwZSwgImxpc3RGb2xkZWQiLCB2b2lkIDApOwogICAgQVBsYXllcl9kZWNvcmF0ZShbUHJvcCh7CiAgICAgIHR5cGU6IE51bWJlciwKICAgICAgcmVxdWlyZWQ6IGZhbHNlLAogICAgICAiZGVmYXVsdCI6IDI1MAogICAgfSksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgTnVtYmVyKV0sIEFQbGF5ZXJfQVBsYXllci5wcm90b3R5cGUsICJsaXN0TWF4SGVpZ2h0Iiwgdm9pZCAwKTsKICAgIEFQbGF5ZXJfZGVjb3JhdGUoW1Byb3AoewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwKICAgICAgImRlZmF1bHQiOiAnYXBsYXllci1zZXR0aW5nJwogICAgfSksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgU3RyaW5nKV0sIEFQbGF5ZXJfQVBsYXllci5wcm90b3R5cGUsICJzdG9yYWdlTmFtZSIsIHZvaWQgMCk7CiAgICBBUGxheWVyX2RlY29yYXRlKFtQcm92aWRlKCksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgT2JqZWN0KSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnBhcmFtdHlwZXMiLCBbXSldLCBBUGxheWVyX0FQbGF5ZXIucHJvdG90eXBlLCAiYXBsYXllciIsIG51bGwpOwogICAgQVBsYXllcl9kZWNvcmF0ZShbV2F0Y2goJ29yZGVyTGlzdCcsIHsKICAgICAgaW1tZWRpYXRlOiB0cnVlLAogICAgICBkZWVwOiB0cnVlCiAgICB9KSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbiksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjpwYXJhbXR5cGVzIiwgW0FycmF5LCBBcnJheV0pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cmV0dXJudHlwZSIsIFByb21pc2UpXSwgQVBsYXllcl9BUGxheWVyLnByb3RvdHlwZSwgImhhbmRsZUNoYW5nZVBsYXlMaXN0IiwgbnVsbCk7CiAgICBBUGxheWVyX2RlY29yYXRlKFtXYXRjaCgnY3VycmVudE11c2ljJywgewogICAgICBpbW1lZGlhdGU6IHRydWUsCiAgICAgIGRlZXA6IHRydWUKICAgIH0pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIEZ1bmN0aW9uKSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnBhcmFtdHlwZXMiLCBbdHlwZW9mIChfZyA9IHR5cGVvZiBBUGxheWVyX0FQbGF5ZXIgIT09ICJ1bmRlZmluZWQiICYmIEFQbGF5ZXJfQVBsYXllci5BdWRpbykgPT09ICJmdW5jdGlvbiIgPyBfZyA6IE9iamVjdCwgdHlwZW9mIChfaCA9IHR5cGVvZiBBUGxheWVyX0FQbGF5ZXIgIT09ICJ1bmRlZmluZWQiICYmIEFQbGF5ZXJfQVBsYXllci5BdWRpbykgPT09ICJmdW5jdGlvbiIgPyBfaCA6IE9iamVjdF0pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cmV0dXJudHlwZSIsIFByb21pc2UpXSwgQVBsYXllcl9BUGxheWVyLnByb3RvdHlwZSwgImhhbmRsZUNoYW5nZUN1cnJlbnRNdXNpYyIsIG51bGwpOwogICAgQVBsYXllcl9kZWNvcmF0ZShbV2F0Y2goJ3ZvbHVtZScpLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIEZ1bmN0aW9uKSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnBhcmFtdHlwZXMiLCBbTnVtYmVyXSksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjpyZXR1cm50eXBlIiwgdm9pZCAwKV0sIEFQbGF5ZXJfQVBsYXllci5wcm90b3R5cGUsICJoYW5kbGVDaGFuZ2VWb2x1bWUiLCBudWxsKTsKICAgIEFQbGF5ZXJfZGVjb3JhdGUoW1dhdGNoKCdjdXJyZW50Vm9sdW1lJyksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgRnVuY3Rpb24pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cGFyYW10eXBlcyIsIFtdKSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnJldHVybnR5cGUiLCB2b2lkIDApXSwgQVBsYXllcl9BUGxheWVyLnByb3RvdHlwZSwgImhhbmRsZUNoYW5nZUN1cnJlbnRWb2x1bWUiLCBudWxsKTsKICAgIEFQbGF5ZXJfZGVjb3JhdGUoW1dhdGNoKCdtZWRpYS5jdXJyZW50VGltZScpLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIEZ1bmN0aW9uKSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnBhcmFtdHlwZXMiLCBbXSksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjpyZXR1cm50eXBlIiwgdm9pZCAwKV0sIEFQbGF5ZXJfQVBsYXllci5wcm90b3R5cGUsICJoYW5kbGVDaGFuZ2VDdXJyZW50VGltZSIsIG51bGwpOwogICAgQVBsYXllcl9kZWNvcmF0ZShbV2F0Y2goJ21lZGlhLiRkYXRhJywgewogICAgICBkZWVwOiB0cnVlCiAgICB9KSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbiksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjpwYXJhbXR5cGVzIiwgW10pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cmV0dXJudHlwZSIsIHZvaWQgMCldLCBBUGxheWVyX0FQbGF5ZXIucHJvdG90eXBlLCAiaGFuZGxlQ2hhbmdlU2V0dGluZ3MiLCBudWxsKTsKICAgIEFQbGF5ZXJfZGVjb3JhdGUoW1dhdGNoKCdtZWRpYS5lbmRlZCcpLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246dHlwZSIsIEZ1bmN0aW9uKSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnBhcmFtdHlwZXMiLCBbXSksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjpyZXR1cm50eXBlIiwgdm9pZCAwKV0sIEFQbGF5ZXJfQVBsYXllci5wcm90b3R5cGUsICJoYW5kbGVDaGFuZ2VFbmRlZCIsIG51bGwpOwogICAgQVBsYXllcl9kZWNvcmF0ZShbV2F0Y2goJ21pbmknKSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbiksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjpwYXJhbXR5cGVzIiwgW10pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cmV0dXJudHlwZSIsIHZvaWQgMCldLCBBUGxheWVyX0FQbGF5ZXIucHJvdG90eXBlLCAiaGFuZGxlQ2hhbmdlTWluaSIsIG51bGwpOwogICAgQVBsYXllcl9kZWNvcmF0ZShbV2F0Y2goJ2lzTWluaScsIHsKICAgICAgaW1tZWRpYXRlOiB0cnVlCiAgICB9KSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbiksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjpwYXJhbXR5cGVzIiwgW0Jvb2xlYW4sIEJvb2xlYW5dKSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnJldHVybnR5cGUiLCBQcm9taXNlKV0sIEFQbGF5ZXJfQVBsYXllci5wcm90b3R5cGUsICJoYW5kbGVDaGFuZ2VDdXJyZW50TWluaSIsIG51bGwpOwogICAgQVBsYXllcl9kZWNvcmF0ZShbV2F0Y2goJ2xvb3AnKSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbiksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjpwYXJhbXR5cGVzIiwgW10pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cmV0dXJudHlwZSIsIHZvaWQgMCldLCBBUGxheWVyX0FQbGF5ZXIucHJvdG90eXBlLCAiaGFuZGxlQ2hhbmdlTG9vcCIsIG51bGwpOwogICAgQVBsYXllcl9kZWNvcmF0ZShbV2F0Y2goJ2N1cnJlbnRMb29wJyksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjp0eXBlIiwgRnVuY3Rpb24pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cGFyYW10eXBlcyIsIFtdKSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnJldHVybnR5cGUiLCB2b2lkIDApXSwgQVBsYXllcl9BUGxheWVyLnByb3RvdHlwZSwgImhhbmRsZUNoYW5nZUN1cnJlbnRMb29wIiwgbnVsbCk7CiAgICBBUGxheWVyX2RlY29yYXRlKFtXYXRjaCgnb3JkZXInKSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbiksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjpwYXJhbXR5cGVzIiwgW10pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cmV0dXJudHlwZSIsIHZvaWQgMCldLCBBUGxheWVyX0FQbGF5ZXIucHJvdG90eXBlLCAiaGFuZGxlQ2hhbmdlT3JkZXIiLCBudWxsKTsKICAgIEFQbGF5ZXJfZGVjb3JhdGUoW1dhdGNoKCdjdXJyZW50T3JkZXInKSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbiksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjpwYXJhbXR5cGVzIiwgW10pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cmV0dXJudHlwZSIsIHZvaWQgMCldLCBBUGxheWVyX0FQbGF5ZXIucHJvdG90eXBlLCAiaGFuZGxlQ2hhbmdlQ3VycmVudE9yZGVyIiwgbnVsbCk7CiAgICBBUGxheWVyX2RlY29yYXRlKFtXYXRjaCgnbGlzdFZpc2libGUnKSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbiksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjpwYXJhbXR5cGVzIiwgW10pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cmV0dXJudHlwZSIsIHZvaWQgMCldLCBBUGxheWVyX0FQbGF5ZXIucHJvdG90eXBlLCAiaGFuZGxlQ2hhbmdlTGlzdFZpc2libGUiLCBudWxsKTsKICAgIEFQbGF5ZXJfZGVjb3JhdGUoW1dhdGNoKCdseXJpY1Zpc2libGUnKSwgQVBsYXllcl9tZXRhZGF0YSgiZGVzaWduOnR5cGUiLCBGdW5jdGlvbiksIEFQbGF5ZXJfbWV0YWRhdGEoImRlc2lnbjpwYXJhbXR5cGVzIiwgW10pLCBBUGxheWVyX21ldGFkYXRhKCJkZXNpZ246cmV0dXJudHlwZSIsIHZvaWQgMCldLCBBUGxheWVyX0FQbGF5ZXIucHJvdG90eXBlLCAiaGFuZGxlQ2hhbmdlTHlyaWNWaXNpYmxlIiwgbnVsbCk7CiAgICBBUGxheWVyX0FQbGF5ZXIgPSBBUGxheWVyX2RlY29yYXRlKFt2dWVfY2xhc3NfY29tcG9uZW50X2NvbW1vbl9kZWZhdWx0KCkoewogICAgICBtaXhpbnM6IFttaXhpbl0KICAgIH0pXSwgQVBsYXllcl9BUGxheWVyKTsKICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8KCiAgICB2YXIgY29tcG9uZW50c19BUGxheWVyID0gQVBsYXllcl9BUGxheWVyOyAvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL0Btb2VmZS92dWUtYXBsYXllci9pbmRleC50cwoKICAgIGZ1bmN0aW9uIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7CiAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHsKICAgICAgICBwcm9kdWN0aW9uVGlwOiB0cnVlLAogICAgICAgIGRlZmF1bHRDb3ZlcjogJ2h0dHBzOi8vYXZhdGFyczIuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3UvMjAwNjI0ODI/cz0yNzAnCiAgICAgIH07CgogICAgICB2YXIgb3B0cyA9IF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTsKCiAgICAgIE9iamVjdC5hc3NpZ24oY29tcG9uZW50c19BUGxheWVyLnByb3RvdHlwZSwgewogICAgICAgIG9wdGlvbnM6IG9wdHMKICAgICAgfSk7CiAgICAgIFZ1ZS5jb21wb25lbnQoJ2FwbGF5ZXInLCBjb21wb25lbnRzX0FQbGF5ZXIpOwogICAgICBWdWUuY29tcG9uZW50KCdBUGxheWVyJywgY29tcG9uZW50c19BUGxheWVyKTsKCiAgICAgIGlmIChvcHRzLnByb2R1Y3Rpb25UaXApIHsKICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZQogICAgICAgIGNvbnNvbGUubG9nKCIlYyB2dWUtYXBsYXllciAlYyB2Ii5jb25jYXQoIjIuMC4wLWJldGEuNSIsICIgIikuY29uY2F0KCJkZDEwYzUwIiwgIiAlYyIpLCAnYmFja2dyb3VuZDogIzM1NDk1ZTsgcGFkZGluZzogMXB4OyBib3JkZXItcmFkaXVzOiAzcHggMCAwIDNweDsgY29sb3I6ICNmZmYnLCAnYmFja2dyb3VuZDogIzQxYjg4MzsgcGFkZGluZzogMXB4OyBib3JkZXItcmFkaXVzOiAwIDNweCAzcHggMDsgY29sb3I6ICNmZmYnLCAnYmFja2dyb3VuZDogdHJhbnNwYXJlbnQnKTsKICAgICAgfQogICAgfSAvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdnVlL2NsaS1zZXJ2aWNlL2xpYi9jb21tYW5kcy9idWlsZC9lbnRyeS1saWIuanMKCiAgICAvKiBjb25jYXRlZCBoYXJtb255IHJlZXhwb3J0IEFQbGF5ZXIgKi8KCgogICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sICJBUGxheWVyIiwgZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gY29tcG9uZW50c19BUGxheWVyOwogICAgfSk7CiAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovCgoKICAgIHZhciBlbnRyeV9saWIgPSBfX3dlYnBhY2tfZXhwb3J0c19fWyJkZWZhdWx0Il0gPSBpbnN0YWxsOwogICAgLyoqKi8KICB9LAoKICAvKioqLwogICJmZGVmIjoKICAvKioqLwogIGZ1bmN0aW9uIGZkZWYobW9kdWxlLCBleHBvcnRzKSB7CiAgICBtb2R1bGUuZXhwb3J0cyA9ICJcdFxuXHgwQlxmXHIgXHhBMFx1MTY4MFx1MTgwRVx1MjAwMFx1MjAwMVx1MjAwMlx1MjAwMyIgKyAiXHUyMDA0XHUyMDA1XHUyMDA2XHUyMDA3XHUyMDA4XHUyMDA5XHUyMDBBXHUyMDJGXHUyMDVGXHUzMDAwXHUyMDI4XHUyMDI5XHVGRUZGIjsKICAgIC8qKiovCiAgfQogIC8qKioqKiovCgp9KTsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9VnVlQVBsYXllci5jb21tb24uanMubWFw"},{"version":3,"sources":["../src/api.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAAA,IAAA,MAAA,CAAA,CAAA,GAAA,IAAA;AAmCA;;AAIU;AAAA;;AAJV;;AAAA,WAAA,MAAA,CAAA,OAAA;AAAA;AAAA;AAKE;;AAKA;;;;;AACF;;;AAAC,EAAA,mBAAA,CAAA,CAAA,GAAA,OAAA;AAAD;;AAXA;AAIU;;AAJG;;AAAA,EAAA,mBAAA,CAAS,CAAT,GAAS,gBAAT;AAab;;;;;AAEG;;AAAA,EAAA,mBAAA,CAAA,CAAA,GAAA,UAAA,OAAA,EAAA,IAAA,EAAA,MAAA,EAAA;AACH;AAAA,QAAA,CAAA,mBAC0D,CAAA,CAD1D,CAC0D,OAD1D,EAC0D,IAD1D,CAAA,EAC0D;AAExD;AAAO,MAAA,MAAA,CAAA,cAAA,CAAW,OAAX,EAA+B,IAA/B,EAA+B;AAAA,QAAA,UAAA,EAAA,IAAA;AAAA,QAAA,GAAA,EAAA;AAAA,OAA/B;AACT;AAAC;AAJD;;AAAA,GADG;AAgBH;;AACE;AAAA;;AACA;;;AAAA,EAAA,mBAAmB,CAAA,CAAnB,GAAwB,UAAC,OAAD,EAAC;AAC1B;AAAC,QAAA,OAAA,MAAA,KAAA,WAAA,IAAA,MAAA,CAAA,WAAA,EAAA;AAEF;AAAA,MAAA,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,MAAA,CAAA,WAAA,EAAA;AAAA,QAAA,KAAA,EAAA;AAAA,OAAA;;;;;;;;;;GAHE;;;;;;AASC;AAAA;;AACH;AAAA;;AAKE;AAAA;;AACF;AAAC;;AAND;;;AAAA,EAAA,mBAMC,CAAA,CAND,GAMC,UAAA,KAAA,EAAA,IAAA,EAAA;AAED;AAAA,QAAA,IAAA,GAAA,CAAA,EACE,KAAA,GAAA,mBAAiB,CAAA,KAAA,CAAjB;AAEA;;AAAO,QAAA,IAAA,GAAA,CAAA,EAAoB,OAAC,KAAD;AAC7B;;AAAC,QAAA,IAAA,GAAA,CAAA,IAAA,SAAA,KAAA,MAAA,QAAA,IAAA,KAAA,IAAA,KAAA,CAAA,UAAA,EAAA,OAAA,KAAA;AAJD;;AAAA,QAAA,EAAA,GAAA,MAAA,CAAA,MAAA,CAAA,IAAA,CAAA;AAMA;;AAAA,IAAA,mBACE,CAAA,CADF,CACE,EADF;AAGE;;;AAAO,IAAA,MAAA,CAAA,cAAA,CAAqB,EAArB,EAAqB,SAArB,EAAqB;AAAA,MAAA,UAAA,EAAA,IAAA;AAAA,MAAA,KAAA,EAAA;AAAA,KAArB;AACT;;AAAC,QAAA,IAAA,GAAA,CAAA,IAAA,OAAA,KAAA,IAAA,QAAA,EAAA,KAAA,IAAA,GAAA,IAAA,KAAA;AAAA,MAAA,mBAAA,CAAA,CAAA,CAAA,EAAA,EAAA,GAAA,EAAA,UAAA,GAAA,EAAA;AAAA,eAAA,KAAA,CAAA,GAAA,CAAA;AAAA,OAAA,CAAA,IAAA,CAAA,IAAA,EAAA,GAAA,CAAA;AAAA;AAJD;;AAAA,WAAA,EAAA;AAMA;AAAA,GApBA;AAuBE;;AACF;AAAC;;AAJD;;;AAAA,EAAA,mBAAA,CAAA,CAAA,GAAA,UAAA,MAAA,EAIC;AAyHD;AAAA,QAAA,MAAA,GAAA,MAAA,IACE,MACA,CAAA,UAFF;AAIE;AAAO,aAAA,UAAA,GAAA;AAAA,aAAA,MAAA,CAAA,SAAA,CAAA;AAAA,KAJT;AAKI;AAAA,aAAA,gBAAA,GAAmB;AAAA,aAAA,MAAA;AAAA,KALvB;;;AAMM,IAAA,mBAAkB,CAAG,CAArB,CAAqB,MAArB,EAA6B,GAA7B,EAAmC,MAAnC;;;;AACE,WAAM,MAAN;;AAEF,GAtIN;AAuII;;AACA;AAAA;;;;;AACE,EAAA,mBAAO,CAAA,CAAP,GAAO,UAAuB,MAAvB,EAAiC,QAAjC,EAAuC;AAAE,WAAA,MAAW,CAAE,SAAb,CAAc,cAAd,CAAc,IAAd,CAAc,MAAd,EAAc,QAAd,CAAA;AAAc,GAA9D;AACF;;AACD;AAAC;;AACJ;;;AAAC,EAAA,mBAAA,CAAA,CAAA,GAAA,EAAA;AAED;;AAOE;;AACE;AAAA;;;;AACE,SAAA,mBAAW,CAAA,mBAAgB,CAAA,CAAhB,GAAgB,MAAhB,CAAX;AACF;AAAC,C;AACD;;;AACE;;AAEF;;AACE,cAAA,MAAA,EAAO,OAAP,EAAO,mBAAP,EAA8B;AAEjC;;AAGU,QAAA,OAAA,GAAA,mBAMT,CAAA,MAAA,CANS;;AAQb,QAAA,OAAA,GAAA,mBAAA,CAAA,MAAA,CAAA;;QAUE,QAAO,GAAA,mBAAA,CAAuB,MAAvB,C;;AACT,QAAC,IAAA,GAAA,mBAAA,CAAA,MAAA,CAAD;;AAXA,QAAA,SAAA,GAAA,mBAAA,CAAA,MAAA,CAAA;;AAaA,QAAA,WAAA,GAAA,mBAAA,CAAA,MAAA,CAAA;;;;AAEG,QAAA,cAAA,GAAA,mBAAA,CAAA,MAAA,CAAA;;AACU,QAAA,QAAA,GAAA,mBAAY,CAAA,MAAA,CAAZ,CAAY,UAAZ,CAAA;;AACA,QAAA,KAAA,GAAA,EAAA,GAAA,IAAA,IAAa,UAAA,GAAA,IAAA,EAAb,CAAA,CA9BuB,CA8BO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAjCrC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;GAAA;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;GAAA;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;GAAA;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;;;;;;;;;AAAA,C","sourceRoot":"","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"fb15\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"01f9\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar LIBRARY = __webpack_require__(\"2d00\");\nvar $export = __webpack_require__(\"5ca1\");\nvar redefine = __webpack_require__(\"2aba\");\nvar hide = __webpack_require__(\"32e9\");\nvar Iterators = __webpack_require__(\"84f2\");\nvar $iterCreate = __webpack_require__(\"41a0\");\nvar setToStringTag = __webpack_require__(\"7f20\");\nvar getPrototypeOf = __webpack_require__(\"38fd\");\nvar ITERATOR = __webpack_require__(\"2b4c\")('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n/***/ }),\n\n/***/ \"0a49\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\nvar ctx = __webpack_require__(\"9b43\");\nvar IObject = __webpack_require__(\"626a\");\nvar toObject = __webpack_require__(\"4bf8\");\nvar toLength = __webpack_require__(\"9def\");\nvar asc = __webpack_require__(\"cd1c\");\nmodule.exports = function (TYPE, $create) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  var create = $create || asc;\n  return function ($this, callbackfn, that) {\n    var O = toObject($this);\n    var self = IObject(O);\n    var f = ctx(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n    var val, res;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      val = self[index];\n      res = f(val, index, O);\n      if (TYPE) {\n        if (IS_MAP) result[index] = res;   // map\n        else if (res) switch (TYPE) {\n          case 3: return true;             // some\n          case 5: return val;              // find\n          case 6: return index;            // findIndex\n          case 2: result.push(val);        // filter\n        } else if (IS_EVERY) return false; // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n  };\n};\n\n\n/***/ }),\n\n/***/ \"0bfb\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// 21.2.5.3 get RegExp.prototype.flags\nvar anObject = __webpack_require__(\"cb7c\");\nmodule.exports = function () {\n  var that = anObject(this);\n  var result = '';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.unicode) result += 'u';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\n\n/***/ }),\n\n/***/ \"0d58\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = __webpack_require__(\"ce10\");\nvar enumBugKeys = __webpack_require__(\"e11e\");\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n\n\n/***/ }),\n\n/***/ \"1169\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.2.2 IsArray(argument)\nvar cof = __webpack_require__(\"2d95\");\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n\n\n/***/ }),\n\n/***/ \"11e9\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar pIE = __webpack_require__(\"52a7\");\nvar createDesc = __webpack_require__(\"4630\");\nvar toIObject = __webpack_require__(\"6821\");\nvar toPrimitive = __webpack_require__(\"6a99\");\nvar has = __webpack_require__(\"69a8\");\nvar IE8_DOM_DEFINE = __webpack_require__(\"c69a\");\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = __webpack_require__(\"9e1e\") ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n\n/***/ }),\n\n/***/ \"1495\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP = __webpack_require__(\"86cc\");\nvar anObject = __webpack_require__(\"cb7c\");\nvar getKeys = __webpack_require__(\"0d58\");\n\nmodule.exports = __webpack_require__(\"9e1e\") ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n/***/ }),\n\n/***/ \"1991\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ctx = __webpack_require__(\"9b43\");\nvar invoke = __webpack_require__(\"31f4\");\nvar html = __webpack_require__(\"fab2\");\nvar cel = __webpack_require__(\"230e\");\nvar global = __webpack_require__(\"7726\");\nvar process = global.process;\nvar setTask = global.setImmediate;\nvar clearTask = global.clearImmediate;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function () {\n  var id = +this;\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function (event) {\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!setTask || !clearTask) {\n  setTask = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (__webpack_require__(\"2d95\")(process) == 'process') {\n    defer = function (id) {\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if (MessageChannel) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\n    defer = function (id) {\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in cel('script')) {\n    defer = function (id) {\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set: setTask,\n  clear: clearTask\n};\n\n\n/***/ }),\n\n/***/ \"1fa8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// call something on iterator step with safe closing on error\nvar anObject = __webpack_require__(\"cb7c\");\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n\n/***/ }),\n\n/***/ \"20d6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)\nvar $export = __webpack_require__(\"5ca1\");\nvar $find = __webpack_require__(\"0a49\")(6);\nvar KEY = 'findIndex';\nvar forced = true;\n// Shouldn't skip holes\nif (KEY in []) Array(1)[KEY](function () { forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  findIndex: function findIndex(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n__webpack_require__(\"9c6c\")(KEY);\n\n\n/***/ }),\n\n/***/ \"214f\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar hide = __webpack_require__(\"32e9\");\nvar redefine = __webpack_require__(\"2aba\");\nvar fails = __webpack_require__(\"79e5\");\nvar defined = __webpack_require__(\"be13\");\nvar wks = __webpack_require__(\"2b4c\");\n\nmodule.exports = function (KEY, length, exec) {\n  var SYMBOL = wks(KEY);\n  var fns = exec(defined, SYMBOL, ''[KEY]);\n  var strfn = fns[0];\n  var rxfn = fns[1];\n  if (fails(function () {\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  })) {\n    redefine(String.prototype, KEY, strfn);\n    hide(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function (string, arg) { return rxfn.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function (string) { return rxfn.call(string, this); }\n    );\n  }\n};\n\n\n/***/ }),\n\n/***/ \"230e\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"d3f4\");\nvar document = __webpack_require__(\"7726\").document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n\n\n/***/ }),\n\n/***/ \"2350\":\n/***/ (function(module, exports) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n/***/ }),\n\n/***/ \"23c6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(\"2d95\");\nvar TAG = __webpack_require__(\"2b4c\")('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n/***/ }),\n\n/***/ \"2621\":\n/***/ (function(module, exports) {\n\nexports.f = Object.getOwnPropertySymbols;\n\n\n/***/ }),\n\n/***/ \"27ee\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classof = __webpack_require__(\"23c6\");\nvar ITERATOR = __webpack_require__(\"2b4c\")('iterator');\nvar Iterators = __webpack_require__(\"84f2\");\nmodule.exports = __webpack_require__(\"8378\").getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n/***/ }),\n\n/***/ \"28a5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// @@split logic\n__webpack_require__(\"214f\")('split', 2, function (defined, SPLIT, $split) {\n  'use strict';\n  var isRegExp = __webpack_require__(\"aae3\");\n  var _split = $split;\n  var $push = [].push;\n  var $SPLIT = 'split';\n  var LENGTH = 'length';\n  var LAST_INDEX = 'lastIndex';\n  if (\n    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||\n    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||\n    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||\n    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||\n    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||\n    ''[$SPLIT](/.?/)[LENGTH]\n  ) {\n    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group\n    // based on es5-shim implementation, need to rework it\n    $split = function (separator, limit) {\n      var string = String(this);\n      if (separator === undefined && limit === 0) return [];\n      // If `separator` is not a regex, use native split\n      if (!isRegExp(separator)) return _split.call(string, separator, limit);\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var separator2, match, lastIndex, lastLength, i;\n      // Doesn't need flags gy, but they don't hurt\n      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\\\s)', flags);\n      while (match = separatorCopy.exec(string)) {\n        // `separatorCopy.lastIndex` is not reliable cross-browser\n        lastIndex = match.index + match[0][LENGTH];\n        if (lastIndex > lastLastIndex) {\n          output.push(string.slice(lastLastIndex, match.index));\n          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG\n          // eslint-disable-next-line no-loop-func\n          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {\n            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;\n          });\n          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));\n          lastLength = match[0][LENGTH];\n          lastLastIndex = lastIndex;\n          if (output[LENGTH] >= splitLimit) break;\n        }\n        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop\n      }\n      if (lastLastIndex === string[LENGTH]) {\n        if (lastLength || !separatorCopy.test('')) output.push('');\n      } else output.push(string.slice(lastLastIndex));\n      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;\n    };\n  // Chakra, V8\n  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {\n    $split = function (separator, limit) {\n      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);\n    };\n  }\n  // 21.1.3.17 String.prototype.split(separator, limit)\n  return [function split(separator, limit) {\n    var O = defined(this);\n    var fn = separator == undefined ? undefined : separator[SPLIT];\n    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);\n  }, $split];\n});\n\n\n/***/ }),\n\n/***/ \"2aba\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"7726\");\nvar hide = __webpack_require__(\"32e9\");\nvar has = __webpack_require__(\"69a8\");\nvar SRC = __webpack_require__(\"ca5a\")('src');\nvar TO_STRING = 'toString';\nvar $toString = Function[TO_STRING];\nvar TPL = ('' + $toString).split(TO_STRING);\n\n__webpack_require__(\"8378\").inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n\n\n/***/ }),\n\n/***/ \"2aeb\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = __webpack_require__(\"cb7c\");\nvar dPs = __webpack_require__(\"1495\");\nvar enumBugKeys = __webpack_require__(\"e11e\");\nvar IE_PROTO = __webpack_require__(\"613b\")('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __webpack_require__(\"230e\")('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  __webpack_require__(\"fab2\").appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n/***/ }),\n\n/***/ \"2b4c\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar store = __webpack_require__(\"5537\")('wks');\nvar uid = __webpack_require__(\"ca5a\");\nvar Symbol = __webpack_require__(\"7726\").Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n/***/ }),\n\n/***/ \"2d00\":\n/***/ (function(module, exports) {\n\nmodule.exports = false;\n\n\n/***/ }),\n\n/***/ \"2d95\":\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n/***/ }),\n\n/***/ \"2e08\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://github.com/tc39/proposal-string-pad-start-end\nvar toLength = __webpack_require__(\"9def\");\nvar repeat = __webpack_require__(\"9744\");\nvar defined = __webpack_require__(\"be13\");\n\nmodule.exports = function (that, maxLength, fillString, left) {\n  var S = String(defined(that));\n  var stringLength = S.length;\n  var fillStr = fillString === undefined ? ' ' : String(fillString);\n  var intMaxLength = toLength(maxLength);\n  if (intMaxLength <= stringLength || fillStr == '') return S;\n  var fillLen = intMaxLength - stringLength;\n  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));\n  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);\n  return left ? stringFiller + S : S + stringFiller;\n};\n\n\n/***/ }),\n\n/***/ \"2f21\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar fails = __webpack_require__(\"79e5\");\n\nmodule.exports = function (method, arg) {\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call\n    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);\n  });\n};\n\n\n/***/ }),\n\n/***/ \"2fdb\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// 21.1.3.7 String.prototype.includes(searchString, position = 0)\n\nvar $export = __webpack_require__(\"5ca1\");\nvar context = __webpack_require__(\"d2c8\");\nvar INCLUDES = 'includes';\n\n$export($export.P + $export.F * __webpack_require__(\"5147\")(INCLUDES), 'String', {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~context(this, searchString, INCLUDES)\n      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n\n/***/ }),\n\n/***/ \"31f4\":\n/***/ (function(module, exports) {\n\n// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function (fn, args, that) {\n  var un = that === undefined;\n  switch (args.length) {\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return fn.apply(that, args);\n};\n\n\n/***/ }),\n\n/***/ \"32e9\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP = __webpack_require__(\"86cc\");\nvar createDesc = __webpack_require__(\"4630\");\nmodule.exports = __webpack_require__(\"9e1e\") ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n/***/ }),\n\n/***/ \"33a4\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// check on default Array iterator\nvar Iterators = __webpack_require__(\"84f2\");\nvar ITERATOR = __webpack_require__(\"2b4c\")('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n\n/***/ }),\n\n/***/ \"37e7\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n      /* harmony default export */ __webpack_exports__[\"default\"] = ({\n        functional: true,\n        render: \n      function render(_h, _vm) {\n        var _c=_vm._c;return _c('svg',{class:[_vm.data.class, _vm.data.staticClass],style:([_vm.data.style, _vm.data.staticStyle]),attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 32 32\"}},[_c('path',{attrs:{\"d\":\"M25.468 6.947a1.004 1.004 0 0 0-1.03.057L18 11.384V7.831a1.001 1.001 0 0 0-1.562-.827l-12 8.164a1 1 0 0 0 0 1.654l12 8.168A.999.999 0 0 0 18 24.164v-3.556l6.438 4.382A.999.999 0 0 0 26 24.164V7.831c0-.371-.205-.71-.532-.884z\"}})])\n      }\n    \n      });\n    \n\n/***/ }),\n\n/***/ \"3846\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 21.2.5.3 get RegExp.prototype.flags()\nif (__webpack_require__(\"9e1e\") && /./g.flags != 'g') __webpack_require__(\"86cc\").f(RegExp.prototype, 'flags', {\n  configurable: true,\n  get: __webpack_require__(\"0bfb\")\n});\n\n\n/***/ }),\n\n/***/ \"386b\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $export = __webpack_require__(\"5ca1\");\nvar fails = __webpack_require__(\"79e5\");\nvar defined = __webpack_require__(\"be13\");\nvar quot = /\"/g;\n// B.2.3.2.1 CreateHTML(string, tag, attribute, value)\nvar createHTML = function (string, tag, attribute, value) {\n  var S = String(defined(string));\n  var p1 = '<' + tag;\n  if (attribute !== '') p1 += ' ' + attribute + '=\"' + String(value).replace(quot, '&quot;') + '\"';\n  return p1 + '>' + S + '</' + tag + '>';\n};\nmodule.exports = function (NAME, exec) {\n  var O = {};\n  O[NAME] = exec(createHTML);\n  $export($export.P + $export.F * fails(function () {\n    var test = ''[NAME]('\"');\n    return test !== test.toLowerCase() || test.split('\"').length > 3;\n  }), 'String', O);\n};\n\n\n/***/ }),\n\n/***/ \"38fd\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = __webpack_require__(\"69a8\");\nvar toObject = __webpack_require__(\"4bf8\");\nvar IE_PROTO = __webpack_require__(\"613b\")('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n\n/***/ }),\n\n/***/ \"41a0\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar create = __webpack_require__(\"2aeb\");\nvar descriptor = __webpack_require__(\"4630\");\nvar setToStringTag = __webpack_require__(\"7f20\");\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(\"32e9\")(IteratorPrototype, __webpack_require__(\"2b4c\")('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n/***/ }),\n\n/***/ \"456d\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.14 Object.keys(O)\nvar toObject = __webpack_require__(\"4bf8\");\nvar $keys = __webpack_require__(\"0d58\");\n\n__webpack_require__(\"5eda\")('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n\n\n/***/ }),\n\n/***/ \"4588\":\n/***/ (function(module, exports) {\n\n// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n/***/ }),\n\n/***/ \"4630\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n/***/ }),\n\n/***/ \"4713\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n      /* harmony default export */ __webpack_exports__[\"default\"] = ({\n        functional: true,\n        render: \n      function render(_h, _vm) {\n        var _c=_vm._c;return _c('svg',{class:[_vm.data.class, _vm.data.staticClass],style:([_vm.data.style, _vm.data.staticStyle]),attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 32 32\"}},[_c('path',{attrs:{\"d\":\"M26.667 5.333H5.334h-.001a2.667 2.667 0 0 0-2.666 2.666V24.001a2.667 2.667 0 0 0 2.666 2.666h21.335a2.667 2.667 0 0 0 2.666-2.666V8v-.001a2.667 2.667 0 0 0-2.666-2.666h-.001zM5.333 16h5.333v2.667H5.333V16zm13.334 8H5.334v-2.667h13.333V24zm8 0h-5.333v-2.667h5.333V24zm0-5.333H13.334V16h13.333v2.667z\"}})])\n      }\n    \n      });\n    \n\n/***/ }),\n\n/***/ \"475a\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n      /* harmony default export */ __webpack_exports__[\"default\"] = ({\n        functional: true,\n        render: \n      function render(_h, _vm) {\n        var _c=_vm._c;return _c('svg',{class:[_vm.data.class, _vm.data.staticClass],style:([_vm.data.style, _vm.data.staticStyle]),attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 32 32\"}},[_c('path',{attrs:{\"d\":\"M.622 18.334h19.54v7.55l11.052-9.412-11.052-9.413v7.549H.622v3.725z\"}})])\n      }\n    \n      });\n    \n\n/***/ }),\n\n/***/ \"48d3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(\"b349\"));\nvar modifiers_1 = __webpack_require__(\"66a1\");\nexports.modifiers = modifiers_1.modifiers;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwyQkFBc0I7QUFDdEIseUNBQXdDO0FBQS9CLGdDQUFBLFNBQVMsQ0FBQSJ9\n\n/***/ }),\n\n/***/ \"4917\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// @@match logic\n__webpack_require__(\"214f\")('match', 1, function (defined, MATCH, $match) {\n  // 21.1.3.11 String.prototype.match(regexp)\n  return [function match(regexp) {\n    'use strict';\n    var O = defined(this);\n    var fn = regexp == undefined ? undefined : regexp[MATCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n  }, $match];\n});\n\n\n/***/ }),\n\n/***/ \"499e\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js\n/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nfunction listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesClient.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return addStylesClient; });\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\n\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nfunction addStylesClient (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n\n/***/ }),\n\n/***/ \"4a59\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ctx = __webpack_require__(\"9b43\");\nvar call = __webpack_require__(\"1fa8\");\nvar isArrayIter = __webpack_require__(\"33a4\");\nvar anObject = __webpack_require__(\"cb7c\");\nvar toLength = __webpack_require__(\"9def\");\nvar getIterFn = __webpack_require__(\"27ee\");\nvar BREAK = {};\nvar RETURN = {};\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\n  var f = ctx(fn, that, entries ? 2 : 1);\n  var index = 0;\n  var length, step, iterator, result;\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if (result === BREAK || result === RETURN) return result;\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n    result = call(iterator, f, step.value, entries);\n    if (result === BREAK || result === RETURN) return result;\n  }\n};\nexports.BREAK = BREAK;\nexports.RETURN = RETURN;\n\n\n/***/ }),\n\n/***/ \"4b41\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n      /* harmony default export */ __webpack_exports__[\"default\"] = ({\n        functional: true,\n        render: \n      function render(_h, _vm) {\n        var _c=_vm._c;return _c('svg',{class:[_vm.data.class, _vm.data.staticClass],style:([_vm.data.style, _vm.data.staticStyle]),attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 28 32\"}},[_c('path',{attrs:{\"d\":\"M13.728 6.272v19.456q0 .448-.352.8t-.8.32-.8-.32l-5.952-5.952H1.152q-.48 0-.8-.352t-.352-.8v-6.848q0-.48.352-.8t.8-.352h4.672l5.952-5.952q.32-.32.8-.32t.8.32.352.8zM20.576 16q0 1.344-.768 2.528t-2.016 1.664q-.16.096-.448.096-.448 0-.8-.32t-.32-.832q0-.384.192-.64t.544-.448.608-.384.512-.64.192-1.024-.192-1.024-.512-.64-.608-.384-.544-.448-.192-.64q0-.48.32-.832t.8-.32q.288 0 .448.096 1.248.48 2.016 1.664T20.576 16zm4.576 0q0 2.72-1.536 5.056t-4 3.36q-.256.096-.448.096-.48 0-.832-.352t-.32-.8q0-.704.672-1.056 1.024-.512 1.376-.8 1.312-.96 2.048-2.4T22.848 16t-.736-3.104-2.048-2.4q-.352-.288-1.376-.8-.672-.352-.672-1.056 0-.448.32-.8t.8-.352q.224 0 .48.096 2.496 1.056 4 3.36T25.152 16zm4.576 0q0 4.096-2.272 7.552t-6.048 5.056q-.224.096-.448.096-.48 0-.832-.352t-.32-.8q0-.64.704-1.056l.384-.192q.256-.128.416-.192.8-.448 1.44-.896 2.208-1.632 3.456-4.064T27.424 16t-1.216-5.152-3.456-4.064q-.64-.448-1.44-.896-.128-.096-.416-.192t-.384-.192q-.704-.416-.704-1.056 0-.448.32-.8t.832-.352q.224 0 .448.096 3.776 1.632 6.048 5.056T29.728 16z\"}})])\n      }\n    \n      });\n    \n\n/***/ }),\n\n/***/ \"4bf8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(\"be13\");\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n\n\n/***/ }),\n\n/***/ \"4d26\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n\n\n/***/ }),\n\n/***/ \"5147\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar MATCH = __webpack_require__(\"2b4c\")('match');\nmodule.exports = function (KEY) {\n  var re = /./;\n  try {\n    '/./'[KEY](re);\n  } catch (e) {\n    try {\n      re[MATCH] = false;\n      return !'/./'[KEY](re);\n    } catch (f) { /* empty */ }\n  } return true;\n};\n\n\n/***/ }),\n\n/***/ \"52a7\":\n/***/ (function(module, exports) {\n\nexports.f = {}.propertyIsEnumerable;\n\n\n/***/ }),\n\n/***/ \"52f0\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar map = {\n\t\"./loading.svg\": \"885d\",\n\t\"./loop-all.svg\": \"f866\",\n\t\"./loop-none.svg\": \"c3ab\",\n\t\"./loop-one.svg\": \"5527\",\n\t\"./lrc.svg\": \"4713\",\n\t\"./menu.svg\": \"906b\",\n\t\"./order-list.svg\": \"475a\",\n\t\"./order-random.svg\": \"7a1a\",\n\t\"./pause.svg\": \"daf8\",\n\t\"./play.svg\": \"84d8\",\n\t\"./right.svg\": \"bf5c\",\n\t\"./skip.svg\": \"37e7\",\n\t\"./volume-down.svg\": \"bdba\",\n\t\"./volume-off.svg\": \"adec\",\n\t\"./volume-up.svg\": \"4b41\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) { // check for number or string\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn id;\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"52f0\";\n\n/***/ }),\n\n/***/ \"551c\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar LIBRARY = __webpack_require__(\"2d00\");\nvar global = __webpack_require__(\"7726\");\nvar ctx = __webpack_require__(\"9b43\");\nvar classof = __webpack_require__(\"23c6\");\nvar $export = __webpack_require__(\"5ca1\");\nvar isObject = __webpack_require__(\"d3f4\");\nvar aFunction = __webpack_require__(\"d8e8\");\nvar anInstance = __webpack_require__(\"f605\");\nvar forOf = __webpack_require__(\"4a59\");\nvar speciesConstructor = __webpack_require__(\"ebd6\");\nvar task = __webpack_require__(\"1991\").set;\nvar microtask = __webpack_require__(\"8079\")();\nvar newPromiseCapabilityModule = __webpack_require__(\"a5b8\");\nvar perform = __webpack_require__(\"9c80\");\nvar userAgent = __webpack_require__(\"a25f\");\nvar promiseResolve = __webpack_require__(\"bcaa\");\nvar PROMISE = 'Promise';\nvar TypeError = global.TypeError;\nvar process = global.process;\nvar versions = process && process.versions;\nvar v8 = versions && versions.v8 || '';\nvar $Promise = global[PROMISE];\nvar isNode = classof(process) == 'process';\nvar empty = function () { /* empty */ };\nvar Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\nvar newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;\n\nvar USE_NATIVE = !!function () {\n  try {\n    // correct subclassing with @@species support\n    var promise = $Promise.resolve(1);\n    var FakePromise = (promise.constructor = {})[__webpack_require__(\"2b4c\")('species')] = function (exec) {\n      exec(empty, empty);\n    };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function')\n      && promise.then(empty) instanceof FakePromise\n      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n      // we can't detect it synchronously, so just check versions\n      && v8.indexOf('6.6') !== 0\n      && userAgent.indexOf('Chrome/66') === -1;\n  } catch (e) { /* empty */ }\n}();\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar notify = function (promise, isReject) {\n  if (promise._n) return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function () {\n    var value = promise._v;\n    var ok = promise._s == 1;\n    var i = 0;\n    var run = function (reaction) {\n      var handler = ok ? reaction.ok : reaction.fail;\n      var resolve = reaction.resolve;\n      var reject = reaction.reject;\n      var domain = reaction.domain;\n      var result, then, exited;\n      try {\n        if (handler) {\n          if (!ok) {\n            if (promise._h == 2) onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if (handler === true) result = value;\n          else {\n            if (domain) domain.enter();\n            result = handler(value); // may throw\n            if (domain) {\n              domain.exit();\n              exited = true;\n            }\n          }\n          if (result === reaction.promise) {\n            reject(TypeError('Promise-chain cycle'));\n          } else if (then = isThenable(result)) {\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch (e) {\n        if (domain && !exited) domain.exit();\n        reject(e);\n      }\n    };\n    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if (isReject && !promise._h) onUnhandled(promise);\n  });\n};\nvar onUnhandled = function (promise) {\n  task.call(global, function () {\n    var value = promise._v;\n    var unhandled = isUnhandled(promise);\n    var result, handler, console;\n    if (unhandled) {\n      result = perform(function () {\n        if (isNode) {\n          process.emit('unhandledRejection', value, promise);\n        } else if (handler = global.onunhandledrejection) {\n          handler({ promise: promise, reason: value });\n        } else if ((console = global.console) && console.error) {\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if (unhandled && result.e) throw result.v;\n  });\n};\nvar isUnhandled = function (promise) {\n  return promise._h !== 1 && (promise._a || promise._c).length === 0;\n};\nvar onHandleUnhandled = function (promise) {\n  task.call(global, function () {\n    var handler;\n    if (isNode) {\n      process.emit('rejectionHandled', promise);\n    } else if (handler = global.onrejectionhandled) {\n      handler({ promise: promise, reason: promise._v });\n    }\n  });\n};\nvar $reject = function (value) {\n  var promise = this;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if (!promise._a) promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function (value) {\n  var promise = this;\n  var then;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\n    if (then = isThenable(value)) {\n      microtask(function () {\n        var wrapper = { _w: promise, _d: false }; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch (e) {\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch (e) {\n    $reject.call({ _w: promise, _d: false }, e); // wrap\n  }\n};\n\n// constructor polyfill\nif (!USE_NATIVE) {\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor) {\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch (err) {\n      $reject.call(this, err);\n    }\n  };\n  // eslint-disable-next-line no-unused-vars\n  Internal = function Promise(executor) {\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = __webpack_require__(\"dcbc\")($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected) {\n      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if (this._a) this._a.push(reaction);\n      if (this._s) notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function (onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  });\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject = ctx($reject, promise, 1);\n  };\n  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n    return C === $Promise || C === Wrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });\n__webpack_require__(\"7f20\")($Promise, PROMISE);\n__webpack_require__(\"7a56\")(PROMISE);\nWrapper = __webpack_require__(\"8378\")[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r) {\n    var capability = newPromiseCapability(this);\n    var $$reject = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x) {\n    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(\"5cc5\")(function (iter) {\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform(function () {\n      var values = [];\n      var index = 0;\n      var remaining = 1;\n      forOf(iterable, false, function (promise) {\n        var $index = index++;\n        var alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      forOf(iterable, false, function (promise) {\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  }\n});\n\n\n/***/ }),\n\n/***/ \"5527\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n      /* harmony default export */ __webpack_exports__[\"default\"] = ({\n        functional: true,\n        render: \n      function render(_h, _vm) {\n        var _c=_vm._c;return _c('svg',{class:[_vm.data.class, _vm.data.staticClass],style:([_vm.data.style, _vm.data.staticStyle]),attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 33 32\"}},[_c('path',{attrs:{\"d\":\"M9.333 9.333h13.333v4L27.999 8l-5.333-5.333v4h-16v8h2.667V9.334zm13.334 13.334H9.334v-4L4.001 24l5.333 5.333v-4h16v-8h-2.667v5.333zM17.333 20v-8H16l-2.667 1.333v1.333h2v5.333h2z\"}})])\n      }\n    \n      });\n    \n\n/***/ }),\n\n/***/ \"5537\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar core = __webpack_require__(\"8378\");\nvar global = __webpack_require__(\"7726\");\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: __webpack_require__(\"2d00\") ? 'pure' : 'global',\n  copyright: '© 2018 Denis Pushkarev (zloirock.ru)'\n});\n\n\n/***/ }),\n\n/***/ \"55dd\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $export = __webpack_require__(\"5ca1\");\nvar aFunction = __webpack_require__(\"d8e8\");\nvar toObject = __webpack_require__(\"4bf8\");\nvar fails = __webpack_require__(\"79e5\");\nvar $sort = [].sort;\nvar test = [1, 2, 3];\n\n$export($export.P + $export.F * (fails(function () {\n  // IE8-\n  test.sort(undefined);\n}) || !fails(function () {\n  // V8 bug\n  test.sort(null);\n  // Old WebKit\n}) || !__webpack_require__(\"2f21\")($sort)), 'Array', {\n  // 22.1.3.25 Array.prototype.sort(comparefn)\n  sort: function sort(comparefn) {\n    return comparefn === undefined\n      ? $sort.call(toObject(this))\n      : $sort.call(toObject(this), aFunction(comparefn));\n  }\n});\n\n\n/***/ }),\n\n/***/ \"5ca1\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"7726\");\nvar core = __webpack_require__(\"8378\");\nvar hide = __webpack_require__(\"32e9\");\nvar redefine = __webpack_require__(\"2aba\");\nvar ctx = __webpack_require__(\"9b43\");\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n\n\n/***/ }),\n\n/***/ \"5cc5\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ITERATOR = __webpack_require__(\"2b4c\")('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(riter, function () { throw 2; });\n} catch (e) { /* empty */ }\n\nmodule.exports = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n\n\n/***/ }),\n\n/***/ \"5dbc\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"d3f4\");\nvar setPrototypeOf = __webpack_require__(\"8b97\").set;\nmodule.exports = function (that, target, C) {\n  var S = target.constructor;\n  var P;\n  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {\n    setPrototypeOf(that, P);\n  } return that;\n};\n\n\n/***/ }),\n\n/***/ \"5eda\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// most Object methods by ES6 should accept primitives\nvar $export = __webpack_require__(\"5ca1\");\nvar core = __webpack_require__(\"8378\");\nvar fails = __webpack_require__(\"79e5\");\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n\n\n/***/ }),\n\n/***/ \"610a\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"ab57\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(\"499e\").default\nvar update = add(\"4573c8b0\", content, true, {\"sourceMap\":false,\"shadowMode\":false});\n\n/***/ }),\n\n/***/ \"613b\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar shared = __webpack_require__(\"5537\")('keys');\nvar uid = __webpack_require__(\"ca5a\");\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n/***/ }),\n\n/***/ \"626a\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(\"2d95\");\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n/***/ }),\n\n/***/ \"65d9\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n  * vue-class-component v6.3.2\n  * (c) 2015-present Evan You\n  * @license MIT\n  */\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar Vue = _interopDefault(__webpack_require__(\"8bbf\"));\n\nvar reflectionIsSupported = typeof Reflect !== 'undefined' && Reflect.defineMetadata;\nfunction copyReflectionMetadata(to, from) {\n    forwardMetadata(to, from);\n    Object.getOwnPropertyNames(from.prototype).forEach(function (key) {\n        forwardMetadata(to.prototype, from.prototype, key);\n    });\n    Object.getOwnPropertyNames(from).forEach(function (key) {\n        forwardMetadata(to, from, key);\n    });\n}\nfunction forwardMetadata(to, from, propertyKey) {\n    var metaKeys = propertyKey\n        ? Reflect.getOwnMetadataKeys(from, propertyKey)\n        : Reflect.getOwnMetadataKeys(from);\n    metaKeys.forEach(function (metaKey) {\n        var metadata = propertyKey\n            ? Reflect.getOwnMetadata(metaKey, from, propertyKey)\n            : Reflect.getOwnMetadata(metaKey, from);\n        if (propertyKey) {\n            Reflect.defineMetadata(metaKey, metadata, to, propertyKey);\n        }\n        else {\n            Reflect.defineMetadata(metaKey, metadata, to);\n        }\n    });\n}\n\nvar fakeArray = { __proto__: [] };\nvar hasProto = fakeArray instanceof Array;\nfunction createDecorator(factory) {\n    return function (target, key, index) {\n        var Ctor = typeof target === 'function'\n            ? target\n            : target.constructor;\n        if (!Ctor.__decorators__) {\n            Ctor.__decorators__ = [];\n        }\n        if (typeof index !== 'number') {\n            index = undefined;\n        }\n        Ctor.__decorators__.push(function (options) { return factory(options, key, index); });\n    };\n}\nfunction mixins() {\n    var Ctors = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        Ctors[_i] = arguments[_i];\n    }\n    return Vue.extend({ mixins: Ctors });\n}\nfunction isPrimitive(value) {\n    var type = typeof value;\n    return value == null || (type !== 'object' && type !== 'function');\n}\nfunction warn(message) {\n    if (typeof console !== 'undefined') {\n        console.warn('[vue-class-component] ' + message);\n    }\n}\n\nfunction collectDataFromConstructor(vm, Component) {\n    // override _init to prevent to init as Vue instance\n    var originalInit = Component.prototype._init;\n    Component.prototype._init = function () {\n        var _this = this;\n        // proxy to actual vm\n        var keys = Object.getOwnPropertyNames(vm);\n        // 2.2.0 compat (props are no longer exposed as self properties)\n        if (vm.$options.props) {\n            for (var key in vm.$options.props) {\n                if (!vm.hasOwnProperty(key)) {\n                    keys.push(key);\n                }\n            }\n        }\n        keys.forEach(function (key) {\n            if (key.charAt(0) !== '_') {\n                Object.defineProperty(_this, key, {\n                    get: function () { return vm[key]; },\n                    set: function (value) { vm[key] = value; },\n                    configurable: true\n                });\n            }\n        });\n    };\n    // should be acquired class property values\n    var data = new Component();\n    // restore original _init to avoid memory leak (#209)\n    Component.prototype._init = originalInit;\n    // create plain data object\n    var plainData = {};\n    Object.keys(data).forEach(function (key) {\n        if (data[key] !== undefined) {\n            plainData[key] = data[key];\n        }\n    });\n    if (false) {}\n    return plainData;\n}\n\nvar $internalHooks = [\n    'data',\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeDestroy',\n    'destroyed',\n    'beforeUpdate',\n    'updated',\n    'activated',\n    'deactivated',\n    'render',\n    'errorCaptured' // 2.5\n];\nfunction componentFactory(Component, options) {\n    if (options === void 0) { options = {}; }\n    options.name = options.name || Component._componentTag || Component.name;\n    // prototype props.\n    var proto = Component.prototype;\n    Object.getOwnPropertyNames(proto).forEach(function (key) {\n        if (key === 'constructor') {\n            return;\n        }\n        // hooks\n        if ($internalHooks.indexOf(key) > -1) {\n            options[key] = proto[key];\n            return;\n        }\n        var descriptor = Object.getOwnPropertyDescriptor(proto, key);\n        if (descriptor.value !== void 0) {\n            // methods\n            if (typeof descriptor.value === 'function') {\n                (options.methods || (options.methods = {}))[key] = descriptor.value;\n            }\n            else {\n                // typescript decorated data\n                (options.mixins || (options.mixins = [])).push({\n                    data: function () {\n                        var _a;\n                        return _a = {}, _a[key] = descriptor.value, _a;\n                    }\n                });\n            }\n        }\n        else if (descriptor.get || descriptor.set) {\n            // computed properties\n            (options.computed || (options.computed = {}))[key] = {\n                get: descriptor.get,\n                set: descriptor.set\n            };\n        }\n    });\n    (options.mixins || (options.mixins = [])).push({\n        data: function () {\n            return collectDataFromConstructor(this, Component);\n        }\n    });\n    // decorate options\n    var decorators = Component.__decorators__;\n    if (decorators) {\n        decorators.forEach(function (fn) { return fn(options); });\n        delete Component.__decorators__;\n    }\n    // find super\n    var superProto = Object.getPrototypeOf(Component.prototype);\n    var Super = superProto instanceof Vue\n        ? superProto.constructor\n        : Vue;\n    var Extended = Super.extend(options);\n    forwardStaticMembers(Extended, Component, Super);\n    if (reflectionIsSupported) {\n        copyReflectionMetadata(Extended, Component);\n    }\n    return Extended;\n}\nvar reservedPropertyNames = [\n    // Unique id\n    'cid',\n    // Super Vue constructor\n    'super',\n    // Component options that will be used by the component\n    'options',\n    'superOptions',\n    'extendOptions',\n    'sealedOptions',\n    // Private assets\n    'component',\n    'directive',\n    'filter'\n];\nfunction forwardStaticMembers(Extended, Original, Super) {\n    // We have to use getOwnPropertyNames since Babel registers methods as non-enumerable\n    Object.getOwnPropertyNames(Original).forEach(function (key) {\n        // `prototype` should not be overwritten\n        if (key === 'prototype') {\n            return;\n        }\n        // Some browsers does not allow reconfigure built-in properties\n        var extendedDescriptor = Object.getOwnPropertyDescriptor(Extended, key);\n        if (extendedDescriptor && !extendedDescriptor.configurable) {\n            return;\n        }\n        var descriptor = Object.getOwnPropertyDescriptor(Original, key);\n        // If the user agent does not support `__proto__` or its family (IE <= 10),\n        // the sub class properties may be inherited properties from the super class in TypeScript.\n        // We need to exclude such properties to prevent to overwrite\n        // the component options object which stored on the extended constructor (See #192).\n        // If the value is a referenced value (object or function),\n        // we can check equality of them and exclude it if they have the same reference.\n        // If it is a primitive value, it will be forwarded for safety.\n        if (!hasProto) {\n            // Only `cid` is explicitly exluded from property forwarding\n            // because we cannot detect whether it is a inherited property or not\n            // on the no `__proto__` environment even though the property is reserved.\n            if (key === 'cid') {\n                return;\n            }\n            var superDescriptor = Object.getOwnPropertyDescriptor(Super, key);\n            if (!isPrimitive(descriptor.value) &&\n                superDescriptor &&\n                superDescriptor.value === descriptor.value) {\n                return;\n            }\n        }\n        // Warn if the users manually declare reserved properties\n        if (false) {}\n        Object.defineProperty(Extended, key, descriptor);\n    });\n}\n\nfunction Component(options) {\n    if (typeof options === 'function') {\n        return componentFactory(options);\n    }\n    return function (Component) {\n        return componentFactory(Component, options);\n    };\n}\nComponent.registerHooks = function registerHooks(keys) {\n    $internalHooks.push.apply($internalHooks, keys);\n};\n\nexports.default = Component;\nexports.createDecorator = createDecorator;\nexports.mixins = mixins;\n\n\n/***/ }),\n\n/***/ \"66a1\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction handleEvent(event, filters, handler) {\n    for (var _i = 0, filters_1 = filters; _i < filters_1.length; _i++) {\n        var filter = filters_1[_i];\n        if (!filter(event)) {\n            return;\n        }\n    }\n    if (handler) {\n        handler(event);\n    }\n}\nvar keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    down: 40,\n    del: [8, 46],\n    left: 37,\n    right: 39\n};\nfunction createKeyFilter(keys) {\n    var codes = [];\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n        if (typeof key === \"number\") {\n            codes.push(key);\n        }\n        else {\n            var code = keyCodes[key];\n            if (typeof code === \"number\") {\n                codes.push(code);\n            }\n            else {\n                codes.push.apply(codes, code);\n            }\n        }\n    }\n    switch (codes.length) {\n        case 0:\n            return function (_) { return false; };\n        case 1:\n            var code_1 = codes[0];\n            return function (e) { return e.keyCode === code_1; };\n        default:\n            return function (e) { return codes.indexOf(e.keyCode) >= 0; };\n    }\n}\nfunction defineChildModifier(target, currentFilters, name, filter, children) {\n    Object.defineProperty(target, name, {\n        get: function () {\n            // call this getter at most once.\n            // reuse created instance after next time.\n            var ret = createModifier(currentFilters.concat([filter]), children);\n            Object.defineProperty(target, name, {\n                value: ret,\n                enumerable: true\n            });\n            return ret;\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\nfunction defineKeyCodeModifiers(target, filters, children) {\n    var _loop_1 = function (name_1) {\n        var keyName = name_1;\n        if (keyName === \"left\" || keyName === \"right\") {\n            return \"continue\";\n        }\n        var code = keyCodes[keyName];\n        if (typeof code === \"number\") {\n            defineChildModifier(target, filters, keyName, function (e) { return e.keyCode === code; }, children);\n        }\n        else {\n            var c1_1 = code[0], c2_1 = code[1];\n            defineChildModifier(target, filters, keyName, function (e) { return e.keyCode === c1_1 || e.keyCode === c2_1; }, children);\n        }\n    };\n    for (var name_1 in keyCodes) {\n        _loop_1(name_1);\n    }\n}\nfunction defineKeys(target, filters, children) {\n    Object.defineProperty(target, \"keys\", {\n        get: function () {\n            var _this = this;\n            var keysFunction = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var propName = \"keys:\" + args.toString();\n                var modifier = _this[propName];\n                if (modifier !== undefined) {\n                    return modifier;\n                }\n                var filter = createKeyFilter(args);\n                defineChildModifier(_this, filters, propName, filter, children);\n                return _this[propName];\n            };\n            Object.defineProperty(this, \"keys\", {\n                value: keysFunction,\n                enumerable: true\n            });\n            return keysFunction;\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\nfunction defineExact(target, filters, children) {\n    Object.defineProperty(target, \"exact\", {\n        get: function () {\n            var _this = this;\n            var exactFunction = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var propName = \"exact:\" + args.toString();\n                var modifier = _this[propName];\n                if (modifier !== undefined) {\n                    return modifier;\n                }\n                var expected = {\n                    ctrl: false,\n                    shift: false,\n                    alt: false,\n                    meta: false\n                };\n                args.forEach(function (arg) { return (expected[arg] = true); });\n                var filter = function (e) {\n                    return !!e.ctrlKey === expected.ctrl &&\n                        !!e.shiftKey === expected.shift &&\n                        !!e.altKey === expected.alt &&\n                        !!e.metaKey === expected.meta;\n                };\n                defineChildModifier(_this, filters, propName, filter, children);\n                return _this[propName];\n            };\n            Object.defineProperty(this, \"exact\", {\n                value: exactFunction,\n                enumerable: true\n            });\n            return exactFunction;\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\nfunction createModifier(filters, children) {\n    function m(arg) {\n        if (arg instanceof Function) {\n            // EventHandler => EventHandler\n            return function (event) { return handleEvent(event, filters, arg); };\n        }\n        else {\n            // Event => void\n            handleEvent(arg, filters);\n            return;\n        }\n    }\n    if (children.keyboard || children.mouse) {\n        var nextChildren = __assign({}, children, { keyboard: false, mouse: false });\n        if (children.keyboard) {\n            defineKeyCodeModifiers(m, filters, nextChildren);\n            defineKeys(m, filters, nextChildren);\n        }\n        if (children.mouse) {\n            defineChildModifier(m, filters, \"middle\", function (e) { return e.button === 1; }, nextChildren);\n        }\n        defineChildModifier(m, filters, \"left\", function (e) { return e.keyCode === 37 || e.button === 0; }, nextChildren);\n        defineChildModifier(m, filters, \"right\", function (e) { return e.keyCode === 39 || e.button === 2; }, nextChildren);\n    }\n    if (children.exact) {\n        var nextChildren = __assign({}, children, { exact: false, modkey: false });\n        defineExact(m, filters, nextChildren);\n    }\n    if (children.modkey) {\n        var nextChildren = __assign({}, children, { exact: false });\n        defineChildModifier(m, filters, \"ctrl\", function (e) { return e.ctrlKey; }, nextChildren);\n        defineChildModifier(m, filters, \"shift\", function (e) { return e.shiftKey; }, nextChildren);\n        defineChildModifier(m, filters, \"alt\", function (e) { return e.altKey; }, nextChildren);\n        defineChildModifier(m, filters, \"meta\", function (e) { return e.metaKey; }, nextChildren);\n        defineChildModifier(m, filters, \"noctrl\", function (e) { return !e.ctrlKey; }, nextChildren);\n        defineChildModifier(m, filters, \"noshift\", function (e) { return !e.shiftKey; }, nextChildren);\n        defineChildModifier(m, filters, \"noalt\", function (e) { return !e.altKey; }, nextChildren);\n        defineChildModifier(m, filters, \"nometa\", function (e) { return !e.metaKey; }, nextChildren);\n    }\n    defineChildModifier(m, filters, \"stop\", function (e) { return e.stopPropagation() || true; }, children);\n    defineChildModifier(m, filters, \"prevent\", function (e) { return e.preventDefault() || true; }, children);\n    defineChildModifier(m, filters, \"self\", function (e) { return e.target === e.currentTarget; }, children);\n    return m;\n}\nexports.modifiers = createModifier([], {\n    keyboard: true,\n    mouse: true,\n    modkey: true,\n    exact: true\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kaWZpZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL21vZGlmaWVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBb0RBLHFCQUNFLEtBQVksRUFDWixPQUFzQixFQUN0QixPQUE2QjtJQUU3QixLQUFtQixVQUFPLEVBQVAsbUJBQU8sRUFBUCxxQkFBTyxFQUFQLElBQU87UUFBckIsSUFBSSxNQUFNLGdCQUFBO1FBQ2IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNsQixPQUFPO1NBQ1I7S0FDRjtJQUNELElBQUksT0FBTyxFQUFFO1FBQ1gsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ2hCO0FBQ0gsQ0FBQztBQUVELElBQU0sUUFBUSxHQUEwRDtJQUN0RSxHQUFHLEVBQUUsRUFBRTtJQUNQLEdBQUcsRUFBRSxDQUFDO0lBQ04sS0FBSyxFQUFFLEVBQUU7SUFDVCxLQUFLLEVBQUUsRUFBRTtJQUNULEVBQUUsRUFBRSxFQUFFO0lBQ04sSUFBSSxFQUFFLEVBQUU7SUFDUixHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0lBQ1osSUFBSSxFQUFFLEVBQUU7SUFDUixLQUFLLEVBQUUsRUFBRTtDQUNWLENBQUM7QUFFRix5QkFBeUIsSUFBa0M7SUFDekQsSUFBTSxLQUFLLEdBQUcsRUFBYyxDQUFDO0lBQzdCLEtBQWtCLFVBQUksRUFBSixhQUFJLEVBQUosa0JBQUksRUFBSixJQUFJO1FBQWpCLElBQU0sR0FBRyxhQUFBO1FBQ1osSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7WUFDM0IsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNqQjthQUFNO1lBQ0wsSUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzNCLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFO2dCQUM1QixLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ2xCO2lCQUFNO2dCQUNMLEtBQUssQ0FBQyxJQUFJLE9BQVYsS0FBSyxFQUFTLElBQUksRUFBRTthQUNyQjtTQUNGO0tBQ0Y7SUFDRCxRQUFRLEtBQUssQ0FBQyxNQUFNLEVBQUU7UUFDcEIsS0FBSyxDQUFDO1lBQ0osT0FBTyxVQUFBLENBQUMsSUFBSSxPQUFBLEtBQUssRUFBTCxDQUFLLENBQUM7UUFDcEIsS0FBSyxDQUFDO1lBQ0osSUFBTSxNQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RCLE9BQU8sVUFBQyxDQUFNLElBQUssT0FBQSxDQUFDLENBQUMsT0FBTyxLQUFLLE1BQUksRUFBbEIsQ0FBa0IsQ0FBQztRQUN4QztZQUNFLE9BQU8sVUFBQyxDQUFNLElBQUssT0FBQSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQTdCLENBQTZCLENBQUM7S0FDcEQ7QUFDSCxDQUFDO0FBU0QsNkJBQ0UsTUFBZ0IsRUFDaEIsY0FBNkIsRUFDN0IsSUFBWSxFQUNaLE1BQW1CLEVBQ25CLFFBQTZCO0lBRTdCLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRTtRQUNsQyxHQUFHLEVBQUU7WUFDSCxpQ0FBaUM7WUFDakMsMENBQTBDO1lBQzFDLElBQU0sR0FBRyxHQUFHLGNBQWMsQ0FBSyxjQUFjLFNBQUUsTUFBTSxJQUFHLFFBQVEsQ0FBQyxDQUFDO1lBQ2xFLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRTtnQkFDbEMsS0FBSyxFQUFFLEdBQUc7Z0JBQ1YsVUFBVSxFQUFFLElBQUk7YUFDakIsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDO1FBQ0QsVUFBVSxFQUFFLElBQUk7UUFDaEIsWUFBWSxFQUFFLElBQUk7S0FDbkIsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELGdDQUNFLE1BQWdCLEVBQ2hCLE9BQXNCLEVBQ3RCLFFBQTZCOzRCQUVsQixNQUFJO1FBQ2IsSUFBTSxPQUFPLEdBQUcsTUFBdUIsQ0FBQztRQUN4QyxJQUFJLE9BQU8sS0FBSyxNQUFNLElBQUksT0FBTyxLQUFLLE9BQU8sRUFBRTs7U0FFOUM7UUFDRCxJQUFNLElBQUksR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDL0IsSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRLEVBQUU7WUFDNUIsbUJBQW1CLENBQ2pCLE1BQU0sRUFDTixPQUFPLEVBQ1AsT0FBTyxFQUNQLFVBQUMsQ0FBTSxJQUFLLE9BQUEsQ0FBQyxDQUFDLE9BQU8sS0FBSyxJQUFJLEVBQWxCLENBQWtCLEVBQzlCLFFBQVEsQ0FDVCxDQUFDO1NBQ0g7YUFBTTtZQUNFLElBQUEsY0FBRSxFQUFFLGNBQUUsQ0FBUztZQUN0QixtQkFBbUIsQ0FDakIsTUFBTSxFQUNOLE9BQU8sRUFDUCxPQUFPLEVBQ1AsVUFBQyxDQUFNLElBQUssT0FBQSxDQUFDLENBQUMsT0FBTyxLQUFLLElBQUUsSUFBSSxDQUFDLENBQUMsT0FBTyxLQUFLLElBQUUsRUFBcEMsQ0FBb0MsRUFDaEQsUUFBUSxDQUNULENBQUM7U0FDSDtJQUNILENBQUM7SUF4QkQsS0FBSyxJQUFNLE1BQUksSUFBSSxRQUFRO2dCQUFoQixNQUFJO0tBd0JkO0FBQ0gsQ0FBQztBQUVELG9CQUNFLE1BQWdCLEVBQ2hCLE9BQXNCLEVBQ3RCLFFBQTZCO0lBRTdCLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRTtRQUNwQyxHQUFHO1lBQUgsaUJBZ0JDO1lBZkMsSUFBTSxZQUFZLEdBQUc7Z0JBQUMsY0FBcUM7cUJBQXJDLFVBQXFDLEVBQXJDLHFCQUFxQyxFQUFyQyxJQUFxQztvQkFBckMseUJBQXFDOztnQkFDekQsSUFBTSxRQUFRLEdBQUcsT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDM0MsSUFBTSxRQUFRLEdBQUcsS0FBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUNoQyxJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7b0JBQzFCLE9BQU8sUUFBUSxDQUFDO2lCQUNqQjtnQkFDRCxJQUFNLE1BQU0sR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3JDLG1CQUFtQixDQUFDLEtBQUksRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFDL0QsT0FBTyxLQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDeEIsQ0FBQyxDQUFDO1lBQ0YsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFO2dCQUNsQyxLQUFLLEVBQUUsWUFBWTtnQkFDbkIsVUFBVSxFQUFFLElBQUk7YUFDakIsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxZQUFZLENBQUM7UUFDdEIsQ0FBQztRQUNELFVBQVUsRUFBRSxJQUFJO1FBQ2hCLFlBQVksRUFBRSxJQUFJO0tBQ25CLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCxxQkFDRSxNQUFnQixFQUNoQixPQUFzQixFQUN0QixRQUE2QjtJQUU3QixNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUU7UUFDckMsR0FBRztZQUFILGlCQTJCQztZQTFCQyxJQUFNLGFBQWEsR0FBRztnQkFBQyxjQUFpQjtxQkFBakIsVUFBaUIsRUFBakIscUJBQWlCLEVBQWpCLElBQWlCO29CQUFqQix5QkFBaUI7O2dCQUN0QyxJQUFNLFFBQVEsR0FBRyxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUM1QyxJQUFNLFFBQVEsR0FBRyxLQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQ2hDLElBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtvQkFDMUIsT0FBTyxRQUFRLENBQUM7aUJBQ2pCO2dCQUNELElBQU0sUUFBUSxHQUFHO29CQUNmLElBQUksRUFBRSxLQUFLO29CQUNYLEtBQUssRUFBRSxLQUFLO29CQUNaLEdBQUcsRUFBRSxLQUFLO29CQUNWLElBQUksRUFBRSxLQUFLO2lCQUNaLENBQUM7Z0JBQ0YsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFBLEdBQUcsSUFBSSxPQUFBLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUF0QixDQUFzQixDQUFDLENBQUM7Z0JBQzVDLElBQU0sTUFBTSxHQUFHLFVBQUMsQ0FBTTtvQkFDcEIsT0FBQSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sS0FBSyxRQUFRLENBQUMsSUFBSTt3QkFDN0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEtBQUssUUFBUSxDQUFDLEtBQUs7d0JBQy9CLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLFFBQVEsQ0FBQyxHQUFHO3dCQUMzQixDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sS0FBSyxRQUFRLENBQUMsSUFBSTtnQkFIN0IsQ0FHNkIsQ0FBQztnQkFDaEMsbUJBQW1CLENBQUMsS0FBSSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2dCQUMvRCxPQUFPLEtBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN4QixDQUFDLENBQUM7WUFDRixNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUU7Z0JBQ25DLEtBQUssRUFBRSxhQUFhO2dCQUNwQixVQUFVLEVBQUUsSUFBSTthQUNqQixDQUFDLENBQUM7WUFDSCxPQUFPLGFBQWEsQ0FBQztRQUN2QixDQUFDO1FBQ0QsVUFBVSxFQUFFLElBQUk7UUFDaEIsWUFBWSxFQUFFLElBQUk7S0FDbkIsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELHdCQUNFLE9BQXNCLEVBQ3RCLFFBQTZCO0lBRTdCLFdBQVcsR0FBUTtRQUNqQixJQUFJLEdBQUcsWUFBWSxRQUFRLEVBQUU7WUFDM0IsK0JBQStCO1lBQy9CLE9BQU8sVUFBQyxLQUFZLElBQUssT0FBQSxXQUFXLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxHQUFHLENBQUMsRUFBaEMsQ0FBZ0MsQ0FBQztTQUMzRDthQUFNO1lBQ0wsZ0JBQWdCO1lBQ2hCLFdBQVcsQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDMUIsT0FBTztTQUNSO0lBQ0gsQ0FBQztJQUNELElBQUksUUFBUSxDQUFDLFFBQVEsSUFBSSxRQUFRLENBQUMsS0FBSyxFQUFFO1FBQ3ZDLElBQU0sWUFBWSxnQkFBUSxRQUFRLElBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxHQUFFLENBQUM7UUFDcEUsSUFBSSxRQUFRLENBQUMsUUFBUSxFQUFFO1lBQ3JCLHNCQUFzQixDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFDakQsVUFBVSxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUM7U0FDdEM7UUFDRCxJQUFJLFFBQVEsQ0FBQyxLQUFLLEVBQUU7WUFDbEIsbUJBQW1CLENBQ2pCLENBQUMsRUFDRCxPQUFPLEVBQ1AsUUFBUSxFQUNSLFVBQUMsQ0FBTSxJQUFLLE9BQUEsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQWQsQ0FBYyxFQUMxQixZQUFZLENBQ2IsQ0FBQztTQUNIO1FBQ0QsbUJBQW1CLENBQ2pCLENBQUMsRUFDRCxPQUFPLEVBQ1AsTUFBTSxFQUNOLFVBQUMsQ0FBTSxJQUFLLE9BQUEsQ0FBQyxDQUFDLE9BQU8sS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQWxDLENBQWtDLEVBQzlDLFlBQVksQ0FDYixDQUFDO1FBQ0YsbUJBQW1CLENBQ2pCLENBQUMsRUFDRCxPQUFPLEVBQ1AsT0FBTyxFQUNQLFVBQUMsQ0FBTSxJQUFLLE9BQUEsQ0FBQyxDQUFDLE9BQU8sS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQWxDLENBQWtDLEVBQzlDLFlBQVksQ0FDYixDQUFDO0tBQ0g7SUFDRCxJQUFJLFFBQVEsQ0FBQyxLQUFLLEVBQUU7UUFDbEIsSUFBTSxZQUFZLGdCQUFRLFFBQVEsSUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEdBQUUsQ0FBQztRQUNsRSxXQUFXLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztLQUN2QztJQUNELElBQUksUUFBUSxDQUFDLE1BQU0sRUFBRTtRQUNuQixJQUFNLFlBQVksZ0JBQVEsUUFBUSxJQUFFLEtBQUssRUFBRSxLQUFLLEdBQUUsQ0FBQztRQUNuRCxtQkFBbUIsQ0FDakIsQ0FBQyxFQUNELE9BQU8sRUFDUCxNQUFNLEVBQ04sVUFBQyxDQUFNLElBQUssT0FBQSxDQUFDLENBQUMsT0FBTyxFQUFULENBQVMsRUFDckIsWUFBWSxDQUNiLENBQUM7UUFDRixtQkFBbUIsQ0FDakIsQ0FBQyxFQUNELE9BQU8sRUFDUCxPQUFPLEVBQ1AsVUFBQyxDQUFNLElBQUssT0FBQSxDQUFDLENBQUMsUUFBUSxFQUFWLENBQVUsRUFDdEIsWUFBWSxDQUNiLENBQUM7UUFDRixtQkFBbUIsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxVQUFDLENBQU0sSUFBSyxPQUFBLENBQUMsQ0FBQyxNQUFNLEVBQVIsQ0FBUSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQzNFLG1CQUFtQixDQUNqQixDQUFDLEVBQ0QsT0FBTyxFQUNQLE1BQU0sRUFDTixVQUFDLENBQU0sSUFBSyxPQUFBLENBQUMsQ0FBQyxPQUFPLEVBQVQsQ0FBUyxFQUNyQixZQUFZLENBQ2IsQ0FBQztRQUVGLG1CQUFtQixDQUNqQixDQUFDLEVBQ0QsT0FBTyxFQUNQLFFBQVEsRUFDUixVQUFDLENBQU0sSUFBSyxPQUFBLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBVixDQUFVLEVBQ3RCLFlBQVksQ0FDYixDQUFDO1FBQ0YsbUJBQW1CLENBQ2pCLENBQUMsRUFDRCxPQUFPLEVBQ1AsU0FBUyxFQUNULFVBQUMsQ0FBTSxJQUFLLE9BQUEsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFYLENBQVcsRUFDdkIsWUFBWSxDQUNiLENBQUM7UUFDRixtQkFBbUIsQ0FDakIsQ0FBQyxFQUNELE9BQU8sRUFDUCxPQUFPLEVBQ1AsVUFBQyxDQUFNLElBQUssT0FBQSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQVQsQ0FBUyxFQUNyQixZQUFZLENBQ2IsQ0FBQztRQUNGLG1CQUFtQixDQUNqQixDQUFDLEVBQ0QsT0FBTyxFQUNQLFFBQVEsRUFDUixVQUFDLENBQU0sSUFBSyxPQUFBLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBVixDQUFVLEVBQ3RCLFlBQVksQ0FDYixDQUFDO0tBQ0g7SUFDRCxtQkFBbUIsQ0FDakIsQ0FBQyxFQUNELE9BQU8sRUFDUCxNQUFNLEVBQ04sVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsZUFBZSxFQUFFLElBQUksSUFBSSxFQUEzQixDQUEyQixFQUNoQyxRQUFRLENBQ1QsQ0FBQztJQUNGLG1CQUFtQixDQUNqQixDQUFDLEVBQ0QsT0FBTyxFQUNQLFNBQVMsRUFDVCxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxjQUFjLEVBQUUsSUFBSSxJQUFJLEVBQTFCLENBQTBCLEVBQy9CLFFBQVEsQ0FDVCxDQUFDO0lBQ0YsbUJBQW1CLENBQ2pCLENBQUMsRUFDRCxPQUFPLEVBQ1AsTUFBTSxFQUNOLFVBQUEsQ0FBQyxJQUFJLE9BQUEsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsYUFBYSxFQUE1QixDQUE0QixFQUNqQyxRQUFRLENBQ1QsQ0FBQztJQUNGLE9BQU8sQ0FBMkIsQ0FBQztBQUNyQyxDQUFDO0FBRVksUUFBQSxTQUFTLEdBQUcsY0FBYyxDQUFDLEVBQUUsRUFBRTtJQUMxQyxRQUFRLEVBQUUsSUFBSTtJQUNkLEtBQUssRUFBRSxJQUFJO0lBQ1gsTUFBTSxFQUFFLElBQUk7SUFDWixLQUFLLEVBQUUsSUFBSTtDQUNaLENBQUMsQ0FBQyJ9\n\n/***/ }),\n\n/***/ \"6762\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// https://github.com/tc39/Array.prototype.includes\nvar $export = __webpack_require__(\"5ca1\");\nvar $includes = __webpack_require__(\"c366\")(true);\n\n$export($export.P, 'Array', {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n__webpack_require__(\"9c6c\")('includes');\n\n\n/***/ }),\n\n/***/ \"6821\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(\"626a\");\nvar defined = __webpack_require__(\"be13\");\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n\n\n/***/ }),\n\n/***/ \"69a8\":\n/***/ (function(module, exports) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n/***/ }),\n\n/***/ \"6a99\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(\"d3f4\");\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n/***/ }),\n\n/***/ \"6b54\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n__webpack_require__(\"3846\");\nvar anObject = __webpack_require__(\"cb7c\");\nvar $flags = __webpack_require__(\"0bfb\");\nvar DESCRIPTORS = __webpack_require__(\"9e1e\");\nvar TO_STRING = 'toString';\nvar $toString = /./[TO_STRING];\n\nvar define = function (fn) {\n  __webpack_require__(\"2aba\")(RegExp.prototype, TO_STRING, fn, true);\n};\n\n// 21.2.5.14 RegExp.prototype.toString()\nif (__webpack_require__(\"79e5\")(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {\n  define(function toString() {\n    var R = anObject(this);\n    return '/'.concat(R.source, '/',\n      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);\n  });\n// FF44- RegExp#toString has a wrong name\n} else if ($toString.name != TO_STRING) {\n  define(function toString() {\n    return $toString.call(this);\n  });\n}\n\n\n/***/ }),\n\n/***/ \"7333\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys = __webpack_require__(\"0d58\");\nvar gOPS = __webpack_require__(\"2621\");\nvar pIE = __webpack_require__(\"52a7\");\nvar toObject = __webpack_require__(\"4bf8\");\nvar IObject = __webpack_require__(\"626a\");\nvar $assign = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || __webpack_require__(\"79e5\")(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var S = Symbol();\n  var K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function (k) { B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var aLen = arguments.length;\n  var index = 1;\n  var getSymbols = gOPS.f;\n  var isEnum = pIE.f;\n  while (aLen > index) {\n    var S = IObject(arguments[index++]);\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n  } return T;\n} : $assign;\n\n\n/***/ }),\n\n/***/ \"7514\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\nvar $export = __webpack_require__(\"5ca1\");\nvar $find = __webpack_require__(\"0a49\")(5);\nvar KEY = 'find';\nvar forced = true;\n// Shouldn't skip holes\nif (KEY in []) Array(1)[KEY](function () { forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  find: function find(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n__webpack_require__(\"9c6c\")(KEY);\n\n\n/***/ }),\n\n/***/ \"7726\":\n/***/ (function(module, exports) {\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n\n/***/ }),\n\n/***/ \"77f1\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(\"4588\");\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n/***/ }),\n\n/***/ \"79e5\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n\n/***/ }),\n\n/***/ \"7a1a\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n      /* harmony default export */ __webpack_exports__[\"default\"] = ({\n        functional: true,\n        render: \n      function render(_h, _vm) {\n        var _c=_vm._c;return _c('svg',{class:[_vm.data.class, _vm.data.staticClass],style:([_vm.data.style, _vm.data.staticStyle]),attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 32 32\"}},[_c('path',{attrs:{\"d\":\"M22.667 4l7 6-7 6 7 6-7 6v-4h-3.653l-3.76-3.76 2.827-2.827L20.668 20h2v-8h-2l-12 12h-6v-4h4.347l12-12h3.653V4zm-20 4h6l3.76 3.76L9.6 14.587 7.013 12H2.666V8z\"}})])\n      }\n    \n      });\n    \n\n/***/ }),\n\n/***/ \"7a56\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar global = __webpack_require__(\"7726\");\nvar dP = __webpack_require__(\"86cc\");\nvar DESCRIPTORS = __webpack_require__(\"9e1e\");\nvar SPECIES = __webpack_require__(\"2b4c\")('species');\n\nmodule.exports = function (KEY) {\n  var C = global[KEY];\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n\n\n/***/ }),\n\n/***/ \"7f20\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar def = __webpack_require__(\"86cc\").f;\nvar has = __webpack_require__(\"69a8\");\nvar TAG = __webpack_require__(\"2b4c\")('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n\n\n/***/ }),\n\n/***/ \"7f7f\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP = __webpack_require__(\"86cc\").f;\nvar FProto = Function.prototype;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// 19.2.4.2 name\nNAME in FProto || __webpack_require__(\"9e1e\") && dP(FProto, NAME, {\n  configurable: true,\n  get: function () {\n    try {\n      return ('' + this).match(nameRE)[1];\n    } catch (e) {\n      return '';\n    }\n  }\n});\n\n\n/***/ }),\n\n/***/ \"8079\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"7726\");\nvar macrotask = __webpack_require__(\"1991\").set;\nvar Observer = global.MutationObserver || global.WebKitMutationObserver;\nvar process = global.process;\nvar Promise = global.Promise;\nvar isNode = __webpack_require__(\"2d95\")(process) == 'process';\n\nmodule.exports = function () {\n  var head, last, notify;\n\n  var flush = function () {\n    var parent, fn;\n    if (isNode && (parent = process.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (e) {\n        if (head) notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // Node.js\n  if (isNode) {\n    notify = function () {\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339\n  } else if (Observer && !(global.navigator && global.navigator.standalone)) {\n    var toggle = true;\n    var node = document.createTextNode('');\n    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\n    notify = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (Promise && Promise.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    var promise = Promise.resolve(undefined);\n    notify = function () {\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function () {\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function (fn) {\n    var task = { fn: fn, next: undefined };\n    if (last) last.next = task;\n    if (!head) {\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n\n\n/***/ }),\n\n/***/ \"8378\":\n/***/ (function(module, exports) {\n\nvar core = module.exports = { version: '2.5.7' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n\n/***/ }),\n\n/***/ \"84d8\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n      /* harmony default export */ __webpack_exports__[\"default\"] = ({\n        functional: true,\n        render: \n      function render(_h, _vm) {\n        var _c=_vm._c;return _c('svg',{class:[_vm.data.class, _vm.data.staticClass],style:([_vm.data.style, _vm.data.staticStyle]),attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 16 31\"}},[_c('path',{attrs:{\"d\":\"M15.552 15.168q.448.32.448.832 0 .448-.448.768L1.856 25.28q-.768.512-1.312.192T0 24.192V7.744q0-.96.544-1.28t1.312.192z\"}})])\n      }\n    \n      });\n    \n\n/***/ }),\n\n/***/ \"84f2\":\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n\n/***/ }),\n\n/***/ \"86cc\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(\"cb7c\");\nvar IE8_DOM_DEFINE = __webpack_require__(\"c69a\");\nvar toPrimitive = __webpack_require__(\"6a99\");\nvar dP = Object.defineProperty;\n\nexports.f = __webpack_require__(\"9e1e\") ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n/***/ }),\n\n/***/ \"885d\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n      /* harmony default export */ __webpack_exports__[\"default\"] = ({\n        functional: true,\n        render: \n      function render(_h, _vm) {\n        var _c=_vm._c;return _c('svg',{class:[_vm.data.class, _vm.data.staticClass],style:([_vm.data.style, _vm.data.staticStyle]),attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 32 32\"}},[_c('path',{attrs:{\"d\":\"M4 16C4 9.4 9.4 4 16 4s12 5.4 12 12c0 1.2-.8 2-2 2s-2-.8-2-2c0-4.4-3.6-8-8-8s-8 3.6-8 8 3.6 8 8 8c1.2 0 2 .8 2 2s-.8 2-2 2C9.4 28 4 22.6 4 16z\"}})])\n      }\n    \n      });\n    \n\n/***/ }),\n\n/***/ \"8b97\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = __webpack_require__(\"d3f4\");\nvar anObject = __webpack_require__(\"cb7c\");\nvar check = function (O, proto) {\n  anObject(O);\n  if (!isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function (test, buggy, set) {\n      try {\n        set = __webpack_require__(\"9b43\")(Function.call, __webpack_require__(\"11e9\").f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch (e) { buggy = true; }\n      return function setPrototypeOf(O, proto) {\n        check(O, proto);\n        if (buggy) O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n\n\n/***/ }),\n\n/***/ \"8bbf\":\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"vue\");\n\n/***/ }),\n\n/***/ \"906b\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n      /* harmony default export */ __webpack_exports__[\"default\"] = ({\n        functional: true,\n        render: \n      function render(_h, _vm) {\n        var _c=_vm._c;return _c('svg',{class:[_vm.data.class, _vm.data.staticClass],style:([_vm.data.style, _vm.data.staticStyle]),attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 22 32\"}},[_c('path',{attrs:{\"d\":\"M20.8 14.4q.704 0 1.152.48T22.4 16t-.48 1.12-1.12.48H1.6q-.64 0-1.12-.48T0 16t.448-1.12T1.6 14.4h19.2zM1.6 11.2q-.64 0-1.12-.48T0 9.6t.448-1.12T1.6 8h19.2q.704 0 1.152.48T22.4 9.6t-.48 1.12-1.12.48H1.6zm19.2 9.6q.704 0 1.152.48t.448 1.12-.48 1.12-1.12.48H1.6q-.64 0-1.12-.48T0 22.4t.448-1.12T1.6 20.8h19.2z\"}})])\n      }\n    \n      });\n    \n\n/***/ }),\n\n/***/ \"9093\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = __webpack_require__(\"ce10\");\nvar hiddenKeys = __webpack_require__(\"e11e\").concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n\n\n/***/ }),\n\n/***/ \"96cf\":\n/***/ (function(module, exports) {\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n/***/ }),\n\n/***/ \"9744\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar toInteger = __webpack_require__(\"4588\");\nvar defined = __webpack_require__(\"be13\");\n\nmodule.exports = function repeat(count) {\n  var str = String(defined(this));\n  var res = '';\n  var n = toInteger(count);\n  if (n < 0 || n == Infinity) throw RangeError(\"Count can't be negative\");\n  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;\n  return res;\n};\n\n\n/***/ }),\n\n/***/ \"9b43\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// optional / simple context binding\nvar aFunction = __webpack_require__(\"d8e8\");\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/***/ }),\n\n/***/ \"9c6c\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = __webpack_require__(\"2b4c\")('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(\"32e9\")(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function (key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n\n\n/***/ }),\n\n/***/ \"9c80\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return { e: false, v: exec() };\n  } catch (e) {\n    return { e: true, v: e };\n  }\n};\n\n\n/***/ }),\n\n/***/ \"9def\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.15 ToLength\nvar toInteger = __webpack_require__(\"4588\");\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n/***/ }),\n\n/***/ \"9e1e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(\"79e5\")(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ \"a25f\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"7726\");\nvar navigator = global.navigator;\n\nmodule.exports = navigator && navigator.userAgent || '';\n\n\n/***/ }),\n\n/***/ \"a481\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// @@replace logic\n__webpack_require__(\"214f\")('replace', 2, function (defined, REPLACE, $replace) {\n  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)\n  return [function replace(searchValue, replaceValue) {\n    'use strict';\n    var O = defined(this);\n    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];\n    return fn !== undefined\n      ? fn.call(searchValue, O, replaceValue)\n      : $replace.call(String(O), searchValue, replaceValue);\n  }, $replace];\n});\n\n\n/***/ }),\n\n/***/ \"a5b8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// 25.4.1.5 NewPromiseCapability(C)\nvar aFunction = __webpack_require__(\"d8e8\");\n\nfunction PromiseCapability(C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject = aFunction(reject);\n}\n\nmodule.exports.f = function (C) {\n  return new PromiseCapability(C);\n};\n\n\n/***/ }),\n\n/***/ \"aa77\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $export = __webpack_require__(\"5ca1\");\nvar defined = __webpack_require__(\"be13\");\nvar fails = __webpack_require__(\"79e5\");\nvar spaces = __webpack_require__(\"fdef\");\nvar space = '[' + spaces + ']';\nvar non = '\\u200b\\u0085';\nvar ltrim = RegExp('^' + space + space + '*');\nvar rtrim = RegExp(space + space + '*$');\n\nvar exporter = function (KEY, exec, ALIAS) {\n  var exp = {};\n  var FORCE = fails(function () {\n    return !!spaces[KEY]() || non[KEY]() != non;\n  });\n  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];\n  if (ALIAS) exp[ALIAS] = fn;\n  $export($export.P + $export.F * FORCE, 'String', exp);\n};\n\n// 1 -> String#trimLeft\n// 2 -> String#trimRight\n// 3 -> String#trim\nvar trim = exporter.trim = function (string, TYPE) {\n  string = String(defined(string));\n  if (TYPE & 1) string = string.replace(ltrim, '');\n  if (TYPE & 2) string = string.replace(rtrim, '');\n  return string;\n};\n\nmodule.exports = exporter;\n\n\n/***/ }),\n\n/***/ \"aae3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.2.8 IsRegExp(argument)\nvar isObject = __webpack_require__(\"d3f4\");\nvar cof = __webpack_require__(\"2d95\");\nvar MATCH = __webpack_require__(\"2b4c\")('match');\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\n};\n\n\n/***/ }),\n\n/***/ \"ab57\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"2350\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \".aplayer{background:#fff;font-family:Arial,Helvetica,sans-serif;margin:5px;-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,.07),0 1px 5px 0 rgba(0,0,0,.1);box-shadow:0 2px 2px 0 rgba(0,0,0,.07),0 1px 5px 0 rgba(0,0,0,.1);border-radius:2px;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;line-height:normal;position:relative}.aplayer *{-webkit-box-sizing:content-box;box-sizing:content-box}.aplayer svg{width:100%;height:100%}.aplayer svg circle,.aplayer svg path{fill:#fff}.aplayer.aplayer-withlist .aplayer-info{border-bottom:1px solid #e9e9e9}.aplayer.aplayer-withlist .aplayer-list{display:block;width:100%}.aplayer.aplayer-withlist .aplayer-icon-order,.aplayer.aplayer-withlist .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu{display:inline}.aplayer.aplayer-withlrc .aplayer-pic{height:90px;width:90px}.aplayer.aplayer-withlrc .aplayer-info{margin-left:90px;height:90px;padding:10px 7px 0 7px}.aplayer.aplayer-withlrc .aplayer-lrc{display:block}.aplayer.aplayer-narrow{width:66px}.aplayer.aplayer-narrow .aplayer-info,.aplayer.aplayer-narrow .aplayer-list{display:none}.aplayer.aplayer-narrow .aplayer-body,.aplayer.aplayer-narrow .aplayer-pic{height:66px;width:66px}.aplayer.aplayer-fixed{position:fixed;bottom:0;left:0;right:0;margin:0;z-index:99;overflow:visible;max-width:400px;-webkit-box-shadow:none;box-shadow:none}.aplayer.aplayer-fixed .aplayer-list{margin-bottom:65px;border:1px solid #eee;border-bottom:none;-webkit-box-sizing:border-box;box-sizing:border-box}.aplayer.aplayer-fixed .aplayer-body{position:fixed;bottom:0;left:0;right:0;margin:0;z-index:99;background:#fff;padding-right:18px;-webkit-transition:width .3s ease;transition:width .3s ease;max-width:400px;width:calc(100% - 18px)}.aplayer.aplayer-fixed .aplayer-lrc{display:block;position:fixed;bottom:10px;left:0;right:0;margin:0;z-index:98;pointer-events:none;text-shadow:-1px -1px 0 #fff}.aplayer.aplayer-fixed .aplayer-lrc:after,.aplayer.aplayer-fixed .aplayer-lrc:before{display:none}.aplayer.aplayer-fixed .aplayer-info{-webkit-transform:scaleX(1);transform:scaleX(1);-webkit-transform-origin:0 0;transform-origin:0 0;-webkit-transition:all .3s ease;transition:all .3s ease;border-bottom:none;border-top:1px solid #e9e9e9}.aplayer.aplayer-fixed .aplayer-info .aplayer-music{width:calc(100% - 105px)}.aplayer.aplayer-fixed .aplayer-miniswitcher{display:block}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-info{display:block;-webkit-transform:scaleX(0);transform:scaleX(0)}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{width:66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-miniswitcher .aplayer-icon{-webkit-transform:rotateY(0);transform:rotateY(0)}.aplayer.aplayer-fixed .aplayer-icon-back,.aplayer.aplayer-fixed .aplayer-icon-forward,.aplayer.aplayer-fixed .aplayer-icon-lrc,.aplayer.aplayer-fixed .aplayer-icon-play{display:inline-block}.aplayer.aplayer-fixed .aplayer-icon-back,.aplayer.aplayer-fixed .aplayer-icon-forward,.aplayer.aplayer-fixed .aplayer-icon-menu,.aplayer.aplayer-fixed .aplayer-icon-play{position:absolute;bottom:27px;width:20px;height:20px}.aplayer.aplayer-fixed .aplayer-icon-back{right:75px}.aplayer.aplayer-fixed .aplayer-icon-play{right:50px}.aplayer.aplayer-fixed .aplayer-icon-forward{right:25px}.aplayer.aplayer-fixed .aplayer-icon-menu{right:0}.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order,.aplayer.aplayer-mobile .aplayer-icon-volume-down,.aplayer.aplayer-mobile .aplayer-icon-volume-up{display:none}.aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-loading-icon{display:block}.aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb{-webkit-transform:scale(1);transform:scale(1)}.aplayer .aplayer-body{position:relative}.aplayer .aplayer-icon{width:15px;height:15px;border:none;background-color:transparent;outline:none;cursor:pointer;opacity:.8;vertical-align:middle;padding:0;font-size:12px;margin:0;display:inline-block}.aplayer .aplayer-icon path{-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.aplayer .aplayer-icon-back,.aplayer .aplayer-icon-forward,.aplayer .aplayer-icon-lrc,.aplayer .aplayer-icon-order,.aplayer .aplayer-icon-play{display:none}.aplayer .aplayer-icon-lrc-inactivity svg{opacity:.4}.aplayer .aplayer-icon-forward{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.aplayer .aplayer-lrc-content{display:none}.aplayer .aplayer-pic{position:relative;float:left;height:66px;width:66px;background-size:cover;background-position:50%;-webkit-transition:all .3s ease;transition:all .3s ease;cursor:pointer}.aplayer .aplayer-pic:hover .aplayer-button{opacity:1}.aplayer .aplayer-pic .aplayer-button{position:absolute;border-radius:50%;opacity:.8;text-shadow:0 1px 1px rgba(0,0,0,.2);-webkit-box-shadow:0 1px 1px rgba(0,0,0,.2);box-shadow:0 1px 1px rgba(0,0,0,.2);background:rgba(0,0,0,.2);-webkit-transition:all .1s ease;transition:all .1s ease}.aplayer .aplayer-pic .aplayer-button path{fill:#fff}.aplayer .aplayer-pic .aplayer-hide{display:none}.aplayer .aplayer-pic .aplayer-play{width:26px;height:26px;border:2px solid #fff;bottom:50%;right:50%;margin:0 -15px -15px 0}.aplayer .aplayer-pic .aplayer-play svg{position:absolute;top:3px;left:4px;height:20px;width:20px}.aplayer .aplayer-pic .aplayer-pause{width:16px;height:16px;border:2px solid #fff;bottom:4px;right:4px}.aplayer .aplayer-pic .aplayer-pause svg{position:absolute;top:2px;left:2px;height:12px;width:12px}.aplayer .aplayer-info{margin-left:66px;padding:14px 7px 0 10px;height:66px;-webkit-box-sizing:border-box;box-sizing:border-box}.aplayer .aplayer-info .aplayer-music{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0 0 13px 5px;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;cursor:default;padding-bottom:2px;height:20px}.aplayer .aplayer-info .aplayer-music .aplayer-title{font-size:14px}.aplayer .aplayer-info .aplayer-music .aplayer-author{font-size:12px;color:#666}.aplayer .aplayer-info .aplayer-controller{position:relative;display:-webkit-box;display:-ms-flexbox;display:flex}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap{margin:0 0 0 5px;padding:4px 0;cursor:pointer!important;-webkit-box-flex:1;-ms-flex:1;flex:1}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap:hover .aplayer-bar .aplayer-played .aplayer-thumb{-webkit-transform:scale(1);transform:scale(1)}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar{position:relative;height:2px;width:100%;background:#cdcdcd}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-loaded{position:absolute;left:0;top:0;bottom:0;background:#aaa;height:2px;-webkit-transition:all .5s ease;transition:all .5s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played{position:absolute;left:0;top:0;bottom:0;height:2px;-webkit-transition:background-color .3s ease;transition:background-color .3s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb{position:absolute;top:0;right:5px;margin-top:-4px;margin-right:-10px;height:10px;width:10px;border-radius:50%;cursor:pointer;-webkit-transition:all .3s ease-in-out;transition:all .3s ease-in-out;-webkit-transform:scale(0);transform:scale(0)}.aplayer .aplayer-info .aplayer-controller .aplayer-time{position:relative;right:0;bottom:4px;height:17px;color:#999;font-size:11px;padding-left:7px}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-time-inner{vertical-align:middle}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon{cursor:pointer;-webkit-transition:all .2s ease;transition:all .2s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#666}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-loop{margin-right:2px}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon:hover path{fill:#000}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu,.aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-menu,.aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-mode{display:none}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap{position:relative;display:inline-block;margin-left:3px;cursor:pointer!important}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap:hover .aplayer-volume-bar-wrap{height:40px}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap{position:absolute;bottom:15px;right:-3px;width:25px;height:0;z-index:99;overflow:hidden;-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap.aplayer-volume-bar-wrap-active{height:40px}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar{position:absolute;bottom:0;right:10px;width:5px;height:35px;background:#aaa;border-radius:2.5px;overflow:hidden}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar .aplayer-volume{position:absolute;bottom:0;right:0;width:5px;-webkit-transition:all .1s ease;transition:all .1s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon{display:none}.aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon svg{position:absolute;-webkit-animation:rotate 1s linear infinite;animation:rotate 1s linear infinite}.aplayer .aplayer-lrc{display:none;position:relative;height:30px;text-align:center;overflow:hidden;margin:-10px 0 7px}.aplayer .aplayer-lrc:before{top:0;height:10%;background:-webkit-gradient(linear,left top,left bottom,from(#fff),to(hsla(0,0%,100%,0)));background:linear-gradient(180deg,#fff 0,hsla(0,0%,100%,0));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\\"#ffffff\\\",endColorstr=\\\"#00ffffff\\\",GradientType=0)}.aplayer .aplayer-lrc:after,.aplayer .aplayer-lrc:before{position:absolute;z-index:1;display:block;overflow:hidden;width:100%;content:\\\" \\\"}.aplayer .aplayer-lrc:after{bottom:0;height:33%;background:-webkit-gradient(linear,left top,left bottom,from(hsla(0,0%,100%,0)),to(hsla(0,0%,100%,.8)));background:linear-gradient(180deg,hsla(0,0%,100%,0) 0,hsla(0,0%,100%,.8));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\\"#00ffffff\\\",endColorstr=\\\"#ccffffff\\\",GradientType=0)}.aplayer .aplayer-lrc p{font-size:12px;color:#666;line-height:16px!important;height:16px!important;padding:0!important;margin:0!important;-webkit-transition-property:font-size,color,opacity;transition-property:font-size,color,opacity;-webkit-transition-timing-function:ease-out;transition-timing-function:ease-out;-webkit-transition-duration:.5s;transition-duration:.5s;opacity:.4;overflow:hidden}.aplayer .aplayer-lrc p.aplayer-lrc-current{opacity:1;overflow:visible;height:auto!important;min-height:16px}.aplayer .aplayer-lrc.aplayer-lrc-hide{display:none}.aplayer .aplayer-lrc .aplayer-lrc-contents{width:100%;-webkit-transition:all .5s ease-out;transition:all .5s ease-out;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;cursor:default}.aplayer .aplayer-list{overflow:auto;-webkit-transition:all .5s ease;transition:all .5s ease;will-change:height;display:none;overflow:hidden;list-style-type:none;margin:0;padding:0;overflow-y:auto}.aplayer .aplayer-list::-webkit-scrollbar{width:5px}.aplayer .aplayer-list::-webkit-scrollbar-thumb{border-radius:3px;background-color:#eee}.aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#ccc}.aplayer .aplayer-list li{position:relative;height:32px;line-height:32px;padding:0 15px;font-size:12px;border-top:1px solid #e9e9e9;cursor:pointer;-webkit-transition:all .2s ease;transition:all .2s ease;overflow:hidden;margin:0}.aplayer .aplayer-list li:first-child{border-top:none}.aplayer .aplayer-list li:hover{background:#efefef}.aplayer .aplayer-list li.aplayer-list-light{background:#e9e9e9}.aplayer .aplayer-list li.aplayer-list-light .aplayer-list-cur{display:inline-block}.aplayer .aplayer-list li .aplayer-list-cur{display:none;width:3px;height:22px;position:absolute;left:0;top:5px;-webkit-transition:background-color .3s ease;transition:background-color .3s ease;cursor:pointer}.aplayer .aplayer-list li .aplayer-list-index{color:#666;margin-right:12px;cursor:pointer}.aplayer .aplayer-list li .aplayer-list-author{color:#666;float:right;cursor:pointer}.aplayer .aplayer-notice{opacity:0;position:absolute;z-index:1;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);font-size:12px;border-radius:4px;padding:5px 10px;-webkit-transition:all .3s ease-in-out;transition:all .3s ease-in-out;overflow:hidden;color:#fff;pointer-events:none;background-color:#f4f4f5;color:#909399}.aplayer .aplayer-miniswitcher{display:none;position:absolute;top:0;right:0;bottom:0;height:100%;background:#e6e6e6;width:18px;border-radius:0 2px 2px 0}.aplayer .aplayer-miniswitcher .aplayer-icon{height:100%;width:100%;-webkit-transform:rotateY(180deg);transform:rotateY(180deg);-webkit-transition:all .3s ease;transition:all .3s ease}.aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#666}.aplayer .aplayer-miniswitcher .aplayer-icon:hover path{fill:#000}@-webkit-keyframes aplayer-roll{0%{left:0}to{left:-100%}}@keyframes aplayer-roll{0%{left:0}to{left:-100%}}@-webkit-keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}\", \"\"]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"ac6a\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $iterators = __webpack_require__(\"cadf\");\nvar getKeys = __webpack_require__(\"0d58\");\nvar redefine = __webpack_require__(\"2aba\");\nvar global = __webpack_require__(\"7726\");\nvar hide = __webpack_require__(\"32e9\");\nvar Iterators = __webpack_require__(\"84f2\");\nvar wks = __webpack_require__(\"2b4c\");\nvar ITERATOR = wks('iterator');\nvar TO_STRING_TAG = wks('toStringTag');\nvar ArrayValues = Iterators.Array;\n\nvar DOMIterables = {\n  CSSRuleList: true, // TODO: Not spec compliant, should be false.\n  CSSStyleDeclaration: false,\n  CSSValueList: false,\n  ClientRectList: false,\n  DOMRectList: false,\n  DOMStringList: false,\n  DOMTokenList: true,\n  DataTransferItemList: false,\n  FileList: false,\n  HTMLAllCollection: false,\n  HTMLCollection: false,\n  HTMLFormElement: false,\n  HTMLSelectElement: false,\n  MediaList: true, // TODO: Not spec compliant, should be false.\n  MimeTypeArray: false,\n  NamedNodeMap: false,\n  NodeList: true,\n  PaintRequestList: false,\n  Plugin: false,\n  PluginArray: false,\n  SVGLengthList: false,\n  SVGNumberList: false,\n  SVGPathSegList: false,\n  SVGPointList: false,\n  SVGStringList: false,\n  SVGTransformList: false,\n  SourceBufferList: false,\n  StyleSheetList: true, // TODO: Not spec compliant, should be false.\n  TextTrackCueList: false,\n  TextTrackList: false,\n  TouchList: false\n};\n\nfor (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {\n  var NAME = collections[i];\n  var explicit = DOMIterables[NAME];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  var key;\n  if (proto) {\n    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\n    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = ArrayValues;\n    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);\n  }\n}\n\n\n/***/ }),\n\n/***/ \"adec\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n      /* harmony default export */ __webpack_exports__[\"default\"] = ({\n        functional: true,\n        render: \n      function render(_h, _vm) {\n        var _c=_vm._c;return _c('svg',{class:[_vm.data.class, _vm.data.staticClass],style:([_vm.data.style, _vm.data.staticStyle]),attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 28 32\"}},[_c('path',{attrs:{\"d\":\"M13.728 6.272v19.456q0 .448-.352.8t-.8.32-.8-.32l-5.952-5.952H1.152q-.48 0-.8-.352t-.352-.8v-6.848q0-.48.352-.8t.8-.352h4.672l5.952-5.952q.32-.32.8-.32t.8.32.352.8z\"}})])\n      }\n    \n      });\n    \n\n/***/ }),\n\n/***/ \"b349\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar vue_1 = __importDefault(__webpack_require__(\"8bbf\"));\nvar Component = /** @class */ (function (_super) {\n    __extends(Component, _super);\n    function Component() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._tsxattrs = undefined;\n        _this.$scopedSlots = undefined;\n        return _this;\n    }\n    return Component;\n}(vue_1.default));\nexports.Component = Component;\n/**\n * Create component from component options (Compatible with Vue.extend)\n */\nfunction createComponent(opts) {\n    return vue_1.default.extend(opts);\n}\nexports.createComponent = createComponent;\nvar factoryImpl = {\n    convert: function (c) { return c; },\n    extendFrom: function (c) { return c; }\n};\n/**\n * Specify Props and Event types of component\n *\n * Usage:\n *  // Get TSX-supported component with props(`name`, `value`) and event(`onInput`)\n *  const NewComponent = tsx.ofType<{ name: string, value: string }, { onInput: string }>.convert(Component);\n */\nfunction ofType() {\n    return factoryImpl;\n}\nexports.ofType = ofType;\nfunction withNativeOn(componentType) {\n    return componentType;\n}\nexports.withNativeOn = withNativeOn;\nfunction withHtmlAttrs(componentType) {\n    return componentType;\n}\nexports.withHtmlAttrs = withHtmlAttrs;\nfunction withUnknownProps(componentType) {\n    return componentType;\n}\nexports.withUnknownProps = withUnknownProps;\nfunction createComponentFactory(base, mixins) {\n    return {\n        create: function (options) {\n            var mergedMixins = options.mixins\n                ? options.mixins.concat(mixins) : mixins;\n            return base.extend(__assign({}, options, { mixins: mergedMixins }));\n        },\n        mixin: function (mixinObject) {\n            return createComponentFactory(base, mixins.concat([mixinObject]));\n        }\n    };\n}\nfunction createExtendableComponentFactory() {\n    return {\n        create: function (options) {\n            return vue_1.default.extend(options);\n        },\n        extendFrom: function (base) {\n            return createComponentFactory(base, []);\n        },\n        mixin: function (mixinObject) {\n            return createComponentFactory(vue_1.default, [mixinObject]);\n        }\n    };\n}\nexports.componentFactory = createExtendableComponentFactory();\nfunction componentFactoryOf() {\n    return exports.componentFactory;\n}\nexports.componentFactoryOf = componentFactoryOf;\n/**\n * Shorthand of `componentFactory.create`\n */\nexports.component = exports.componentFactory.create;\nexports.extendFrom = exports.componentFactory.extendFrom;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2FwaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDRDQUlhO0FBK0JiO0lBSVUsNkJBQUc7SUFKYjtRQUFBLHFFQVdDO1FBTkMsZUFBUyxHQUlMLFNBQWdCLENBQUM7UUFDckIsa0JBQVksR0FBZ0MsU0FBZ0IsQ0FBQzs7SUFDL0QsQ0FBQztJQUFELGdCQUFDO0FBQUQsQ0FBQyxBQVhELENBSVUsYUFBRyxHQU9aO0FBWFksOEJBQVM7QUFhdEI7O0dBRUc7QUFDSCx5QkFDRSxJQUF3RDtJQUV4RCxPQUFPLGFBQUcsQ0FBQyxNQUFNLENBQUMsSUFBVyxDQUFRLENBQUM7QUFDeEMsQ0FBQztBQUpELDBDQUlDO0FBV0QsSUFBTSxXQUFXLEdBQUc7SUFDbEIsT0FBTyxFQUFFLFVBQUMsQ0FBTSxJQUFLLE9BQUEsQ0FBQyxFQUFELENBQUM7SUFDdEIsVUFBVSxFQUFFLFVBQUMsQ0FBTSxJQUFLLE9BQUEsQ0FBQyxFQUFELENBQUM7Q0FDMUIsQ0FBQztBQUVGOzs7Ozs7R0FNRztBQUNIO0lBS0UsT0FBTyxXQUFXLENBQUM7QUFDckIsQ0FBQztBQU5ELHdCQU1DO0FBRUQsc0JBQ0UsYUFBaUI7SUFFakIsT0FBTyxhQUFvQixDQUFDO0FBQzlCLENBQUM7QUFKRCxvQ0FJQztBQUVELHVCQUNFLGFBQWlCO0lBRWpCLE9BQU8sYUFBb0IsQ0FBQztBQUM5QixDQUFDO0FBSkQsc0NBSUM7QUFFRCwwQkFDRSxhQUFpQjtJQUVqQixPQUFPLGFBQW9CLENBQUM7QUFDOUIsQ0FBQztBQUpELDRDQUlDO0FBeUhELGdDQUNFLElBQWdCLEVBQ2hCLE1BQWE7SUFFYixPQUFPO1FBQ0wsTUFBTSxFQUFOLFVBQU8sT0FBWTtZQUNqQixJQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsTUFBTTtnQkFDakMsQ0FBQyxDQUFLLE9BQU8sQ0FBQyxNQUFNLFFBQUssTUFBTSxFQUMvQixDQUFDLENBQUMsTUFBTSxDQUFDO1lBQ1gsT0FBTyxJQUFJLENBQUMsTUFBTSxjQUFNLE9BQU8sSUFBRSxNQUFNLEVBQUUsWUFBWSxJQUFHLENBQUM7UUFDM0QsQ0FBQztRQUNELEtBQUssRUFBTCxVQUFNLFdBQWdCO1lBQ3BCLE9BQU8sc0JBQXNCLENBQUMsSUFBSSxFQUFNLE1BQU0sU0FBRSxXQUFXLEdBQUUsQ0FBQztRQUNoRSxDQUFDO0tBQ0YsQ0FBQztBQUNKLENBQUM7QUFFRDtJQU9FLE9BQU87UUFDTCxNQUFNLEVBQU4sVUFBTyxPQUFZO1lBQ2pCLE9BQU8sYUFBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM3QixDQUFDO1FBQ0QsVUFBVSxFQUFWLFVBQVcsSUFBZ0I7WUFDekIsT0FBTyxzQkFBc0IsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDMUMsQ0FBQztRQUNELEtBQUssRUFBTCxVQUFNLFdBQWdCO1lBQ3BCLE9BQU8sc0JBQXNCLENBQUMsYUFBRyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztRQUNwRCxDQUFDO0tBQ0YsQ0FBQztBQUNKLENBQUM7QUFFWSxRQUFBLGdCQUFnQixHQU16QixnQ0FBZ0MsRUFBRSxDQUFDO0FBRXZDO0lBVUUsT0FBTyx3QkFBdUIsQ0FBQztBQUNqQyxDQUFDO0FBWEQsZ0RBV0M7QUFFRDs7R0FFRztBQUNVLFFBQUEsU0FBUyxHQUFHLHdCQUFnQixDQUFDLE1BQU0sQ0FBQztBQUNwQyxRQUFBLFVBQVUsR0FBRyx3QkFBZ0IsQ0FBQyxVQUFVLENBQUMifQ==\n\n/***/ }),\n\n/***/ \"bcaa\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(\"cb7c\");\nvar isObject = __webpack_require__(\"d3f4\");\nvar newPromiseCapability = __webpack_require__(\"a5b8\");\n\nmodule.exports = function (C, x) {\n  anObject(C);\n  if (isObject(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\n\n/***/ }),\n\n/***/ \"bdba\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n      /* harmony default export */ __webpack_exports__[\"default\"] = ({\n        functional: true,\n        render: \n      function render(_h, _vm) {\n        var _c=_vm._c;return _c('svg',{class:[_vm.data.class, _vm.data.staticClass],style:([_vm.data.style, _vm.data.staticStyle]),attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 28 32\"}},[_c('path',{attrs:{\"d\":\"M13.728 6.272v19.456q0 .448-.352.8t-.8.32-.8-.32l-5.952-5.952H1.152q-.48 0-.8-.352t-.352-.8v-6.848q0-.48.352-.8t.8-.352h4.672l5.952-5.952q.32-.32.8-.32t.8.32.352.8zM20.576 16q0 1.344-.768 2.528t-2.016 1.664q-.16.096-.448.096-.448 0-.8-.32t-.32-.832q0-.384.192-.64t.544-.448.608-.384.512-.64.192-1.024-.192-1.024-.512-.64-.608-.384-.544-.448-.192-.64q0-.48.32-.832t.8-.32q.288 0 .448.096 1.248.48 2.016 1.664T20.576 16z\"}})])\n      }\n    \n      });\n    \n\n/***/ }),\n\n/***/ \"be13\":\n/***/ (function(module, exports) {\n\n// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"bf5c\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n      /* harmony default export */ __webpack_exports__[\"default\"] = ({\n        functional: true,\n        render: \n      function render(_h, _vm) {\n        var _c=_vm._c;return _c('svg',{class:[_vm.data.class, _vm.data.staticClass],style:([_vm.data.style, _vm.data.staticStyle]),attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 32 32\"}},[_c('path',{attrs:{\"d\":\"M22 16L11.895 5.4 10 7.387 18.211 16 10 24.612l1.895 1.988 8.211-8.613z\"}})])\n      }\n    \n      });\n    \n\n/***/ }),\n\n/***/ \"c366\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(\"6821\");\nvar toLength = __webpack_require__(\"9def\");\nvar toAbsoluteIndex = __webpack_require__(\"77f1\");\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n/***/ }),\n\n/***/ \"c3ab\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n      /* harmony default export */ __webpack_exports__[\"default\"] = ({\n        functional: true,\n        render: \n      function render(_h, _vm) {\n        var _c=_vm._c;return _c('svg',{class:[_vm.data.class, _vm.data.staticClass],style:([_vm.data.style, _vm.data.staticStyle]),attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 29 32\"}},[_c('path',{attrs:{\"d\":\"M2.667 7.027l1.707-1.693 22.293 22.293-1.693 1.707-4-4H9.334v4l-5.333-5.333 5.333-5.333v4h8.973l-8.973-8.973v.973H6.667v-3.64l-4-4zm20 10.306h2.667v5.573l-2.667-2.667v-2.907zm0-10.666v-4L28 8l-5.333 5.333v-4H11.76L9.093 6.666h13.573z\"}})])\n      }\n    \n      });\n    \n\n/***/ }),\n\n/***/ \"c5f6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar global = __webpack_require__(\"7726\");\nvar has = __webpack_require__(\"69a8\");\nvar cof = __webpack_require__(\"2d95\");\nvar inheritIfRequired = __webpack_require__(\"5dbc\");\nvar toPrimitive = __webpack_require__(\"6a99\");\nvar fails = __webpack_require__(\"79e5\");\nvar gOPN = __webpack_require__(\"9093\").f;\nvar gOPD = __webpack_require__(\"11e9\").f;\nvar dP = __webpack_require__(\"86cc\").f;\nvar $trim = __webpack_require__(\"aa77\").trim;\nvar NUMBER = 'Number';\nvar $Number = global[NUMBER];\nvar Base = $Number;\nvar proto = $Number.prototype;\n// Opera ~12 has broken Object#toString\nvar BROKEN_COF = cof(__webpack_require__(\"2aeb\")(proto)) == NUMBER;\nvar TRIM = 'trim' in String.prototype;\n\n// 7.1.3 ToNumber(argument)\nvar toNumber = function (argument) {\n  var it = toPrimitive(argument, false);\n  if (typeof it == 'string' && it.length > 2) {\n    it = TRIM ? it.trim() : $trim(it, 3);\n    var first = it.charCodeAt(0);\n    var third, radix, maxCode;\n    if (first === 43 || first === 45) {\n      third = it.charCodeAt(2);\n      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix\n    } else if (first === 48) {\n      switch (it.charCodeAt(1)) {\n        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i\n        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i\n        default: return +it;\n      }\n      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {\n        code = digits.charCodeAt(i);\n        // parseInt parses a string to a first unavailable symbol\n        // but ToNumber should return NaN if a string contains unavailable symbols\n        if (code < 48 || code > maxCode) return NaN;\n      } return parseInt(digits, radix);\n    }\n  } return +it;\n};\n\nif (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {\n  $Number = function Number(value) {\n    var it = arguments.length < 1 ? 0 : value;\n    var that = this;\n    return that instanceof $Number\n      // check on 1..constructor(foo) case\n      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)\n        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);\n  };\n  for (var keys = __webpack_require__(\"9e1e\") ? gOPN(Base) : (\n    // ES3:\n    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +\n    // ES6 (in case, if modules with ES6 Number statics required before):\n    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +\n    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'\n  ).split(','), j = 0, key; keys.length > j; j++) {\n    if (has(Base, key = keys[j]) && !has($Number, key)) {\n      dP($Number, key, gOPD(Base, key));\n    }\n  }\n  $Number.prototype = proto;\n  proto.constructor = $Number;\n  __webpack_require__(\"2aba\")(global, NUMBER, $Number);\n}\n\n\n/***/ }),\n\n/***/ \"c69a\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = !__webpack_require__(\"9e1e\") && !__webpack_require__(\"79e5\")(function () {\n  return Object.defineProperty(__webpack_require__(\"230e\")('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ \"ca5a\":\n/***/ (function(module, exports) {\n\nvar id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n/***/ }),\n\n/***/ \"cadf\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar addToUnscopables = __webpack_require__(\"9c6c\");\nvar step = __webpack_require__(\"d53b\");\nvar Iterators = __webpack_require__(\"84f2\");\nvar toIObject = __webpack_require__(\"6821\");\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(\"01f9\")(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n/***/ }),\n\n/***/ \"cb7c\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"d3f4\");\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"cd1c\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar speciesConstructor = __webpack_require__(\"e853\");\n\nmodule.exports = function (original, length) {\n  return new (speciesConstructor(original))(length);\n};\n\n\n/***/ }),\n\n/***/ \"ce10\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(\"69a8\");\nvar toIObject = __webpack_require__(\"6821\");\nvar arrayIndexOf = __webpack_require__(\"c366\")(false);\nvar IE_PROTO = __webpack_require__(\"613b\")('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n/***/ }),\n\n/***/ \"d263\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// B.2.3.6 String.prototype.fixed()\n__webpack_require__(\"386b\")('fixed', function (createHTML) {\n  return function fixed() {\n    return createHTML(this, 'tt', '', '');\n  };\n});\n\n\n/***/ }),\n\n/***/ \"d2c8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// helper for String#{startsWith, endsWith, includes}\nvar isRegExp = __webpack_require__(\"aae3\");\nvar defined = __webpack_require__(\"be13\");\n\nmodule.exports = function (that, searchString, NAME) {\n  if (isRegExp(searchString)) throw TypeError('String#' + NAME + \" doesn't accept regex!\");\n  return String(defined(that));\n};\n\n\n/***/ }),\n\n/***/ \"d3f4\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/***/ }),\n\n/***/ \"d53b\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n\n\n/***/ }),\n\n/***/ \"d8e8\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"daf8\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n      /* harmony default export */ __webpack_exports__[\"default\"] = ({\n        functional: true,\n        render: \n      function render(_h, _vm) {\n        var _c=_vm._c;return _c('svg',{class:[_vm.data.class, _vm.data.staticClass],style:([_vm.data.style, _vm.data.staticStyle]),attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 17 32\"}},[_c('path',{attrs:{\"d\":\"M14.08 4.8q2.88 0 2.88 2.048v18.24q0 2.112-2.88 2.112t-2.88-2.112V6.848q0-2.048 2.88-2.048zm-11.2 0q2.88 0 2.88 2.048v18.24q0 2.112-2.88 2.112T0 25.088V6.848Q0 4.8 2.88 4.8z\"}})])\n      }\n    \n      });\n    \n\n/***/ }),\n\n/***/ \"dcbc\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar redefine = __webpack_require__(\"2aba\");\nmodule.exports = function (target, src, safe) {\n  for (var key in src) redefine(target, key, src[key], safe);\n  return target;\n};\n\n\n/***/ }),\n\n/***/ \"e11e\":\n/***/ (function(module, exports) {\n\n// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n/***/ }),\n\n/***/ \"e853\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"d3f4\");\nvar isArray = __webpack_require__(\"1169\");\nvar SPECIES = __webpack_require__(\"2b4c\")('species');\n\nmodule.exports = function (original) {\n  var C;\n  if (isArray(original)) {\n    C = original.constructor;\n    // cross-realm fallback\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n    if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n\n\n/***/ }),\n\n/***/ \"ebd6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject = __webpack_require__(\"cb7c\");\nvar aFunction = __webpack_require__(\"d8e8\");\nvar SPECIES = __webpack_require__(\"2b4c\")('species');\nmodule.exports = function (O, D) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n\n\n/***/ }),\n\n/***/ \"f559\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// 21.1.3.18 String.prototype.startsWith(searchString [, position ])\n\nvar $export = __webpack_require__(\"5ca1\");\nvar toLength = __webpack_require__(\"9def\");\nvar context = __webpack_require__(\"d2c8\");\nvar STARTS_WITH = 'startsWith';\nvar $startsWith = ''[STARTS_WITH];\n\n$export($export.P + $export.F * __webpack_require__(\"5147\")(STARTS_WITH), 'String', {\n  startsWith: function startsWith(searchString /* , position = 0 */) {\n    var that = context(this, searchString, STARTS_WITH);\n    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));\n    var search = String(searchString);\n    return $startsWith\n      ? $startsWith.call(that, search, index)\n      : that.slice(index, index + search.length) === search;\n  }\n});\n\n\n/***/ }),\n\n/***/ \"f576\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = __webpack_require__(\"5ca1\");\nvar $pad = __webpack_require__(\"2e08\");\nvar userAgent = __webpack_require__(\"a25f\");\n\n// https://github.com/zloirock/core-js/issues/280\n$export($export.P + $export.F * /Version\\/10\\.\\d+(\\.\\d+)? Safari\\//.test(userAgent), 'String', {\n  padStart: function padStart(maxLength /* , fillString = ' ' */) {\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);\n  }\n});\n\n\n/***/ }),\n\n/***/ \"f605\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ \"f751\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.3.1 Object.assign(target, source)\nvar $export = __webpack_require__(\"5ca1\");\n\n$export($export.S + $export.F, 'Object', { assign: __webpack_require__(\"7333\") });\n\n\n/***/ }),\n\n/***/ \"f866\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n      /* harmony default export */ __webpack_exports__[\"default\"] = ({\n        functional: true,\n        render: \n      function render(_h, _vm) {\n        var _c=_vm._c;return _c('svg',{class:[_vm.data.class, _vm.data.staticClass],style:([_vm.data.style, _vm.data.staticStyle]),attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 29 32\"}},[_c('path',{attrs:{\"d\":\"M9.333 9.333h13.333v4L27.999 8l-5.333-5.333v4h-16v8h2.667V9.334zm13.334 13.334H9.334v-4L4.001 24l5.333 5.333v-4h16v-8h-2.667v5.333z\"}})])\n      }\n    \n      });\n    \n\n/***/ }),\n\n/***/ \"fab2\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar document = __webpack_require__(\"7726\").document;\nmodule.exports = document && document.documentElement;\n\n\n/***/ }),\n\n/***/ \"fb15\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js\n// This file is imported into lib/wc client bundles.\n\nif (typeof window !== 'undefined') {\n  var setPublicPath_i\n  if ((setPublicPath_i = window.document.currentScript) && (setPublicPath_i = setPublicPath_i.src.match(/(.+\\/)[^/]+\\.js(\\?.*)?$/))) {\n    __webpack_require__.p = setPublicPath_i[1] // eslint-disable-line\n  }\n}\n\n// Indicate to webpack that this file can be concatenated\n/* harmony default export */ var setPublicPath = (null);\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.assign.js\nvar es6_object_assign = __webpack_require__(\"f751\");\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread.js\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.number.constructor.js\nvar es6_number_constructor = __webpack_require__(\"c5f6\");\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\n\n\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js\nvar web_dom_iterable = __webpack_require__(\"ac6a\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.promise.js\nvar es6_promise = __webpack_require__(\"551c\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.array.includes.js\nvar es7_array_includes = __webpack_require__(\"6762\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.includes.js\nvar es6_string_includes = __webpack_require__(\"2fdb\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.function.name.js\nvar es6_function_name = __webpack_require__(\"7f7f\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.find.js\nvar es6_array_find = __webpack_require__(\"7514\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.to-string.js\nvar es6_regexp_to_string = __webpack_require__(\"6b54\");\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\n\n\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.find-index.js\nvar es6_array_find_index = __webpack_require__(\"20d6\");\n\n// EXTERNAL MODULE: ./node_modules/regenerator-runtime/runtime.js\nvar runtime = __webpack_require__(\"96cf\");\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.fixed.js\nvar es6_string_fixed = __webpack_require__(\"d263\");\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js\nfunction _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\n\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n// EXTERNAL MODULE: ./node_modules/vue-tsx-support/lib/index.js\nvar lib = __webpack_require__(\"48d3\");\n\n// EXTERNAL MODULE: ./node_modules/vue-class-component/dist/vue-class-component.common.js\nvar vue_class_component_common = __webpack_require__(\"65d9\");\nvar vue_class_component_common_default = /*#__PURE__*/__webpack_require__.n(vue_class_component_common);\n\n// EXTERNAL MODULE: external {\"commonjs\":\"vue\",\"commonjs2\":\"vue\",\"root\":\"Vue\"}\nvar external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__(\"8bbf\");\nvar external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);\n\n// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/vue-property-decorator.js\n/** vue-property-decorator verson 7.2.0 MIT LICENSE copyright 2018 kaorun343 */\n\n\n\n\n/**\n * decorator of an inject\n * @param from key\n * @return PropertyDecorator\n */\nfunction Inject(options) {\n    return Object(vue_class_component_common[\"createDecorator\"])(function (componentOptions, key) {\n        if (typeof componentOptions.inject === 'undefined') {\n            componentOptions.inject = {};\n        }\n        if (!Array.isArray(componentOptions.inject)) {\n            componentOptions.inject[key] = options || key;\n        }\n    });\n}\n/**\n * decorator of a provide\n * @param key key\n * @return PropertyDecorator | void\n */\nfunction Provide(key) {\n    return Object(vue_class_component_common[\"createDecorator\"])(function (componentOptions, k) {\n        var provide = componentOptions.provide;\n        if (typeof provide !== 'function' || !provide.managed) {\n            var original_1 = componentOptions.provide;\n            provide = componentOptions.provide = function () {\n                var rv = Object.create((typeof original_1 === 'function' ? original_1.call(this) : original_1) || null);\n                for (var i in provide.managed)\n                    rv[provide.managed[i]] = this[i];\n                return rv;\n            };\n            provide.managed = {};\n        }\n        provide.managed[k] = key || k;\n    });\n}\n/**\n * decorator of model\n * @param  event event name\n * @param options options\n * @return PropertyDecorator\n */\nfunction Model(event, options) {\n    if (options === void 0) { options = {}; }\n    return Object(vue_class_component_common[\"createDecorator\"])(function (componentOptions, k) {\n        (componentOptions.props || (componentOptions.props = {}))[k] = options;\n        componentOptions.model = { prop: k, event: event || k };\n    });\n}\n/**\n * decorator of a prop\n * @param  options the options for the prop\n * @return PropertyDecorator | void\n */\nfunction Prop(options) {\n    if (options === void 0) { options = {}; }\n    return Object(vue_class_component_common[\"createDecorator\"])(function (componentOptions, k) {\n        (componentOptions.props || (componentOptions.props = {}))[k] = options;\n    });\n}\n/**\n * decorator of a watch function\n * @param  path the path or the expression to observe\n * @param  WatchOption\n * @return MethodDecorator\n */\nfunction Watch(path, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.deep, deep = _a === void 0 ? false : _a, _b = options.immediate, immediate = _b === void 0 ? false : _b;\n    return Object(vue_class_component_common[\"createDecorator\"])(function (componentOptions, handler) {\n        if (typeof componentOptions.watch !== 'object') {\n            componentOptions.watch = Object.create(null);\n        }\n        componentOptions.watch[path] = { handler: handler, deep: deep, immediate: immediate };\n    });\n}\n// Code copied from Vue/src/shared/util.js\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = function (str) { return str.replace(hyphenateRE, '-$1').toLowerCase(); };\n/**\n * decorator of an event-emitter function\n * @param  event The name of the event\n * @return MethodDecorator\n */\nfunction Emit(event) {\n    return function (_target, key, descriptor) {\n        key = hyphenate(key);\n        var original = descriptor.value;\n        descriptor.value = function emitter() {\n            var _this = this;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var emit = function (returnValue) {\n                if (returnValue !== undefined)\n                    args.unshift(returnValue);\n                _this.$emit.apply(_this, [event || key].concat(args));\n            };\n            var returnValue = original.apply(this, args);\n            if (isPromise(returnValue)) {\n                returnValue.then(function (returnValue) {\n                    emit(returnValue);\n                });\n            }\n            else {\n                emit(returnValue);\n            }\n        };\n    };\n}\nfunction isPromise(obj) {\n    return obj instanceof Promise || (obj && typeof obj.then === 'function');\n}\n\n// EXTERNAL MODULE: ./node_modules/classnames/index.js\nvar classnames = __webpack_require__(\"4d26\");\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.iterator.js\nvar es6_array_iterator = __webpack_require__(\"cadf\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.keys.js\nvar es6_object_keys = __webpack_require__(\"456d\");\n\n// CONCATENATED MODULE: ./utils/index.ts\n\nfunction sleep() {\n  var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, delay);\n  });\n}\nfunction eventLoop(target) {\n  var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3000;\n  return new Promise(function (resolve, reject) {\n    var startTime = new Date().getTime();\n    var timerId = setInterval(function () {\n      if (!target()) {\n        if (timeout > 0 && new Date().getTime() - startTime > timeout) {\n          reject();\n          clearInterval(timerId);\n        }\n\n        return;\n      }\n\n      resolve();\n      clearInterval(timerId);\n    }, 100);\n  });\n}\n// CONCATENATED MODULE: ./packages/@moefe/vue-audio/events.ts\n/* harmony default export */ var events = (['abort', 'canplay', 'canplaythrough', 'durationchange', 'emptied', 'ended', 'error', 'loadeddata', 'loadedmetadata', 'loadstart', 'pause', 'play', 'playing', 'progress', 'ratechange', 'readystatechange', 'seeked', 'seeking', 'stalled', 'suspend', 'timeupdate', 'volumechange', 'waiting']);\n// CONCATENATED MODULE: ./packages/@moefe/vue-audio/index.ts\n\n\n\n\n\n\n\n\n\n\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = undefined && undefined.__metadata || function (k, v) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\n\n\n\n\n\nvar ReadyState;\n\n(function (ReadyState) {\n  /** 没有关于音频是否就绪的信息 */\n  ReadyState[ReadyState[\"HAVE_NOTHING\"] = 0] = \"HAVE_NOTHING\";\n  /** 关于音频就绪的元数据 */\n\n  ReadyState[ReadyState[\"HAVE_METADATA\"] = 1] = \"HAVE_METADATA\";\n  /** 关于当前播放位置的数据是可用的，但没有足够的数据来播放下一帧/毫秒 */\n\n  ReadyState[ReadyState[\"HAVE_CURRENT_DATA\"] = 2] = \"HAVE_CURRENT_DATA\";\n  /** 当前及至少下一帧的数据是可用的 */\n\n  ReadyState[ReadyState[\"HAVE_FUTURE_DATA\"] = 3] = \"HAVE_FUTURE_DATA\";\n  /** 可用数据足以开始播放 */\n\n  ReadyState[ReadyState[\"HAVE_ENOUGH_DATA\"] = 4] = \"HAVE_ENOUGH_DATA\";\n})(ReadyState || (ReadyState = {}));\n\nvar vue_audio_VueAudio =\n/*#__PURE__*/\nfunction (_Vue) {\n  _inherits(VueAudio, _Vue);\n\n  function VueAudio() {\n    var _this;\n\n    _classCallCheck(this, VueAudio);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(VueAudio).call(this));\n    _this.audio = new Audio();\n    _this.audioTracks = _this.audio.audioTracks;\n    _this.autoplay = _this.audio.autoplay;\n    _this.buffered = _this.audio.buffered;\n    _this.controls = _this.audio.controls;\n    _this.crossOrigin = _this.audio.crossOrigin;\n    _this.currentSrc = _this.audio.currentSrc;\n    _this.currentTime = _this.audio.currentTime;\n    _this.defaultMuted = _this.audio.defaultMuted;\n    _this.defaultPlaybackRate = _this.audio.defaultPlaybackRate;\n    _this.duration = _this.audio.duration;\n    _this.ended = _this.audio.ended;\n    _this.error = _this.audio.error;\n    _this.loop = _this.audio.loop;\n    _this.mediaKeys = _this.audio.mediaKeys;\n    _this.muted = _this.audio.muted;\n    _this.networkState = _this.audio.networkState;\n    _this.paused = _this.audio.paused;\n    _this.playbackRate = _this.audio.playbackRate;\n    _this.played = _this.audio.played;\n    _this.preload = _this.audio.preload;\n    _this.readyState = _this.audio.readyState;\n    _this.seekable = _this.audio.seekable;\n    _this.seeking = _this.audio.seeking;\n    _this.src = _this.audio.src;\n    _this.textTracks = _this.audio.textTracks;\n    _this.volume = _this.audio.volume;\n    events.forEach(function (event) {\n      _this.audio.addEventListener(event, function (e) {\n        _this.sync();\n      });\n    });\n    return _this;\n  }\n\n  _createClass(VueAudio, [{\n    key: \"sync\",\n    value: function sync() {\n      var _this2 = this;\n\n      Object.keys(this.$data).forEach(function (key) {\n        if (key === 'audio') return;\n        _this2[key] = _this2.audio[key];\n      });\n    }\n  }, {\n    key: \"loaded\",\n    value: function loaded() {\n      var _this3 = this;\n\n      return eventLoop(function () {\n        return _this3.readyState >= ReadyState.HAVE_FUTURE_DATA;\n      }, 0);\n    }\n  }, {\n    key: \"srcLoaded\",\n    value: function srcLoaded() {\n      var _this4 = this;\n\n      return eventLoop(function () {\n        return _this4.src;\n      }, 0);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n\n  return VueAudio;\n}(external_commonjs_vue_commonjs2_vue_root_Vue_default.a);\n\nvue_audio_VueAudio = __decorate([vue_class_component_common_default.a, __metadata(\"design:paramtypes\", [])], vue_audio_VueAudio);\n/* harmony default export */ var vue_audio = (vue_audio_VueAudio);\n// CONCATENATED MODULE: ./packages/@moefe/vue-store/index.ts\n\n\n\n\n\n\n\nvar vue_store_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\nvar vue_store_VueStore =\n/*#__PURE__*/\nfunction (_Vue) {\n  _inherits(VueStore, _Vue);\n\n  function VueStore() {\n    var _this;\n\n    _classCallCheck(this, VueStore);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(VueStore).apply(this, arguments));\n    _this.key = 'aplayer-setting';\n    _this.store = _this.get(_this.key);\n    return _this;\n  } // eslint-disable-next-line class-methods-use-this\n\n\n  _createClass(VueStore, [{\n    key: \"get\",\n    value: function get(key) {\n      return JSON.parse(localStorage.getItem(key) || '[]');\n    }\n  }, {\n    key: \"set\",\n    value: function set(val) {\n      this.store = val;\n      localStorage.setItem(this.key, JSON.stringify(val));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n\n  return VueStore;\n}(external_commonjs_vue_commonjs2_vue_root_Vue_default.a);\n\nvue_store_VueStore = vue_store_decorate([vue_class_component_common_default.a], vue_store_VueStore);\n/* harmony default export */ var vue_store = (vue_store_VueStore);\n// CONCATENATED MODULE: ./utils/mixin.ts\n\n\n\n\n\n\n\nvar mixin_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\nvar mixin_Mixin =\n/*#__PURE__*/\nfunction (_Vue) {\n  _inherits(Mixin, _Vue);\n\n  function Mixin() {\n    _classCallCheck(this, Mixin);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Mixin).apply(this, arguments));\n  }\n\n  _createClass(Mixin, [{\n    key: \"isMobile\",\n    get: function get() {\n      var ua = this.$ssrContext ? this.$ssrContext.userAgent : window.navigator.userAgent;\n      return /mobile/i.test(ua);\n    }\n  }]);\n\n  return Mixin;\n}(external_commonjs_vue_commonjs2_vue_root_Vue_default.a);\n\nmixin_Mixin = mixin_decorate([vue_class_component_common_default.a], mixin_Mixin);\n/* harmony default export */ var mixin = (mixin_Mixin);\n// CONCATENATED MODULE: ./packages/@moefe/vue-aplayer/components/Cover.tsx\n\n\n\n\n\n\n\nvar Cover_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar Cover_metadata = undefined && undefined.__metadata || function (k, v) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar Cover_a;\n\n\n\n\n\nvar Cover_Cover =\n/*#__PURE__*/\nfunction (_Vue$Component) {\n  _inherits(Cover, _Vue$Component);\n\n  function Cover() {\n    _classCallCheck(this, Cover);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Cover).apply(this, arguments));\n  }\n\n  _createClass(Cover, [{\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      this.$emit('click', e);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var h = arguments[0];\n      return h(\"div\", {\n        \"class\": \"aplayer-pic\",\n        style: this.style,\n        on: {\n          \"click\": this.handleClick\n        }\n      }, [this.$slots.default]);\n    }\n  }, {\n    key: \"style\",\n    get: function get() {\n      var _this$aplayer = this.aplayer,\n          options = _this$aplayer.options,\n          currentTheme = _this$aplayer.currentTheme,\n          currentMusic = _this$aplayer.currentMusic;\n      var cover = currentMusic.cover || options.defaultCover;\n      return {\n        backgroundImage: cover && \"url(\\\"\".concat(cover, \"\\\")\"),\n        backgroundColor: currentTheme\n      };\n    }\n  }]);\n\n  return Cover;\n}(lib[\"Component\"]);\n\nCover_decorate([Inject(), Cover_metadata(\"design:type\", Object)], Cover_Cover.prototype, \"aplayer\", void 0);\n\nCover_Cover = Cover_decorate([vue_class_component_common_default.a], Cover_Cover);\n/* harmony default export */ var components_Cover = (Cover_Cover);\n// CONCATENATED MODULE: ./packages/@moefe/vue-aplayer/components/Icon.tsx\n\n\n\n\n\n\n\nvar Icon_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar Icon_metadata = undefined && undefined.__metadata || function (k, v) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\n\n\n\nvar icon = function icon(type) {\n  return __webpack_require__(\"52f0\")(\"./\".concat(type, \".svg\")).default;\n}; // eslint-disable-line\n\nvar Icon_Icon =\n/*#__PURE__*/\nfunction (_Vue$Component) {\n  _inherits(Icon, _Vue$Component);\n\n  function Icon() {\n    _classCallCheck(this, Icon);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Icon).apply(this, arguments));\n  }\n\n  _createClass(Icon, [{\n    key: \"render\",\n    value: function render() {\n      var h = arguments[0];\n      var I = icon(this.type);\n      return h(I);\n    }\n  }]);\n\n  return Icon;\n}(lib[\"Component\"]);\n\nIcon_decorate([Prop({\n  type: String,\n  required: true\n}), Icon_metadata(\"design:type\", String)], Icon_Icon.prototype, \"type\", void 0);\n\nIcon_Icon = Icon_decorate([vue_class_component_common_default.a], Icon_Icon);\n/* harmony default export */ var components_Icon = (Icon_Icon);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.sort.js\nvar es6_array_sort = __webpack_require__(\"55dd\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.split.js\nvar es6_regexp_split = __webpack_require__(\"28a5\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.replace.js\nvar es6_regexp_replace = __webpack_require__(\"a481\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.match.js\nvar es6_regexp_match = __webpack_require__(\"4917\");\n\n// CONCATENATED MODULE: ./packages/@moefe/vue-aplayer/utils/index.ts\n\n\n\n\n/* eslint-disable no-param-reassign */\nfunction shuffle(arr) {\n  for (var i = arr.length - 1; i >= 0; i--) {\n    var randomIndex = Math.floor(Math.random() * (i + 1));\n    var itemAtIndex = arr[randomIndex];\n    arr[randomIndex] = arr[i];\n    arr[i] = itemAtIndex;\n  }\n\n  return arr;\n}\nvar utils_HttpRequest =\n/*#__PURE__*/\nfunction () {\n  function HttpRequest() {\n    _classCallCheck(this, HttpRequest);\n\n    this.xhr = new XMLHttpRequest();\n  }\n\n  _createClass(HttpRequest, [{\n    key: \"download\",\n    value: function download(url) {\n      var _this = this;\n\n      var responseType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      return new Promise(function (resolve, reject) {\n        _this.xhr.open('get', url);\n\n        _this.xhr.responseType = responseType;\n\n        _this.xhr.onload = function () {\n          var status = _this.xhr.status;\n\n          if (status >= 200 && status < 300 || status === 304) {\n            resolve(_this.xhr.response);\n          }\n        };\n\n        _this.xhr.onabort = reject;\n        _this.xhr.onerror = reject;\n        _this.xhr.ontimeout = reject;\n\n        _this.xhr.send();\n      });\n    }\n  }]);\n\n  return HttpRequest;\n}();\n// CONCATENATED MODULE: ./packages/@moefe/vue-aplayer/components/Lyric.tsx\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Lyric_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar Lyric_metadata = undefined && undefined.__metadata || function (k, v) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar Lyric_a;\n\n\n\n\n\n\n\nvar Lyric_Lyric =\n/*#__PURE__*/\nfunction (_Vue$Component) {\n  _inherits(Lyric, _Vue$Component);\n\n  function Lyric() {\n    var _this;\n\n    _classCallCheck(this, Lyric);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Lyric).apply(this, arguments));\n    _this.lrc = '';\n    _this.xhr = new utils_HttpRequest();\n    _this.isLoading = false;\n    return _this;\n  }\n\n  _createClass(Lyric, [{\n    key: \"getLyricFromCurrentMusic\",\n    value: function getLyricFromCurrentMusic() {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        var _this2$aplayer = _this2.aplayer,\n            lrcType = _this2$aplayer.lrcType,\n            currentMusic = _this2$aplayer.currentMusic;\n\n        switch (lrcType) {\n          case 0:\n            resolve('');\n            break;\n\n          case 1:\n            resolve(currentMusic.lrc);\n            break;\n\n          case 3:\n            resolve(currentMusic.lrc ? _this2.xhr.download(currentMusic.lrc) : '');\n            break;\n\n          default:\n            reject(new Error(\"Illegal lrcType: \".concat(lrcType)));\n            break;\n        }\n      });\n    }\n  }, {\n    key: \"parseLRC\",\n    value: function parseLRC(lrc) {\n      var reg = /\\[(\\d+):(\\d+)[.|:](\\d+)\\](.+)/;\n      var regTime = /\\[(\\d+):(\\d+)[.|:](\\d+)\\]/g;\n      var regCompatible = /\\[(\\d+):(\\d+)]()(.+)/;\n      var regTimeCompatible = /\\[(\\d+):(\\d+)]/g;\n      var regOffset = /\\[offset:\\s*(-?\\d+)\\]/;\n      var offsetMatch = this.lrc.match(regOffset);\n      var offset = offsetMatch ? Number(offsetMatch[1]) : 0;\n      var parsed = [];\n\n      var matchAll = function matchAll(line) {\n        var match = line.match(reg) || line.match(regCompatible);\n        if (!match || match.length !== 5) return;\n        var minutes = Number(match[1]) || 0;\n        var seconds = Number(match[2]) || 0;\n        var milliseconds = Number(match[3]) || 0;\n        var time = minutes * 60 * 1000 + seconds * 1000 + milliseconds + offset; // eslint-disable-line no-mixed-operators\n\n        var text = match[4].replace(regTime, '').replace(regTimeCompatible, ''); // 优化：不要显示空行\n\n        if (!text) return;\n        parsed.push({\n          time: time,\n          text: text\n        });\n        matchAll(match[4]); // 递归匹配多个时间标签\n      };\n\n      lrc.replace(/\\\\n/g, '\\n').split('\\n').forEach(function (line) {\n        return matchAll(line);\n      });\n\n      if (parsed.length > 0) {\n        parsed.sort(function (a, b) {\n          return a.time - b.time;\n        });\n      }\n\n      return parsed;\n    }\n  }, {\n    key: \"handleChange\",\n    value: function () {\n      var _handleChange = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                this.isLoading = true;\n                this.lrc = '';\n                _context.next = 5;\n                return this.getLyricFromCurrentMusic();\n\n              case 5:\n                this.lrc = _context.sent;\n\n              case 6:\n                _context.prev = 6;\n                this.isLoading = false;\n                return _context.finish(6);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0,, 6, 9]]);\n      }));\n\n      function handleChange() {\n        return _handleChange.apply(this, arguments);\n      }\n\n      return handleChange;\n    }()\n  }, {\n    key: \"render\",\n    value: function render() {\n      var h = arguments[0];\n      var visible = this.visible,\n          style = this.style,\n          parsed = this.parsed,\n          current = this.current,\n          noLyric = this.noLyric;\n      return h(\"div\", {\n        \"class\": classnames_default()({\n          'aplayer-lrc': true,\n          'aplayer-lrc-hide': !visible\n        })\n      }, [h(\"div\", {\n        \"class\": \"aplayer-lrc-contents\",\n        style: style\n      }, [parsed.length > 0 ? parsed.map(function (item, index) {\n        return h(\"p\", {\n          key: item.time,\n          \"class\": classnames_default()({\n            'aplayer-lrc-current': current.time === item.time\n          })\n        }, [item.text]);\n      }) : h(\"p\", {\n        \"class\": \"aplayer-lrc-current\"\n      }, [noLyric])])]);\n    }\n  }, {\n    key: \"noLyric\",\n    get: function get() {\n      /* eslint-disable no-nested-ternary */\n      var currentMusic = this.aplayer.currentMusic;\n      return !currentMusic.id ? '(ಗ ‸ ಗ ) 未加载音频' : this.isLoading ? '(*ゝω・) 少女祈祷中..' : this.lrc ? '(・∀・*) 抱歉，该歌词格式不支持' : '(,,•́ . •̀,,) 抱歉，当前歌曲暂无歌词';\n      /* eslint-enable no-nested-ternary */\n    }\n  }, {\n    key: \"parsed\",\n    get: function get() {\n      return this.parseLRC(this.lrc);\n    }\n  }, {\n    key: \"current\",\n    get: function get() {\n      var _this$aplayer = this.aplayer,\n          media = _this$aplayer.media,\n          currentPlayed = _this$aplayer.currentPlayed;\n      var match = this.parsed.filter(function (x) {\n        return x.time < currentPlayed * media.duration * 1000;\n      });\n      if (match && match.length > 0) return match[match.length - 1];\n      return this.parsed[0];\n    }\n  }, {\n    key: \"transitionDuration\",\n    get: function get() {\n      return this.parsed.length > 1 ? 500 : 0;\n    }\n  }, {\n    key: \"translateY\",\n    get: function get() {\n      var current = this.current,\n          parsed = this.parsed;\n      if (parsed.length <= 0) return 0;\n      var index = parsed.indexOf(current);\n      var isLast = index === parsed.length - 1;\n      return (isLast ? (index - 1) * 16 : index * 16) * -1;\n    }\n  }, {\n    key: \"style\",\n    get: function get() {\n      return {\n        transitionDuration: \"\".concat(this.transitionDuration, \"ms\"),\n        transform: \"translate3d(0, \".concat(this.translateY, \"px, 0)\")\n      };\n    }\n  }]);\n\n  return Lyric;\n}(lib[\"Component\"]);\n\nLyric_decorate([Prop({\n  type: Boolean,\n  required: false,\n  default: true\n}), Lyric_metadata(\"design:type\", Boolean)], Lyric_Lyric.prototype, \"visible\", void 0);\n\nLyric_decorate([Inject(), Lyric_metadata(\"design:type\", Object)], Lyric_Lyric.prototype, \"aplayer\", void 0);\n\nLyric_decorate([Watch('aplayer.lrcType', {\n  immediate: true\n}), Watch('aplayer.currentMusic.lrc', {\n  immediate: true\n}), Lyric_metadata(\"design:type\", Function), Lyric_metadata(\"design:paramtypes\", []), Lyric_metadata(\"design:returntype\", Promise)], Lyric_Lyric.prototype, \"handleChange\", null);\n\nLyric_Lyric = Lyric_decorate([vue_class_component_common_default.a], Lyric_Lyric);\n/* harmony default export */ var components_Lyric = (Lyric_Lyric);\n// CONCATENATED MODULE: ./packages/@moefe/vue-aplayer/components/Main.tsx\n\n\n\n\n\n\n\n\n\nvar Main_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar Main_metadata = undefined && undefined.__metadata || function (k, v) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar Main_a;\n\n\n\n\n\n\nvar Main_Main =\n/*#__PURE__*/\nfunction (_Vue$Component) {\n  _inherits(Main, _Vue$Component);\n\n  function Main() {\n    _classCallCheck(this, Main);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Main).apply(this, arguments));\n  }\n\n  _createClass(Main, [{\n    key: \"render\",\n    value: function render() {\n      var h = arguments[0];\n      var music = this.music;\n      var fixed = this.aplayer.fixed;\n      return h(\"div\", {\n        \"class\": \"aplayer-info\"\n      }, [h(\"div\", {\n        \"class\": \"aplayer-music\"\n      }, [h(\"span\", {\n        \"class\": \"aplayer-title\"\n      }, [music.name]), h(\"span\", {\n        \"class\": \"aplayer-author\"\n      }, [music.artist])]), !fixed ? h(components_Lyric) : null, this.$slots.default]);\n    }\n  }, {\n    key: \"music\",\n    get: function get() {\n      var currentMusic = this.aplayer.currentMusic;\n      return {\n        name: currentMusic.name,\n        artist: currentMusic.artist ? \" - \".concat(currentMusic.artist) : ''\n      };\n    }\n  }]);\n\n  return Main;\n}(lib[\"Component\"]);\n\nMain_decorate([Inject(), Main_metadata(\"design:type\", Object)], Main_Main.prototype, \"aplayer\", void 0);\n\nMain_Main = Main_decorate([vue_class_component_common_default.a], Main_Main);\n/* harmony default export */ var components_Main = (Main_Main);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.starts-with.js\nvar es6_string_starts_with = __webpack_require__(\"f559\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.string.pad-start.js\nvar es7_string_pad_start = __webpack_require__(\"f576\");\n\n// CONCATENATED MODULE: ./packages/@moefe/vue-touch/index.tsx\n\n\n\n\n\n\n\n\nvar vue_touch_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar vue_touch_metadata = undefined && undefined.__metadata || function (k, v) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\n\n\n\n\n\nvar vue_touch_Touch =\n/*#__PURE__*/\nfunction (_Vue$Component) {\n  _inherits(Touch, _Vue$Component);\n\n  function Touch() {\n    var _this;\n\n    _classCallCheck(this, Touch);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Touch).apply(this, arguments));\n    _this.isDragMove = false;\n    return _this;\n  }\n\n  _createClass(Touch, [{\n    key: \"thumbMove\",\n    value: function thumbMove(e) {\n      this.isDragMove = true;\n      this.$emit('panMove', e);\n    }\n  }, {\n    key: \"thumbUp\",\n    value: function thumbUp(e) {\n      document.removeEventListener(this.dragMove, this.thumbMove);\n      document.removeEventListener(this.dragEnd, this.thumbUp);\n      this.isDragMove = false;\n      this.$emit('panEnd', e);\n    }\n  }, {\n    key: \"mounted\",\n    value: function mounted() {\n      var _this2 = this;\n\n      this.$el.addEventListener(this.dragStart, function (e) {\n        _this2.$emit('panStart', e);\n\n        document.addEventListener(_this2.dragMove, _this2.thumbMove);\n        document.addEventListener(_this2.dragEnd, _this2.thumbUp);\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var h = arguments[0];\n      return h(\"div\", {\n        \"class\": this.classNames,\n        style: {\n          touchAction: 'none',\n          userSelect: 'none',\n          webkitUserDrag: 'none',\n          webkitTapHighlightColor: 'rgba(0, 0, 0, 0)'\n        }\n      }, [this.$slots.default]);\n    }\n  }, {\n    key: \"classNames\",\n    get: function get() {\n      var panMoveClass = this.panMoveClass,\n          isDragMove = this.isDragMove;\n      return _defineProperty({}, panMoveClass, isDragMove);\n    }\n  }, {\n    key: \"dragStart\",\n    get: function get() {\n      return this.isMobile ? 'touchstart' : 'mousedown';\n    }\n  }, {\n    key: \"dragMove\",\n    get: function get() {\n      return this.isMobile ? 'touchmove' : 'mousemove';\n    }\n  }, {\n    key: \"dragEnd\",\n    get: function get() {\n      return this.isMobile ? 'touchend' : 'mouseup';\n    }\n  }]);\n\n  return Touch;\n}(lib[\"Component\"]);\n\nvue_touch_decorate([Prop({\n  type: String,\n  required: false\n}), vue_touch_metadata(\"design:type\", String)], vue_touch_Touch.prototype, \"panMoveClass\", void 0);\n\nvue_touch_Touch = vue_touch_decorate([vue_class_component_common_default()({\n  mixins: [mixin]\n})], vue_touch_Touch);\n/* harmony default export */ var vue_touch = (vue_touch_Touch);\n// CONCATENATED MODULE: ./packages/@moefe/vue-aplayer/components/Button.tsx\n\n\n\n\n\n\n\nvar Button_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar Button_metadata = undefined && undefined.__metadata || function (k, v) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\n\n\n\n\n\nvar Button_Button =\n/*#__PURE__*/\nfunction (_Vue$Component) {\n  _inherits(Button, _Vue$Component);\n\n  function Button() {\n    _classCallCheck(this, Button);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Button).apply(this, arguments));\n  }\n\n  _createClass(Button, [{\n    key: \"handleClick\",\n    value: function handleClick() {\n      this.$emit('click');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var h = arguments[0];\n      return h(\"button\", {\n        attrs: {\n          type: \"button\"\n        },\n        \"class\": \"aplayer-icon aplayer-icon-\".concat(this.type),\n        on: {\n          \"click\": this.handleClick\n        }\n      }, [h(components_Icon, {\n        attrs: {\n          type: this.icon\n        }\n      })]);\n    }\n  }]);\n\n  return Button;\n}(lib[\"Component\"]);\n\nButton_decorate([Prop({\n  type: String,\n  required: true\n}), Button_metadata(\"design:type\", String)], Button_Button.prototype, \"type\", void 0);\n\nButton_decorate([Prop({\n  type: String,\n  required: true\n}), Button_metadata(\"design:type\", String)], Button_Button.prototype, \"icon\", void 0);\n\nButton_Button = Button_decorate([vue_class_component_common_default.a], Button_Button);\n/* harmony default export */ var components_Button = (Button_Button);\n// CONCATENATED MODULE: ./packages/@moefe/vue-aplayer/components/Progress.tsx\n\n\n\n\n\n\n\n\nvar Progress_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar Progress_metadata = undefined && undefined.__metadata || function (k, v) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar Progress_a;\n\n\n\n\n\n\n\nvar Progress_Progress =\n/*#__PURE__*/\nfunction (_Vue$Component) {\n  _inherits(Progress, _Vue$Component);\n\n  function Progress() {\n    _classCallCheck(this, Progress);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Progress).apply(this, arguments));\n  }\n\n  _createClass(Progress, [{\n    key: \"handleChange\",\n    value: function handleChange(e) {\n      var target = this.$refs.progressBar;\n      var targetLeft = target.getBoundingClientRect().left;\n      var clientX = !e.type.startsWith('touch') ? e.clientX : e.changedTouches[0].clientX;\n      var offsetLeft = clientX - targetLeft;\n      var percent = offsetLeft / target.offsetWidth;\n      percent = Math.min(percent, 1);\n      percent = Math.max(percent, 0);\n      this.handleChangeProgress(e, percent);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var h = arguments[0];\n      var _this$aplayer = this.aplayer,\n          currentTheme = _this$aplayer.currentTheme,\n          currentLoaded = _this$aplayer.currentLoaded,\n          currentPlayed = _this$aplayer.currentPlayed;\n      return h(vue_touch, {\n        \"class\": \"aplayer-bar-wrap\",\n        on: {\n          \"panMove\": this.handleChange,\n          \"panEnd\": this.handleChange\n        }\n      }, [h(\"div\", {\n        ref: \"progressBar\",\n        \"class\": \"aplayer-bar\"\n      }, [h(\"div\", {\n        \"class\": \"aplayer-loaded\",\n        style: {\n          width: \"\".concat(currentLoaded * 100, \"%\")\n        }\n      }), h(\"div\", {\n        \"class\": \"aplayer-played\",\n        style: {\n          width: \"\".concat(currentPlayed * 100, \"%\"),\n          backgroundColor: currentTheme\n        }\n      }, [h(\"span\", {\n        \"class\": \"aplayer-thumb\",\n        style: {\n          backgroundColor: currentTheme\n        }\n      }, [h(\"span\", {\n        \"class\": \"aplayer-loading-icon\"\n      }, [h(components_Icon, {\n        attrs: {\n          type: \"loading\"\n        }\n      })])])])])]);\n    }\n  }]);\n\n  return Progress;\n}(lib[\"Component\"]);\n\nProgress_decorate([Inject(), Progress_metadata(\"design:type\", Object)], Progress_Progress.prototype, \"aplayer\", void 0);\n\nProgress_decorate([Inject(), Progress_metadata(\"design:type\", Function)], Progress_Progress.prototype, \"handleChangeProgress\", void 0);\n\nProgress_Progress = Progress_decorate([vue_class_component_common_default.a], Progress_Progress);\n/* harmony default export */ var components_Progress = (Progress_Progress);\n// CONCATENATED MODULE: ./packages/@moefe/vue-aplayer/components/Controller.tsx\n\n\n\n\n\n\n\n\n\n\nvar Controller_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar Controller_metadata = undefined && undefined.__metadata || function (k, v) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar Controller_a;\n\n\n\n\n\n\n\n\n\nvar Controller_Controller =\n/*#__PURE__*/\nfunction (_Vue$Component) {\n  _inherits(Controller, _Vue$Component);\n\n  function Controller() {\n    _classCallCheck(this, Controller);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Controller).apply(this, arguments));\n  }\n\n  _createClass(Controller, [{\n    key: \"timeSecondsFormat\",\n    // eslint-disable-next-line class-methods-use-this\n    value: function timeSecondsFormat() {\n      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var minutes = Math.floor(time / 60) || 0;\n      var seconds = Math.floor(time % 60) || 0;\n      return \"\".concat(minutes.toString().padStart(2, '0'), \":\").concat(seconds.toString().padStart(2, '0')); // prettier-ignore\n    }\n  }, {\n    key: \"handleToggleVolume\",\n    value: function handleToggleVolume() {\n      var _this$aplayer = this.aplayer,\n          currentVolume = _this$aplayer.currentVolume,\n          currentSettings = _this$aplayer.currentSettings;\n      this.handleChangeVolume(currentVolume > 0 ? 0 : currentSettings.volume);\n    }\n  }, {\n    key: \"handleClickVolumeBar\",\n    value: function handleClickVolumeBar(e) {\n      this.handlePanMove(e);\n    }\n  }, {\n    key: \"handlePanMove\",\n    value: function handlePanMove(e) {\n      var target = this.$refs.volumeBar;\n      var targetTop = target.getBoundingClientRect().bottom;\n      if (targetTop <= 0) return; // 音量控制面板已隐藏\n\n      var clientY = !e.type.startsWith('touch') ? e.clientY : e.changedTouches[0].clientY;\n      var offsetTop = Math.round(targetTop - clientY);\n      var volume = offsetTop / target.offsetHeight;\n      volume = Math.min(volume, 1);\n      volume = Math.max(volume, 0);\n      this.handleChangeVolume(volume);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var h = arguments[0];\n      var ptime = this.ptime,\n          dtime = this.dtime,\n          volumeIcon = this.volumeIcon;\n      var _this$aplayer2 = this.aplayer,\n          lrcType = _this$aplayer2.lrcType,\n          currentTheme = _this$aplayer2.currentTheme,\n          currentVolume = _this$aplayer2.currentVolume,\n          currentOrder = _this$aplayer2.currentOrder,\n          currentLoop = _this$aplayer2.currentLoop;\n      return h(\"div\", {\n        \"class\": \"aplayer-controller\"\n      }, [h(components_Progress), h(\"div\", {\n        \"class\": \"aplayer-time\"\n      }, [h(\"span\", {\n        \"class\": \"aplayer-time-inner\"\n      }, [h(\"span\", {\n        \"class\": \"aplayer-ptime\"\n      }, [ptime]), \" /\", ' ', h(\"span\", {\n        \"class\": \"aplayer-dtime\"\n      }, [dtime]), ' ']), h(\"span\", {\n        \"class\": \"aplayer-icon aplayer-icon-back\",\n        on: {\n          \"click\": this.handleSkipBack\n        }\n      }, [h(components_Icon, {\n        attrs: {\n          type: \"skip\"\n        }\n      })]), h(\"span\", {\n        \"class\": \"aplayer-icon aplayer-icon-play\",\n        on: {\n          \"click\": this.handleTogglePlay\n        }\n      }, [h(components_Icon, {\n        attrs: {\n          type: this.playIcon\n        }\n      })]), h(\"span\", {\n        \"class\": \"aplayer-icon aplayer-icon-forward\",\n        on: {\n          \"click\": this.handleSkipForward\n        }\n      }, [h(components_Icon, {\n        attrs: {\n          type: \"skip\"\n        }\n      })]), h(\"div\", {\n        \"class\": \"aplayer-volume-wrap\"\n      }, [h(components_Button, {\n        attrs: {\n          type: \"volume-\".concat(volumeIcon),\n          icon: \"volume-\".concat(volumeIcon)\n        },\n        on: {\n          \"click\": this.handleToggleVolume\n        }\n      }), h(vue_touch, {\n        \"class\": \"aplayer-volume-bar-wrap\",\n        attrs: {\n          panMoveClass: \"aplayer-volume-bar-wrap-active\"\n        },\n        on: {\n          \"panMove\": this.handlePanMove\n        }\n      }, [h(\"div\", {\n        ref: \"volumeBar\",\n        \"class\": \"aplayer-volume-bar\",\n        on: {\n          \"click\": this.handleClickVolumeBar\n        }\n      }, [h(\"div\", {\n        \"class\": \"aplayer-volume\",\n        style: {\n          height: \"\".concat(currentVolume * 100, \"%\"),\n          backgroundColor: currentTheme\n        }\n      })])])]), ' ', h(components_Button, {\n        attrs: {\n          type: \"order\",\n          icon: \"order-\".concat(currentOrder)\n        },\n        on: {\n          \"click\": this.handleToggleOrderMode\n        }\n      }), ' ', h(components_Button, {\n        attrs: {\n          type: \"loop\",\n          icon: \"loop-\".concat(currentLoop)\n        },\n        on: {\n          \"click\": this.handleToggleLoopMode\n        }\n      }), ' ', h(components_Button, {\n        attrs: {\n          type: \"menu\",\n          icon: \"menu\"\n        },\n        on: {\n          \"click\": this.handleTogglePlaylist\n        }\n      }), lrcType !== 0 ? h(components_Button, {\n        attrs: {\n          type: \"lrc\",\n          icon: \"lrc\"\n        },\n        on: {\n          \"click\": this.handleToggleLyric\n        }\n      }) : null])]);\n    }\n  }, {\n    key: \"playIcon\",\n    get: function get() {\n      return this.aplayer.media.paused ? 'play' : 'pause';\n    }\n  }, {\n    key: \"volumeIcon\",\n    get: function get() {\n      var currentVolume = this.aplayer.currentVolume;\n      return currentVolume <= 0 ? 'off' : currentVolume >= 0.95 ? 'up' : 'down'; // eslint-disable-line no-nested-ternary\n    }\n  }, {\n    key: \"ptime\",\n    get: function get() {\n      var _this$aplayer3 = this.aplayer,\n          media = _this$aplayer3.media,\n          currentPlayed = _this$aplayer3.currentPlayed;\n      return this.timeSecondsFormat(currentPlayed * media.duration);\n    }\n  }, {\n    key: \"dtime\",\n    get: function get() {\n      return this.timeSecondsFormat(this.aplayer.media.duration);\n    }\n  }]);\n\n  return Controller;\n}(lib[\"Component\"]);\n\nController_decorate([Inject(), Controller_metadata(\"design:type\", Object)], Controller_Controller.prototype, \"aplayer\", void 0);\n\nController_decorate([Inject(), Controller_metadata(\"design:type\", Function)], Controller_Controller.prototype, \"handleSkipBack\", void 0);\n\nController_decorate([Inject(), Controller_metadata(\"design:type\", Function)], Controller_Controller.prototype, \"handleSkipForward\", void 0);\n\nController_decorate([Inject(), Controller_metadata(\"design:type\", Function)], Controller_Controller.prototype, \"handleTogglePlay\", void 0);\n\nController_decorate([Inject(), Controller_metadata(\"design:type\", Function)], Controller_Controller.prototype, \"handleToggleOrderMode\", void 0);\n\nController_decorate([Inject(), Controller_metadata(\"design:type\", Function)], Controller_Controller.prototype, \"handleToggleLoopMode\", void 0);\n\nController_decorate([Inject(), Controller_metadata(\"design:type\", Function)], Controller_Controller.prototype, \"handleTogglePlaylist\", void 0);\n\nController_decorate([Inject(), Controller_metadata(\"design:type\", Function)], Controller_Controller.prototype, \"handleToggleLyric\", void 0);\n\nController_decorate([Inject(), Controller_metadata(\"design:type\", Function)], Controller_Controller.prototype, \"handleChangeVolume\", void 0);\n\nController_Controller = Controller_decorate([vue_class_component_common_default.a], Controller_Controller);\n/* harmony default export */ var components_Controller = (Controller_Controller);\n// CONCATENATED MODULE: ./packages/@moefe/vue-aplayer/components/Player.tsx\n\n\n\n\n\n\n\n\nvar Player_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar Player_metadata = undefined && undefined.__metadata || function (k, v) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar Player_a, Player_b;\n\n\n\n\n\n\n\n\n\n\nvar Player_Player =\n/*#__PURE__*/\nfunction (_Vue$Component) {\n  _inherits(Player, _Vue$Component);\n\n  function Player() {\n    _classCallCheck(this, Player);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Player).apply(this, arguments));\n  }\n\n  _createClass(Player, [{\n    key: \"handleTogglePlay\",\n    value: function handleTogglePlay() {\n      this.$emit('togglePlay');\n    }\n  }, {\n    key: \"handleSkipBack\",\n    value: function handleSkipBack() {\n      this.$emit('skipBack');\n    }\n  }, {\n    key: \"handleSkipForward\",\n    value: function handleSkipForward() {\n      this.$emit('skipForward');\n    }\n  }, {\n    key: \"handleToggleOrderMode\",\n    value: function handleToggleOrderMode() {\n      this.$emit('toggleOrderMode');\n    }\n  }, {\n    key: \"handleToggleLoopMode\",\n    value: function handleToggleLoopMode() {\n      this.$emit('toggleLoopMode');\n    }\n  }, {\n    key: \"handleTogglePlaylist\",\n    value: function handleTogglePlaylist() {\n      this.$emit('togglePlaylist');\n    }\n  }, {\n    key: \"handleToggleLyric\",\n    value: function handleToggleLyric() {\n      this.$emit('toggleLyric');\n    }\n  }, {\n    key: \"handleChangeVolume\",\n    value: function handleChangeVolume(volume) {\n      this.$emit('changeVolume', volume);\n    }\n  }, {\n    key: \"handleChangeProgress\",\n    value: function handleChangeProgress(e, percent) {\n      this.$emit('changeProgress', e, percent);\n    }\n  }, {\n    key: \"handleMiniSwitcher\",\n    value: function handleMiniSwitcher() {\n      this.$emit('miniSwitcher');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var h = arguments[0];\n      var playIcon = this.playIcon,\n          notice = this.notice;\n      return h(\"div\", {\n        \"class\": \"aplayer-body\"\n      }, [h(components_Cover, {\n        on: {\n          \"click\": this.handleTogglePlay\n        }\n      }, [h(\"div\", {\n        \"class\": \"aplayer-button aplayer-\".concat(playIcon)\n      }, [h(components_Icon, {\n        attrs: {\n          type: playIcon\n        }\n      })])]), h(components_Main, [h(components_Controller, {\n        on: {\n          \"skipBack\": this.handleSkipBack,\n          \"skipForward\": this.handleSkipForward,\n          \"togglePlay\": this.handleTogglePlay,\n          \"toggleOrderMode\": this.handleToggleOrderMode,\n          \"toggleLoopMode\": this.handleToggleLoopMode,\n          \"togglePlaylist\": this.handleTogglePlaylist,\n          \"toggleLyric\": this.handleToggleLyric,\n          \"changeVolume\": this.handleChangeVolume,\n          \"changeProgress\": this.handleChangeProgress\n        }\n      })]), h(\"div\", {\n        \"class\": \"aplayer-notice\",\n        style: {\n          opacity: notice.opacity\n        }\n      }, [notice.text]), h(\"div\", {\n        \"class\": \"aplayer-miniswitcher\",\n        on: {\n          \"click\": this.handleMiniSwitcher\n        }\n      }, [h(components_Button, {\n        attrs: {\n          type: \"miniswitcher\",\n          icon: \"right\"\n        }\n      })])]);\n    }\n  }, {\n    key: \"playIcon\",\n    get: function get() {\n      return this.aplayer.media.paused ? 'play' : 'pause';\n    }\n  }]);\n\n  return Player;\n}(lib[\"Component\"]);\n\nPlayer_decorate([Prop({\n  type: Object,\n  required: true\n}), Player_metadata(\"design:type\", Object)], Player_Player.prototype, \"notice\", void 0);\n\nPlayer_decorate([Inject(), Player_metadata(\"design:type\", Object)], Player_Player.prototype, \"aplayer\", void 0);\n\nPlayer_decorate([Provide(), Player_metadata(\"design:type\", Function), Player_metadata(\"design:paramtypes\", []), Player_metadata(\"design:returntype\", void 0)], Player_Player.prototype, \"handleTogglePlay\", null);\n\nPlayer_decorate([Provide(), Player_metadata(\"design:type\", Function), Player_metadata(\"design:paramtypes\", []), Player_metadata(\"design:returntype\", void 0)], Player_Player.prototype, \"handleSkipBack\", null);\n\nPlayer_decorate([Provide(), Player_metadata(\"design:type\", Function), Player_metadata(\"design:paramtypes\", []), Player_metadata(\"design:returntype\", void 0)], Player_Player.prototype, \"handleSkipForward\", null);\n\nPlayer_decorate([Provide(), Player_metadata(\"design:type\", Function), Player_metadata(\"design:paramtypes\", []), Player_metadata(\"design:returntype\", void 0)], Player_Player.prototype, \"handleToggleOrderMode\", null);\n\nPlayer_decorate([Provide(), Player_metadata(\"design:type\", Function), Player_metadata(\"design:paramtypes\", []), Player_metadata(\"design:returntype\", void 0)], Player_Player.prototype, \"handleToggleLoopMode\", null);\n\nPlayer_decorate([Provide(), Player_metadata(\"design:type\", Function), Player_metadata(\"design:paramtypes\", []), Player_metadata(\"design:returntype\", void 0)], Player_Player.prototype, \"handleTogglePlaylist\", null);\n\nPlayer_decorate([Provide(), Player_metadata(\"design:type\", Function), Player_metadata(\"design:paramtypes\", []), Player_metadata(\"design:returntype\", void 0)], Player_Player.prototype, \"handleToggleLyric\", null);\n\nPlayer_decorate([Provide(), Player_metadata(\"design:type\", Function), Player_metadata(\"design:paramtypes\", [Number]), Player_metadata(\"design:returntype\", void 0)], Player_Player.prototype, \"handleChangeVolume\", null);\n\nPlayer_decorate([Provide(), Player_metadata(\"design:type\", Function), Player_metadata(\"design:paramtypes\", [Object, Number]), Player_metadata(\"design:returntype\", void 0)], Player_Player.prototype, \"handleChangeProgress\", null);\n\nPlayer_Player = Player_decorate([vue_class_component_common_default.a], Player_Player);\n/* harmony default export */ var components_Player = (Player_Player);\n// CONCATENATED MODULE: ./packages/@moefe/vue-aplayer/components/PlayList.tsx\n\n\n\n\n\n\n\n\n\n\n\n\nvar PlayList_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar PlayList_metadata = undefined && undefined.__metadata || function (k, v) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar PlayList_a, PlayList_b, _c;\n\n\n\n\n\n\nvar PlayList_PlayList =\n/*#__PURE__*/\nfunction (_Vue$Component) {\n  _inherits(PlayList, _Vue$Component);\n\n  function PlayList() {\n    _classCallCheck(this, PlayList);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PlayList).apply(this, arguments));\n  }\n\n  _createClass(PlayList, [{\n    key: \"handleChangeScrollTop\",\n    value: function () {\n      var _handleChangeScrollTop = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.$nextTick();\n\n              case 2:\n                if (this.visible) {\n                  this.$refs.list.scrollTop = this.scrollTop;\n                }\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function handleChangeScrollTop() {\n        return _handleChangeScrollTop.apply(this, arguments);\n      }\n\n      return handleChangeScrollTop;\n    }()\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this = this;\n\n      var h = arguments[0];\n      var listHeight = this.listHeight,\n          dataSource = this.dataSource,\n          currentMusic = this.currentMusic;\n      var currentTheme = this.aplayer.currentTheme;\n      return h(\"ol\", {\n        ref: \"list\",\n        \"class\": \"aplayer-list\",\n        style: {\n          height: \"\".concat(listHeight, \"px\")\n        }\n      }, [dataSource.map(function (item, index) {\n        return h(\"li\", {\n          key: item.id,\n          \"class\": classnames_default()({\n            'aplayer-list-light': item.id === currentMusic.id\n          }),\n          on: {\n            \"click\": function click() {\n              return _this.$emit('change', item, index);\n            }\n          }\n        }, [h(\"span\", {\n          \"class\": \"aplayer-list-cur\",\n          style: {\n            backgroundColor: currentTheme\n          }\n        }), h(\"span\", {\n          \"class\": \"aplayer-list-index\"\n        }, [index + 1]), ' ', h(\"span\", {\n          \"class\": \"aplayer-list-title\"\n        }, [item.name]), h(\"span\", {\n          \"class\": \"aplayer-list-author\"\n        }, [item.artist])]);\n      })]);\n    }\n  }, {\n    key: \"listHeight\",\n    get: function get() {\n      var visible = this.visible,\n          dataSource = this.dataSource;\n      return visible ? Math.min(dataSource.length * 33, Number(this.aplayer.listMaxHeight)) : 0;\n    }\n  }]);\n\n  return PlayList;\n}(lib[\"Component\"]);\n\nPlayList_decorate([Prop({\n  type: Boolean,\n  required: false,\n  default: true\n}), PlayList_metadata(\"design:type\", Boolean)], PlayList_PlayList.prototype, \"visible\", void 0);\n\nPlayList_decorate([Prop({\n  type: Object,\n  required: true\n}), PlayList_metadata(\"design:type\", typeof (PlayList_a = typeof APlayer !== \"undefined\" && APlayer.Audio) === \"function\" ? PlayList_a : Object)], PlayList_PlayList.prototype, \"currentMusic\", void 0);\n\nPlayList_decorate([Prop({\n  type: Array,\n  required: true\n}), PlayList_metadata(\"design:type\", typeof (PlayList_b = typeof Array !== \"undefined\" && Array) === \"function\" ? PlayList_b : Object)], PlayList_PlayList.prototype, \"dataSource\", void 0);\n\nPlayList_decorate([Prop({\n  type: Number,\n  required: true\n}), PlayList_metadata(\"design:type\", Number)], PlayList_PlayList.prototype, \"scrollTop\", void 0);\n\nPlayList_decorate([Inject(), PlayList_metadata(\"design:type\", Object)], PlayList_PlayList.prototype, \"aplayer\", void 0);\n\nPlayList_decorate([Watch('scrollTop', {\n  immediate: true\n}), Watch('dataSource', {\n  immediate: true,\n  deep: true\n}), Watch('visible'), PlayList_metadata(\"design:type\", Function), PlayList_metadata(\"design:paramtypes\", []), PlayList_metadata(\"design:returntype\", Promise)], PlayList_PlayList.prototype, \"handleChangeScrollTop\", null);\n\nPlayList_PlayList = PlayList_decorate([vue_class_component_common_default.a], PlayList_PlayList);\n/* harmony default export */ var components_PlayList = (PlayList_PlayList);\n// EXTERNAL MODULE: ./packages/@moefe/vue-aplayer/assets/style/aplayer.scss\nvar aplayer = __webpack_require__(\"610a\");\n\n// CONCATENATED MODULE: ./packages/@moefe/vue-aplayer/components/APlayer.tsx\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar APlayer_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar APlayer_metadata = undefined && undefined.__metadata || function (k, v) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar APlayer_a, APlayer_b, APlayer_c, _d, _e, _f, _g, _h;\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar instances = [];\nvar store = new vue_store();\nvar channel = null;\n\nif (typeof BroadcastChannel !== 'undefined') {\n  channel = new BroadcastChannel('aplayer');\n}\n\nvar APlayer_APlayer =\n/*#__PURE__*/\nfunction (_Vue$Component) {\n  _inherits(APlayer, _Vue$Component);\n\n  function APlayer() {\n    var _this;\n\n    _classCallCheck(this, APlayer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(APlayer).apply(this, arguments)); // 是否正在拖动进度条（防止抖动）\n\n    _this.isDraggingProgressBar = false; // 是否正在等待进度条更新（防止抖动）\n\n    _this.isAwaitChangeProgressBar = false; // 是否是迷你模式\n\n    _this.isMini = _this.mini !== null ? _this.mini : _this.fixed; // 是否是 arrow 模式\n\n    _this.isArrow = false; // 当 currentMusic 改变时是否允许播放\n\n    _this.canPlay = !_this.isMobile && _this.autoplay; // 播放列表是否可见\n\n    _this.listVisible = !_this.listFolded; // 控制迷你模式下的歌词是否可见\n\n    _this.lyricVisible = true; // 封面图片对象\n\n    _this.img = new Image(); // 封面下载对象\n\n    _this.xhr = new utils_HttpRequest(); // 响应式媒体对象\n\n    _this.media = new vue_audio(); // 核心音频对象\n\n    _this.player = _this.media.audio; // 播放器设置存储对象\n\n    _this.store = store; // 当前播放的音乐\n\n    _this.currentMusic = {\n      id: NaN,\n      name: '未加载音频',\n      artist: '(ಗ ‸ ಗ )',\n      url: ''\n    }; // 当前已播放比例\n\n    _this.currentPlayed = 0; // 当前音量\n\n    _this.currentVolume = _this.volume; // 当前循环模式\n\n    _this.currentLoop = _this.loop; // 当前顺序模式\n\n    _this.currentOrder = _this.order; // 当前主题，通过封面自适应主题 > 当前播放的音乐指定的主题 > 主题选项\n\n    _this.currentTheme = _this.currentMusic.theme || _this.theme; // 通知对象\n\n    _this.notice = {\n      text: '',\n      time: 2000,\n      opacity: 0\n    };\n    return _this;\n  } // #endregion\n  // 提供当前实例的引用，让子组件获取该实例的可响应数据\n\n\n  _createClass(APlayer, [{\n    key: \"handleChangePlayList\",\n    // #region 监听属性\n    value: function () {\n      var _handleChangePlayList = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(newList, oldList) {\n        var newLength, oldLength, _this$currentMusic, id, url, oldIndex, _this$currentList, music;\n\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (oldList) {\n                  newLength = newList.length;\n                  oldLength = oldList.length;\n\n                  if (newLength !== oldLength) {\n                    if (newLength <= 0) this.$emit('listClear');else if (newLength > oldLength) this.$emit('listAdd');else {\n                      if (this.currentOrderIndex < 0) {\n                        _this$currentMusic = this.currentMusic, id = _this$currentMusic.id, url = _this$currentMusic.url;\n                        oldIndex = oldList.findIndex(function (item) {\n                          return item.id === id || item.url === url;\n                        });\n                        Object.assign(this.currentMusic, oldList[oldIndex - 1]);\n                      }\n\n                      this.canPlay = !this.player.paused;\n                      this.$emit('listRemove');\n                    }\n                  }\n                } // 播放列表初始化\n\n\n                if (!(this.orderList.length > 0)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                if (!this.currentMusic.id) {\n                  _this$currentList = _slicedToArray(this.currentList, 1);\n                  this.currentMusic = _this$currentList[0];\n                } else {\n                  this.canPlay = !this.player.paused;\n                  music = this.orderList[this.currentOrderIndex] || this.orderList[0]; // eslint-disable-line max-len\n\n                  Object.assign(this.currentMusic, music);\n                }\n\n                _context.next = 5;\n                return this.$nextTick();\n\n              case 5:\n                this.canPlay = true;\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function handleChangePlayList(_x, _x2) {\n        return _handleChangePlayList.apply(this, arguments);\n      }\n\n      return handleChangePlayList;\n    }()\n  }, {\n    key: \"handleChangeCurrentMusic\",\n    value: function () {\n      var _handleChangeCurrentMusic = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee3(newMusic, oldMusic) {\n        var _this2 = this;\n\n        var cover, src;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (newMusic.theme) {\n                  this.currentTheme = newMusic.theme;\n                } else {\n                  cover = newMusic.cover || this.options.defaultCover;\n\n                  if (cover) {\n                    setTimeout(\n                    /*#__PURE__*/\n                    _asyncToGenerator(\n                    /*#__PURE__*/\n                    regeneratorRuntime.mark(function _callee2() {\n                      return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                        while (1) {\n                          switch (_context2.prev = _context2.next) {\n                            case 0:\n                              _context2.prev = 0;\n                              _context2.next = 3;\n                              return _this2.getThemeColorFromCover(cover);\n\n                            case 3:\n                              _this2.currentTheme = _context2.sent;\n                              _context2.next = 9;\n                              break;\n\n                            case 6:\n                              _context2.prev = 6;\n                              _context2.t0 = _context2[\"catch\"](0);\n                              _this2.currentTheme = newMusic.theme || _this2.theme;\n\n                            case 9:\n                            case \"end\":\n                              return _context2.stop();\n                          }\n                        }\n                      }, _callee2, this, [[0, 6]]);\n                    })));\n                  }\n                }\n\n                if (!newMusic.url) {\n                  _context3.next = 15;\n                  break;\n                }\n\n                if (!((oldMusic !== undefined && oldMusic.url) !== newMusic.url || this.player.src !== newMusic.url)) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                this.currentPlayed = 0;\n\n                if (oldMusic && oldMusic.id) {\n                  // 首次初始化时不要触发事件\n                  this.handleChangeSettings();\n                  this.$emit('listSwitch', newMusic);\n                }\n\n                _context3.next = 7;\n                return this.getAudioUrl(newMusic);\n\n              case 7:\n                src = _context3.sent;\n                if (src) this.player.src = src;\n                this.player.playbackRate = newMusic.speed || 1;\n                this.player.preload = this.preload;\n                this.player.volume = this.currentVolume;\n                this.player.currentTime = 0;\n\n                this.player.onerror = function (e) {\n                  _this2.showNotice(e.toString());\n                };\n\n              case 14:\n                // **请勿移动此行**，否则当歌曲结束播放时如果歌单中只有一首歌曲将无法重复播放\n                if (this.canPlay) this.play();\n\n              case 15:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function handleChangeCurrentMusic(_x3, _x4) {\n        return _handleChangeCurrentMusic.apply(this, arguments);\n      }\n\n      return handleChangeCurrentMusic;\n    }()\n  }, {\n    key: \"handleChangeVolume\",\n    value: function handleChangeVolume(volume) {\n      this.currentVolume = volume;\n    }\n  }, {\n    key: \"handleChangeCurrentVolume\",\n    value: function handleChangeCurrentVolume() {\n      this.player.volume = this.currentVolume;\n      this.$emit('update:volume', this.currentVolume);\n    }\n  }, {\n    key: \"handleChangeCurrentTime\",\n    value: function handleChangeCurrentTime() {\n      if (!this.isDraggingProgressBar && !this.isAwaitChangeProgressBar) {\n        this.currentPlayed = this.media.currentTime / this.media.duration || 0;\n      }\n    }\n  }, {\n    key: \"handleChangeSettings\",\n    value: function handleChangeSettings() {\n      var settings = {\n        currentTime: this.media.currentTime,\n        duration: this.media.duration,\n        paused: this.media.paused,\n        mini: this.isMini,\n        lrc: this.lyricVisible,\n        list: this.listVisible,\n        volume: this.currentVolume,\n        loop: this.currentLoop,\n        order: this.currentOrder,\n        music: this.currentMusic\n      };\n\n      if (settings.volume <= 0) {\n        settings.volume = this.currentSettings.volume;\n      }\n\n      this.saveSettings(settings);\n    }\n  }, {\n    key: \"handleChangeEnded\",\n    value: function handleChangeEnded() {\n      if (!this.media.ended) return;\n      this.currentPlayed = 0;\n\n      switch (this.currentLoop) {\n        default:\n        case 'all':\n          this.handleSkipForward();\n          break;\n\n        case 'one':\n          this.play();\n          break;\n\n        case 'none':\n          if (this.currentIndex === this.currentList.length - 1) {\n            var _this$currentList2 = _slicedToArray(this.currentList, 1);\n\n            this.currentMusic = _this$currentList2[0];\n            this.pause();\n            this.canPlay = false;\n          } else this.handleSkipForward();\n\n          break;\n      }\n    }\n  }, {\n    key: \"handleChangeMini\",\n    value: function handleChangeMini() {\n      this.isMini = this.mini;\n    }\n  }, {\n    key: \"handleChangeCurrentMini\",\n    value: function () {\n      var _handleChangeCurrentMini = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee4(newVal, oldVal) {\n        var container;\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.$nextTick();\n\n              case 2:\n                container = this.$refs.container;\n                this.isArrow = container && container.offsetWidth <= 300;\n\n                if (oldVal !== undefined) {\n                  this.$emit('update:mini', this.isMini);\n                  this.handleChangeSettings();\n                }\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function handleChangeCurrentMini(_x5, _x6) {\n        return _handleChangeCurrentMini.apply(this, arguments);\n      }\n\n      return handleChangeCurrentMini;\n    }()\n  }, {\n    key: \"handleChangeLoop\",\n    value: function handleChangeLoop() {\n      this.currentLoop = this.loop;\n    }\n  }, {\n    key: \"handleChangeCurrentLoop\",\n    value: function handleChangeCurrentLoop() {\n      this.$emit('update:loop', this.currentLoop);\n      this.handleChangeSettings();\n    }\n  }, {\n    key: \"handleChangeOrder\",\n    value: function handleChangeOrder() {\n      this.currentOrder = this.order;\n    }\n  }, {\n    key: \"handleChangeCurrentOrder\",\n    value: function handleChangeCurrentOrder() {\n      this.$emit('update:order', this.currentOrder);\n      this.handleChangeSettings();\n    }\n  }, {\n    key: \"handleChangeListVisible\",\n    value: function handleChangeListVisible() {\n      this.$emit(this.listVisible ? 'listShow' : 'listHide');\n      this.$emit('update:listFolded', this.listVisible);\n      this.handleChangeSettings();\n    }\n  }, {\n    key: \"handleChangeLyricVisible\",\n    value: function handleChangeLyricVisible() {\n      this.$emit(this.lyricVisible ? 'lrcShow' : 'lrcHide');\n      this.handleChangeSettings();\n    } // #endregion\n    // #region 公开 API\n\n  }, {\n    key: \"play\",\n    value: function () {\n      var _play = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee5() {\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n                if (this.mutex) this.pauseOtherInstances();\n                _context5.next = 4;\n                return this.player.play();\n\n              case 4:\n                _context5.next = 10;\n                break;\n\n              case 6:\n                _context5.prev = 6;\n                _context5.t0 = _context5[\"catch\"](0);\n                this.showNotice(_context5.t0.message);\n                this.player.pause();\n\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 6]]);\n      }));\n\n      function play() {\n        return _play.apply(this, arguments);\n      }\n\n      return play;\n    }()\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this.player.pause();\n    }\n  }, {\n    key: \"toggle\",\n    value: function toggle() {\n      if (this.media.paused) this.play();else this.pause();\n    }\n  }, {\n    key: \"seeking\",\n    value: function () {\n      var _seeking = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee6(percent) {\n        var paused,\n            oldPaused,\n            _args6 = arguments;\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                paused = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : true;\n                _context6.prev = 1;\n                this.isAwaitChangeProgressBar = true;\n\n                if (!(this.preload === 'none')) {\n                  _context6.next = 11;\n                  break;\n                }\n\n                if (this.player.src) {\n                  _context6.next = 7;\n                  break;\n                }\n\n                _context6.next = 7;\n                return this.media.srcLoaded();\n\n              case 7:\n                oldPaused = this.player.paused;\n                _context6.next = 10;\n                return this.play();\n\n              case 10:\n                // preload 为 none 的情况下必须先 play\n                if (paused && oldPaused) this.pause();\n\n              case 11:\n                if (paused) this.pause();\n                _context6.next = 14;\n                return this.media.loaded();\n\n              case 14:\n                this.player.currentTime = percent * this.media.duration;\n\n                if (!paused) {\n                  this.play();\n\n                  if (channel && this.mutex) {\n                    channel.postMessage('mutex');\n                  }\n                }\n\n                _context6.next = 21;\n                break;\n\n              case 18:\n                _context6.prev = 18;\n                _context6.t0 = _context6[\"catch\"](1);\n                this.showNotice(_context6.t0.message);\n\n              case 21:\n                _context6.prev = 21;\n                this.isAwaitChangeProgressBar = false;\n                return _context6.finish(21);\n\n              case 24:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[1, 18, 21, 24]]);\n      }));\n\n      function seeking(_x7) {\n        return _seeking.apply(this, arguments);\n      }\n\n      return seeking;\n    }()\n  }, {\n    key: \"seek\",\n    value: function seek(time) {\n      this.seeking(time / this.media.duration, this.media.paused);\n    }\n  }, {\n    key: \"switch\",\n    value: function _switch(audio) {\n      switch (_typeof(audio)) {\n        case 'number':\n          this.currentMusic = this.orderList[Math.min(Math.max(0, audio), this.orderList.length - 1)];\n          break;\n        // eslint-disable-next-line no-case-declarations\n\n        default:\n          var music = this.orderList.find(function (item) {\n            return typeof item.name === 'string' && item.name.includes(audio);\n          });\n          if (music) this.currentMusic = music;\n          break;\n      }\n    }\n  }, {\n    key: \"skipBack\",\n    value: function skipBack() {\n      var playIndex = this.getPlayIndexByMode('skipBack');\n      this.currentMusic = _objectSpread({}, this.currentList[playIndex]);\n    }\n  }, {\n    key: \"skipForward\",\n    value: function skipForward() {\n      var playIndex = this.getPlayIndexByMode('skipForward');\n      this.currentMusic = _objectSpread({}, this.currentList[playIndex]);\n    }\n  }, {\n    key: \"showLrc\",\n    value: function showLrc() {\n      this.lyricVisible = true;\n    }\n  }, {\n    key: \"hideLrc\",\n    value: function hideLrc() {\n      this.lyricVisible = false;\n    }\n  }, {\n    key: \"toggleLrc\",\n    value: function toggleLrc() {\n      this.lyricVisible = !this.lyricVisible;\n    }\n  }, {\n    key: \"showList\",\n    value: function showList() {\n      this.listVisible = true;\n    }\n  }, {\n    key: \"hideList\",\n    value: function hideList() {\n      this.listVisible = false;\n    }\n  }, {\n    key: \"toggleList\",\n    value: function toggleList() {\n      this.listVisible = !this.listVisible;\n    }\n  }, {\n    key: \"showNotice\",\n    value: function showNotice(text) {\n      var _this3 = this;\n\n      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;\n      var opacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.8;\n      return new Promise(function (resolve) {\n        if (_this3.isMini) {\n          // eslint-disable-next-line no-console\n          console.warn('aplayer notice:', text);\n          resolve();\n        } else {\n          _this3.notice = {\n            text: text,\n            time: time,\n            opacity: opacity\n          };\n\n          _this3.$emit('noticeShow');\n\n          if (time > 0) {\n            setTimeout(function () {\n              _this3.notice.opacity = 0;\n\n              _this3.$emit('noticeHide');\n\n              resolve();\n            }, time);\n          }\n        }\n      });\n    } // #endregion\n    // #region 私有 API\n    // 从封面中获取主题颜色\n\n  }, {\n    key: \"getThemeColorFromCover\",\n    value: function getThemeColorFromCover(url) {\n      var _this4 = this;\n\n      return new Promise(\n      /*#__PURE__*/\n      function () {\n        var _ref2 = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee7(resolve, reject) {\n          var image, reader;\n          return regeneratorRuntime.wrap(function _callee7$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  _context7.prev = 0;\n\n                  if (!(typeof ColorThief !== 'undefined')) {\n                    _context7.next = 12;\n                    break;\n                  }\n\n                  _context7.next = 4;\n                  return _this4.xhr.download(url, 'blob');\n\n                case 4:\n                  image = _context7.sent;\n                  reader = new FileReader();\n\n                  reader.onload = function () {\n                    _this4.img.src = reader.result;\n\n                    _this4.img.onload = function () {\n                      var _getColor = new ColorThief().getColor(_this4.img),\n                          _getColor2 = _slicedToArray(_getColor, 3),\n                          r = _getColor2[0],\n                          g = _getColor2[1],\n                          b = _getColor2[2];\n\n                      var theme = \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\");\n                      resolve(theme || _this4.currentMusic.theme || _this4.theme);\n                    };\n\n                    _this4.img.onabort = reject;\n                    _this4.img.onerror = reject;\n                  };\n\n                  reader.onabort = reject;\n                  reader.onerror = reject;\n                  reader.readAsDataURL(image);\n                  _context7.next = 13;\n                  break;\n\n                case 12:\n                  resolve(_this4.currentMusic.theme || _this4.theme);\n\n                case 13:\n                  _context7.next = 18;\n                  break;\n\n                case 15:\n                  _context7.prev = 15;\n                  _context7.t0 = _context7[\"catch\"](0);\n                  resolve(_this4.currentMusic.theme || _this4.theme);\n\n                case 18:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee7, this, [[0, 15]]);\n        }));\n\n        return function (_x8, _x9) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n    }\n  }, {\n    key: \"getAudioUrl\",\n    value: function getAudioUrl(music) {\n      var _this5 = this;\n\n      return new Promise(function (resolve, reject) {\n        var type = music.type;\n\n        if (type && _this5.customAudioType && _this5.customAudioType[type]) {\n          if (typeof _this5.customAudioType[type] === 'function') {\n            _this5.customAudioType[type](_this5.player, music, _this5);\n          } else {\n            // eslint-disable-next-line no-console\n            console.error(\"Illegal customType: \".concat(type));\n          }\n\n          resolve();\n        } else {\n          if (!type || type === 'auto') {\n            type = /m3u8(#|\\?|$)/i.test(music.url) ? 'hls' : 'normal';\n          }\n\n          if (type === 'hls') {\n            try {\n              if (Hls.isSupported()) {\n                var hls = new Hls();\n                hls.loadSource(music.url);\n                hls.attachMedia(_this5.player);\n                resolve();\n              } else if (_this5.player.canPlayType('application/x-mpegURL') || _this5.player.canPlayType('application/vnd.apple.mpegURL')) {\n                resolve(music.url);\n              } else {\n                reject(new Error('HLS is not supported.'));\n              }\n            } catch (e) {\n              reject(new Error('HLS is not supported.'));\n            }\n          } else {\n            resolve(music.url);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"getPlayIndexByMode\",\n    value: function getPlayIndexByMode(type) {\n      var length = this.currentList.length;\n      var index = this.currentIndex;\n      return (type === 'skipBack' ? length + (index - 1) : index + 1) % length;\n    }\n  }, {\n    key: \"pauseOtherInstances\",\n    value: function pauseOtherInstances() {\n      var _this6 = this;\n\n      instances.filter(function (inst) {\n        return inst !== _this6;\n      }).forEach(function (inst) {\n        return inst.pause();\n      });\n    }\n  }, {\n    key: \"saveSettings\",\n    value: function saveSettings(settings) {\n      var instanceIndex = instances.indexOf(this);\n      if (settings === null) delete instances[instanceIndex];\n      this.store.set(this.settings[instanceIndex] !== undefined ? this.settings.map(function (item, index) {\n        return index === instanceIndex ? settings : item;\n      }) : _toConsumableArray(this.settings).concat([settings]));\n    } // #endregion\n    // #region 事件处理\n    // 切换上一曲\n\n  }, {\n    key: \"handleSkipBack\",\n    value: function handleSkipBack() {\n      this.skipBack();\n    } // 切换下一曲\n\n  }, {\n    key: \"handleSkipForward\",\n    value: function handleSkipForward() {\n      this.skipForward();\n    } // 切换播放\n\n  }, {\n    key: \"handleTogglePlay\",\n    value: function handleTogglePlay() {\n      this.toggle();\n    } // 处理切换顺序模式\n\n  }, {\n    key: \"handleToggleOrderMode\",\n    value: function handleToggleOrderMode() {\n      this.currentOrder = this.currentOrder === 'list' ? 'random' : 'list';\n    } // 处理切换循环模式\n\n  }, {\n    key: \"handleToggleLoopMode\",\n    value: function handleToggleLoopMode() {\n      this.currentLoop = this.currentLoop === 'all' ? 'one' : this.currentLoop === 'one' ? 'none' : 'all';\n    } // 处理切换播放/暂停事件\n\n  }, {\n    key: \"handleTogglePlaylist\",\n    value: function handleTogglePlaylist() {\n      this.toggleList();\n    } // 处理切换歌词显隐事件\n\n  }, {\n    key: \"handleToggleLyric\",\n    value: function handleToggleLyric() {\n      this.toggleLrc();\n    } // 处理进度条改变事件\n\n  }, {\n    key: \"handleChangeProgress\",\n    value: function handleChangeProgress(e, percent) {\n      this.currentPlayed = percent;\n      this.isDraggingProgressBar = e.type.includes('move');\n\n      if (['touchend', 'mouseup'].includes(e.type)) {\n        this.seeking(percent, this.media.paused); // preload 为 none 的情况下无法获取到 duration\n      }\n    } // 处理切换迷你模式事件\n\n  }, {\n    key: \"handleMiniSwitcher\",\n    value: function handleMiniSwitcher() {\n      this.isMini = !this.isMini;\n    } // 处理播放曲目改变事件\n\n  }, {\n    key: \"handleChangePlaylist\",\n    value: function handleChangePlaylist(music, index) {\n      if (music.id === this.currentMusic.id) this.handleTogglePlay();else this.currentMusic = this.orderList[index];\n    } // #endregion\n\n  }, {\n    key: \"beforeMount\",\n    value: function beforeMount() {\n      var _this7 = this;\n\n      this.store.key = this.storageName;\n      var emptyIndex = instances.findIndex(function (x) {\n        return !x;\n      });\n      if (emptyIndex > -1) instances[emptyIndex] = this;else instances.push(this);\n\n      if (this.currentSettings) {\n        var _this$currentSettings = this.currentSettings,\n            mini = _this$currentSettings.mini,\n            lrc = _this$currentSettings.lrc,\n            list = _this$currentSettings.list,\n            volume = _this$currentSettings.volume,\n            loop = _this$currentSettings.loop,\n            order = _this$currentSettings.order,\n            music = _this$currentSettings.music,\n            currentTime = _this$currentSettings.currentTime,\n            duration = _this$currentSettings.duration,\n            paused = _this$currentSettings.paused;\n        this.isMini = mini;\n        this.lyricVisible = lrc;\n        this.listVisible = list;\n        this.currentVolume = volume;\n        this.currentLoop = loop;\n        this.currentOrder = order;\n\n        if (music) {\n          this.currentMusic = music;\n\n          if (!this.isMobile && duration) {\n            this.seeking(currentTime / duration, paused);\n          }\n        }\n      } // 处理多页面互斥\n\n\n      if (channel) {\n        if (this.mutex) {\n          channel.addEventListener('message', function (_ref3) {\n            var data = _ref3.data;\n            if (data === 'mutex') _this7.pause();\n          });\n        }\n      } else {// 不支持 BroadcastChannel，暂不处理\n      }\n\n      events.forEach(function (event) {\n        _this7.player.addEventListener(event, function (e) {\n          return _this7.$emit(event, e);\n        });\n      });\n    }\n  }, {\n    key: \"beforeDestroy\",\n    value: function beforeDestroy() {\n      this.pause();\n      this.saveSettings(null);\n      this.$emit('destroy');\n      this.$el.remove();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var h = arguments[0];\n      var dataSource = this.dataSource,\n          fixed = this.fixed,\n          lrcType = this.lrcType,\n          isMini = this.isMini,\n          isMobile = this.isMobile,\n          isArrow = this.isArrow,\n          isLoading = this.isLoading,\n          notice = this.notice,\n          listVisible = this.listVisible,\n          listScrollTop = this.listScrollTop,\n          currentMusic = this.currentMusic,\n          lyricVisible = this.lyricVisible;\n      return h(\"div\", {\n        ref: \"container\",\n        \"class\": classnames_default()({\n          aplayer: true,\n          'aplayer-withlist': dataSource.length > 1,\n          'aplayer-withlrc': !fixed && lrcType !== 0 && lyricVisible,\n          'aplayer-narrow': isMini,\n          'aplayer-fixed': fixed,\n          'aplayer-mobile': isMobile,\n          'aplayer-arrow': isArrow,\n          'aplayer-loading': isLoading\n        })\n      }, [h(components_Player, {\n        attrs: {\n          notice: notice\n        },\n        on: {\n          \"skipBack\": this.handleSkipBack,\n          \"skipForward\": this.handleSkipForward,\n          \"togglePlay\": this.handleTogglePlay,\n          \"toggleOrderMode\": this.handleToggleOrderMode,\n          \"toggleLoopMode\": this.handleToggleLoopMode,\n          \"togglePlaylist\": this.handleTogglePlaylist,\n          \"toggleLyric\": this.handleToggleLyric,\n          \"changeVolume\": this.handleChangeVolume,\n          \"changeProgress\": this.handleChangeProgress,\n          \"miniSwitcher\": this.handleMiniSwitcher\n        }\n      }), h(components_PlayList, {\n        attrs: {\n          visible: listVisible,\n          scrollTop: listScrollTop,\n          currentMusic: currentMusic,\n          dataSource: dataSource\n        },\n        on: {\n          \"change\": this.handleChangePlaylist\n        }\n      }), fixed && lrcType !== 0 ? h(components_Lyric, {\n        attrs: {\n          visible: lyricVisible\n        }\n      }) : null]);\n    }\n  }, {\n    key: \"aplayer\",\n    get: function get() {\n      return this;\n    }\n  }, {\n    key: \"settings\",\n    get: function get() {\n      return this.store.store;\n    }\n  }, {\n    key: \"currentSettings\",\n    get: function get() {\n      return this.settings[instances.indexOf(this)];\n    } // 当前播放模式对应的播放列表\n\n  }, {\n    key: \"currentList\",\n    get: function get() {\n      return this.currentOrder === 'list' ? this.orderList : this.randomList;\n    } // 数据源，自动生成 ID 作为播放列表项的 key\n\n  }, {\n    key: \"dataSource\",\n    get: function get() {\n      return (Array.isArray(this.audio) ? this.audio : [this.audio]).filter(function (x) {\n        return x;\n      }).map(function (item, index) {\n        return _objectSpread({\n          id: index + 1\n        }, item);\n      });\n    } // 根据数据源生成顺序播放列表（处理 VNode）\n\n  }, {\n    key: \"orderList\",\n    get: function get() {\n      var text = function text(vnode, key) {\n        return typeof vnode === 'string' ? vnode : vnode.data && vnode.data.attrs && vnode.data.attrs[\"data-\".concat(key)];\n      };\n\n      return this.dataSource.map(function (_ref4) {\n        var name = _ref4.name,\n            artist = _ref4.artist,\n            item = _objectWithoutProperties(_ref4, [\"name\", \"artist\"]);\n\n        return _objectSpread({}, item, {\n          name: text(name, 'name'),\n          artist: text(artist, 'artist')\n        });\n      });\n    } // 根据顺序播放列表生成随机播放列表\n\n  }, {\n    key: \"randomList\",\n    get: function get() {\n      return shuffle(_toConsumableArray(this.orderList));\n    } // 是否正在缓冲\n\n  }, {\n    key: \"isLoading\",\n    get: function get() {\n      var preload = this.preload,\n          currentPlayed = this.currentPlayed,\n          currentLoaded = this.currentLoaded;\n      var _this$media = this.media,\n          src = _this$media.src,\n          paused = _this$media.paused,\n          duration = _this$media.duration;\n      var loading = !!src && (currentPlayed > currentLoaded || !duration);\n      return preload === 'none' ? !paused && loading : loading;\n    }\n  }, {\n    key: \"listScrollTop\",\n    get: function get() {\n      return this.currentOrderIndex * 33;\n    } // 当前播放的音乐索引\n\n  }, {\n    key: \"currentIndex\",\n    get: function get() {\n      return this.currentOrder === 'list' ? this.currentOrderIndex : this.currentRandomIndex;\n    }\n  }, {\n    key: \"currentOrderIndex\",\n    get: function get() {\n      var _this$currentMusic2 = this.currentMusic,\n          id = _this$currentMusic2.id,\n          url = _this$currentMusic2.url;\n      return this.orderList.findIndex(function (item) {\n        return item.id === id || item.url === url;\n      });\n    }\n  }, {\n    key: \"currentRandomIndex\",\n    get: function get() {\n      var _this$currentMusic3 = this.currentMusic,\n          id = _this$currentMusic3.id,\n          url = _this$currentMusic3.url;\n      return this.randomList.findIndex(function (item) {\n        return item.id === id || item.url === url;\n      });\n    } // 当前已缓冲比例\n\n  }, {\n    key: \"currentLoaded\",\n    get: function get() {\n      if (this.media.readyState < ReadyState.HAVE_FUTURE_DATA) return 0;\n      var length = this.media.buffered.length;\n      return length > 0 ? this.media.buffered.end(length - 1) / this.media.duration : 1;\n    }\n  }]);\n\n  return APlayer;\n}(lib[\"Component\"]);\n\nAPlayer_APlayer.version = \"2.0.0-beta.5\";\n\nAPlayer_decorate([Prop({\n  type: Boolean,\n  required: false,\n  default: false\n}), APlayer_metadata(\"design:type\", Boolean)], APlayer_APlayer.prototype, \"fixed\", void 0);\n\nAPlayer_decorate([Prop({\n  type: Boolean,\n  required: false,\n  default: null\n}), APlayer_metadata(\"design:type\", Boolean)], APlayer_APlayer.prototype, \"mini\", void 0);\n\nAPlayer_decorate([Prop({\n  type: Boolean,\n  required: false,\n  default: false\n}), APlayer_metadata(\"design:type\", Boolean)], APlayer_APlayer.prototype, \"autoplay\", void 0);\n\nAPlayer_decorate([Prop({\n  type: String,\n  required: false,\n  default: '#b7daff'\n}), APlayer_metadata(\"design:type\", String)], APlayer_APlayer.prototype, \"theme\", void 0);\n\nAPlayer_decorate([Prop({\n  type: String,\n  required: false,\n  default: 'all'\n}), APlayer_metadata(\"design:type\", typeof (APlayer_a = typeof APlayer_APlayer !== \"undefined\" && APlayer_APlayer.LoopMode) === \"function\" ? APlayer_a : Object)], APlayer_APlayer.prototype, \"loop\", void 0);\n\nAPlayer_decorate([Prop({\n  type: String,\n  required: false,\n  default: 'list'\n}), APlayer_metadata(\"design:type\", typeof (APlayer_b = typeof APlayer_APlayer !== \"undefined\" && APlayer_APlayer.OrderMode) === \"function\" ? APlayer_b : Object)], APlayer_APlayer.prototype, \"order\", void 0);\n\nAPlayer_decorate([Prop({\n  type: String,\n  required: false,\n  default: 'auto'\n}), APlayer_metadata(\"design:type\", typeof (APlayer_c = typeof APlayer_APlayer !== \"undefined\" && APlayer_APlayer.Preload) === \"function\" ? APlayer_c : Object)], APlayer_APlayer.prototype, \"preload\", void 0);\n\nAPlayer_decorate([Prop({\n  type: Number,\n  required: false,\n  default: 0.7\n}), APlayer_metadata(\"design:type\", Number)], APlayer_APlayer.prototype, \"volume\", void 0);\n\nAPlayer_decorate([Prop({\n  type: [Object, Array],\n  required: true\n}), APlayer_metadata(\"design:type\", Object)], APlayer_APlayer.prototype, \"audio\", void 0);\n\nAPlayer_decorate([Prop({\n  type: Object,\n  required: false\n}), APlayer_metadata(\"design:type\", Object)], APlayer_APlayer.prototype, \"customAudioType\", void 0);\n\nAPlayer_decorate([Prop({\n  type: Boolean,\n  required: false,\n  default: true\n}), APlayer_metadata(\"design:type\", Boolean)], APlayer_APlayer.prototype, \"mutex\", void 0);\n\nAPlayer_decorate([Prop({\n  type: Number,\n  required: false,\n  default: 0\n}), APlayer_metadata(\"design:type\", typeof (_f = typeof APlayer_APlayer !== \"undefined\" && APlayer_APlayer.LrcType) === \"function\" ? _f : Object)], APlayer_APlayer.prototype, \"lrcType\", void 0);\n\nAPlayer_decorate([Prop({\n  type: Boolean,\n  required: false,\n  default: false\n}), APlayer_metadata(\"design:type\", Boolean)], APlayer_APlayer.prototype, \"listFolded\", void 0);\n\nAPlayer_decorate([Prop({\n  type: Number,\n  required: false,\n  default: 250\n}), APlayer_metadata(\"design:type\", Number)], APlayer_APlayer.prototype, \"listMaxHeight\", void 0);\n\nAPlayer_decorate([Prop({\n  type: String,\n  required: false,\n  default: 'aplayer-setting'\n}), APlayer_metadata(\"design:type\", String)], APlayer_APlayer.prototype, \"storageName\", void 0);\n\nAPlayer_decorate([Provide(), APlayer_metadata(\"design:type\", Object), APlayer_metadata(\"design:paramtypes\", [])], APlayer_APlayer.prototype, \"aplayer\", null);\n\nAPlayer_decorate([Watch('orderList', {\n  immediate: true,\n  deep: true\n}), APlayer_metadata(\"design:type\", Function), APlayer_metadata(\"design:paramtypes\", [Array, Array]), APlayer_metadata(\"design:returntype\", Promise)], APlayer_APlayer.prototype, \"handleChangePlayList\", null);\n\nAPlayer_decorate([Watch('currentMusic', {\n  immediate: true,\n  deep: true\n}), APlayer_metadata(\"design:type\", Function), APlayer_metadata(\"design:paramtypes\", [typeof (_g = typeof APlayer_APlayer !== \"undefined\" && APlayer_APlayer.Audio) === \"function\" ? _g : Object, typeof (_h = typeof APlayer_APlayer !== \"undefined\" && APlayer_APlayer.Audio) === \"function\" ? _h : Object]), APlayer_metadata(\"design:returntype\", Promise)], APlayer_APlayer.prototype, \"handleChangeCurrentMusic\", null);\n\nAPlayer_decorate([Watch('volume'), APlayer_metadata(\"design:type\", Function), APlayer_metadata(\"design:paramtypes\", [Number]), APlayer_metadata(\"design:returntype\", void 0)], APlayer_APlayer.prototype, \"handleChangeVolume\", null);\n\nAPlayer_decorate([Watch('currentVolume'), APlayer_metadata(\"design:type\", Function), APlayer_metadata(\"design:paramtypes\", []), APlayer_metadata(\"design:returntype\", void 0)], APlayer_APlayer.prototype, \"handleChangeCurrentVolume\", null);\n\nAPlayer_decorate([Watch('media.currentTime'), APlayer_metadata(\"design:type\", Function), APlayer_metadata(\"design:paramtypes\", []), APlayer_metadata(\"design:returntype\", void 0)], APlayer_APlayer.prototype, \"handleChangeCurrentTime\", null);\n\nAPlayer_decorate([Watch('media.$data', {\n  deep: true\n}), APlayer_metadata(\"design:type\", Function), APlayer_metadata(\"design:paramtypes\", []), APlayer_metadata(\"design:returntype\", void 0)], APlayer_APlayer.prototype, \"handleChangeSettings\", null);\n\nAPlayer_decorate([Watch('media.ended'), APlayer_metadata(\"design:type\", Function), APlayer_metadata(\"design:paramtypes\", []), APlayer_metadata(\"design:returntype\", void 0)], APlayer_APlayer.prototype, \"handleChangeEnded\", null);\n\nAPlayer_decorate([Watch('mini'), APlayer_metadata(\"design:type\", Function), APlayer_metadata(\"design:paramtypes\", []), APlayer_metadata(\"design:returntype\", void 0)], APlayer_APlayer.prototype, \"handleChangeMini\", null);\n\nAPlayer_decorate([Watch('isMini', {\n  immediate: true\n}), APlayer_metadata(\"design:type\", Function), APlayer_metadata(\"design:paramtypes\", [Boolean, Boolean]), APlayer_metadata(\"design:returntype\", Promise)], APlayer_APlayer.prototype, \"handleChangeCurrentMini\", null);\n\nAPlayer_decorate([Watch('loop'), APlayer_metadata(\"design:type\", Function), APlayer_metadata(\"design:paramtypes\", []), APlayer_metadata(\"design:returntype\", void 0)], APlayer_APlayer.prototype, \"handleChangeLoop\", null);\n\nAPlayer_decorate([Watch('currentLoop'), APlayer_metadata(\"design:type\", Function), APlayer_metadata(\"design:paramtypes\", []), APlayer_metadata(\"design:returntype\", void 0)], APlayer_APlayer.prototype, \"handleChangeCurrentLoop\", null);\n\nAPlayer_decorate([Watch('order'), APlayer_metadata(\"design:type\", Function), APlayer_metadata(\"design:paramtypes\", []), APlayer_metadata(\"design:returntype\", void 0)], APlayer_APlayer.prototype, \"handleChangeOrder\", null);\n\nAPlayer_decorate([Watch('currentOrder'), APlayer_metadata(\"design:type\", Function), APlayer_metadata(\"design:paramtypes\", []), APlayer_metadata(\"design:returntype\", void 0)], APlayer_APlayer.prototype, \"handleChangeCurrentOrder\", null);\n\nAPlayer_decorate([Watch('listVisible'), APlayer_metadata(\"design:type\", Function), APlayer_metadata(\"design:paramtypes\", []), APlayer_metadata(\"design:returntype\", void 0)], APlayer_APlayer.prototype, \"handleChangeListVisible\", null);\n\nAPlayer_decorate([Watch('lyricVisible'), APlayer_metadata(\"design:type\", Function), APlayer_metadata(\"design:paramtypes\", []), APlayer_metadata(\"design:returntype\", void 0)], APlayer_APlayer.prototype, \"handleChangeLyricVisible\", null);\n\nAPlayer_APlayer = APlayer_decorate([vue_class_component_common_default()({\n  mixins: [mixin]\n})], APlayer_APlayer);\n/* harmony default export */ var components_APlayer = (APlayer_APlayer);\n// CONCATENATED MODULE: ./packages/@moefe/vue-aplayer/index.ts\n\n\n\n\nfunction install(Vue, options) {\n  var defaultOptions = {\n    productionTip: true,\n    defaultCover: 'https://avatars2.githubusercontent.com/u/20062482?s=270'\n  };\n\n  var opts = _objectSpread({}, defaultOptions, options);\n\n  Object.assign(components_APlayer.prototype, {\n    options: opts\n  });\n  Vue.component('aplayer', components_APlayer);\n  Vue.component('APlayer', components_APlayer);\n\n  if (opts.productionTip) {\n    // eslint-disable-next-line no-console\n    console.log(\"%c vue-aplayer %c v\".concat(\"2.0.0-beta.5\", \" \").concat(\"dd10c50\", \" %c\"), 'background: #35495e; padding: 1px; border-radius: 3px 0 0 3px; color: #fff', 'background: #41b883; padding: 1px; border-radius: 0 3px 3px 0; color: #fff', 'background: transparent');\n  }\n}\n// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js\n/* concated harmony reexport APlayer */__webpack_require__.d(__webpack_exports__, \"APlayer\", function() { return components_APlayer; });\n\n\n/* harmony default export */ var entry_lib = __webpack_exports__[\"default\"] = (install);\n\n\n\n/***/ }),\n\n/***/ \"fdef\":\n/***/ (function(module, exports) {\n\nmodule.exports = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n  '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=VueAPlayer.common.js.map"]}]}